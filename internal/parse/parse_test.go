package parse

import (
	"context"
	"strings"
	"testing"
	"time"

	"github.com/inoxlang/inox/internal/ast"
	"github.com/inoxlang/inox/internal/sourcecode"
	utils "github.com/inoxlang/inox/internal/utils/common"
	"github.com/stretchr/testify/assert"
)

func TestParseNoContext(t *testing.T) {
	testParse(t, func(t *testing.T, str string) (result *ast.Chunk) {
		return mustParseChunkForgetTokens(str)
	}, func(t *testing.T, str, name string) (result *ast.Chunk, err error) {
		return parseChunkForgetTokens(str, name)
	})
}

//TODO: add more specific tests for testing context checks.

func testParse(
	t *testing.T,
	mustparseChunk func(t *testing.T, str string) (result *ast.Chunk),
	parseChunk func(t *testing.T, str string, name string) (result *ast.Chunk, err error),
) {

	t.Run("module", func(t *testing.T) {

		t.Run("empty", func(t *testing.T) {
			n := mustparseChunk(t, "")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 0}, nil, false},
			}, n)
		})

		t.Run("comment with missing space", func(t *testing.T) {
			n, err := parseChunk(t, "#", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
				Statements: []ast.Node{
					&ast.UnambiguousIdentifierLiteral{
						NodeBase: ast.NodeBase{
							Span: NodeSpan{0, 1},
							Err:  &sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_IDENTIFIER_LIT},
						},
					},
				},
			}, n)

			aggregation := err.(*sourcecode.ParsingErrorAggregation)
			assert.Equal(t, []*sourcecode.ParsingError{{UnspecifiedParsingError, UNTERMINATED_IDENTIFIER_LIT}}, aggregation.Errors)
			assert.Equal(t, []sourcecode.PositionRange{
				{StartLine: 1, StartColumn: 1, EndLine: 1, EndColumn: 2, Span: NodeSpan{0, 1}},
			}, aggregation.ErrorPositions)
		})

		t.Run("shebang", func(t *testing.T) {
			n := mustparseChunk(t, "#!/usr/local/bin/inox")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: nil,
			}, n)
		})

		t.Run("unexpected char: ]", func(t *testing.T) {
			n, err := parseChunk(t, "]", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
				Statements: []ast.Node{
					&ast.UnknownNode{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 1},
							&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInBlockOrModule(']')},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("unexpected char: <", func(t *testing.T) {
			n, err := parseChunk(t, "<", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
				Statements: []ast.Node{
					&ast.UnknownNode{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 1},
							&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInBlockOrModule('<')},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("non regular space", func(t *testing.T) {
			n, err := parseChunk(t, " ", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
				Statements: []ast.Node{
					&ast.UnknownNode{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 1},
							&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInBlockOrModule(' ')},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("carriage return", func(t *testing.T) {
			n := mustparseChunk(t, "\r")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
			}, n)
		})

		t.Run("line feed", func(t *testing.T) {
			n := mustparseChunk(t, "\n")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 1},
					nil,
					false,
				},
			}, n)
		})

		t.Run("two line feeds", func(t *testing.T) {
			n := mustparseChunk(t, "\n\n")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 2}},
			}, n)
		})

		t.Run("carriage return + line feed", func(t *testing.T) {
			n := mustparseChunk(t, "\r\n")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 2}},
			}, n)
		})

		t.Run("twice: carriage return + line feed", func(t *testing.T) {
			n := mustparseChunk(t, "\r\n\r\n")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
			}, n)
		})

		t.Run("two lines with one statement per line", func(t *testing.T) {
			n := mustparseChunk(t, "1\n2")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 3}},
				Statements: []ast.Node{
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
						Raw:      "1",
						Value:    1,
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
						Raw:      "2",
						Value:    2,
					},
				},
			}, n)
		})

		t.Run("two lines with one statement per line, followed by line feed character", func(t *testing.T) {
			n := mustparseChunk(t, "1\n2\n")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
				Statements: []ast.Node{
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
						Raw:      "1",
						Value:    1,
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
						Raw:      "2",
						Value:    2,
					},
				},
			}, n)
		})

		t.Run("statements next to each other", func(t *testing.T) {
			n, err := parseChunk(t, "1$v", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
						Raw:      "1",
						Value:    1,
					},
					&ast.Variable{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 3},
							&sourcecode.ParsingError{UnspecifiedParsingError, STMTS_SHOULD_BE_SEPARATED_BY},
							false,
						},
						Name: "v",
					},
				},
			}, n)
		})

		t.Run("empty preinit", func(t *testing.T) {
			n := mustparseChunk(t, "preinit {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: nil,
				Preinit: &ast.PreinitStatement{
					NodeBase: ast.NodeBase{
						Span:            NodeSpan{0, 10},
						IsParenthesized: false,
					},
					Block: &ast.Block{
						NodeBase: ast.NodeBase{Span: NodeSpan{8, 10}},
					},
				},
			}, n)
		})

		t.Run("empty preinit after line feed", func(t *testing.T) {
			n := mustparseChunk(t, "\npreinit {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{Span: NodeSpan{0, 11}},
				Statements: nil,
				Preinit: &ast.PreinitStatement{
					NodeBase: ast.NodeBase{
						Span:            NodeSpan{1, 11},
						IsParenthesized: false,
					},
					Block: &ast.Block{
						NodeBase: ast.NodeBase{Span: NodeSpan{9, 11}},
					},
				},
			}, n)
		})

		t.Run("preinit with missing block", func(t *testing.T) {
			n, err := parseChunk(t, "preinit", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: nil,
				Preinit: &ast.PreinitStatement{
					NodeBase: ast.NodeBase{
						Span:            NodeSpan{0, 7},
						Err:             &sourcecode.ParsingError{UnspecifiedParsingError, PREINIT_KEYWORD_SHOULD_BE_FOLLOWED_BY_A_BLOCK},
						IsParenthesized: false,
					},
				},
			}, n)
		})

		t.Run("empty manifest", func(t *testing.T) {
			n := mustparseChunk(t, "manifest {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: nil,
				Manifest: &ast.Manifest{
					NodeBase: ast.NodeBase{
						Span:            NodeSpan{0, 11},
						IsParenthesized: false,
					},
					Object: &ast.ObjectLiteral{
						NodeBase:   ast.NodeBase{Span: NodeSpan{9, 11}},
						Properties: nil,
					},
				},
			}, n)
		})

		t.Run("empty manifest after line feed", func(t *testing.T) {
			n := mustparseChunk(t, "\nmanifest {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{Span: NodeSpan{0, 12}},
				Statements: nil,
				Manifest: &ast.Manifest{
					NodeBase: ast.NodeBase{
						Span:            NodeSpan{1, 12},
						IsParenthesized: false,
					},
					Object: &ast.ObjectLiteral{
						NodeBase:   ast.NodeBase{Span: NodeSpan{10, 12}},
						Properties: nil,
					},
				},
			}, n)
		})

		t.Run("empty manifest after preinit", func(t *testing.T) {
			n := mustparseChunk(t, "preinit {}\nmanifest {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{Span: NodeSpan{0, 22}},
				Statements: nil,
				Preinit: &ast.PreinitStatement{
					NodeBase: ast.NodeBase{
						Span:            NodeSpan{0, 10},
						IsParenthesized: false,
					},
					Block: &ast.Block{
						NodeBase: ast.NodeBase{Span: NodeSpan{8, 10}},
					},
				},
				Manifest: &ast.Manifest{
					NodeBase: ast.NodeBase{
						Span:            NodeSpan{11, 22},
						IsParenthesized: false,
					},
					Object: &ast.ObjectLiteral{
						NodeBase:   ast.NodeBase{Span: NodeSpan{20, 22}},
						Properties: nil,
					},
				},
			}, n)
		})

		t.Run("manifest with multiline object literal", func(t *testing.T) {
			n := mustparseChunk(t, "manifest {a:1\nb:2}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: nil,
				Manifest: &ast.Manifest{
					NodeBase: ast.NodeBase{
						Span:            NodeSpan{0, 18},
						IsParenthesized: false,
					},
					Object: &ast.ObjectLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{9, 18}},
						Properties: []*ast.ObjectProperty{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 13},
									nil,
									false,
								},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{10, 11}},
									Name:     "a",
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{12, 13}},
									Value:    1,
									Raw:      "1",
								},
							},
							{
								NodeBase: ast.NodeBase{
									NodeSpan{14, 17},
									nil,
									false,
								},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{14, 15}},
									Name:     "b",
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{16, 17}},
									Value:    2,
									Raw:      "2",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("includable-file", func(t *testing.T) {
			n := mustparseChunk(t, "includable-file")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: nil,
				IncludableChunkDesc: &ast.IncludableChunkDescription{
					NodeBase: ast.NodeBase{
						Span:            NodeSpan{0, 15},
						IsParenthesized: false,
					},
				},
			}, n)
		})

		t.Run("includable-file after line feed", func(t *testing.T) {
			n := mustparseChunk(t, "\nincludable-file")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{Span: NodeSpan{0, 16}},
				Statements: nil,
				IncludableChunkDesc: &ast.IncludableChunkDescription{
					NodeBase: ast.NodeBase{
						Span:            NodeSpan{1, 16},
						IsParenthesized: false,
					},
				},
			}, n)
		})

		t.Run("annotated function declaration: linefeed after annotation", func(t *testing.T) {
			n := mustparseChunk(t, "@a\nfn f(){}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					Span: NodeSpan{0, 11},
				},
				Statements: []ast.Node{
					&ast.FunctionDeclaration{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
						Annotations: &ast.MetadataAnnotations{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 3}},
							Expressions: []ast.Node{
								&ast.MetaIdentifier{
									NodeBase: ast.NodeBase{Span: NodeSpan{0, 2}},
									Name:     "a",
								},
							},
						},
						Name: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{6, 7}},
							Name:     "f",
						},
						Function: &ast.FunctionExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{3, 11}},
							Body: &ast.Block{
								NodeBase: ast.NodeBase{Span: NodeSpan{9, 11}},
							},
						},
					},
				},
			}, n)
		})

		t.Run("annotated function declaration: two annotations with a linefeed after each annotation", func(t *testing.T) {
			n := mustparseChunk(t, "@a\n@b\nfn f(){}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					Span: NodeSpan{0, 14},
				},
				Statements: []ast.Node{
					&ast.FunctionDeclaration{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
						Annotations: &ast.MetadataAnnotations{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
							Expressions: []ast.Node{
								&ast.MetaIdentifier{
									NodeBase: ast.NodeBase{Span: NodeSpan{0, 2}},
									Name:     "a",
								},
								&ast.MetaIdentifier{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 5}},
									Name:     "b",
								},
							},
						},
						Name: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{9, 10}},
							Name:     "f",
						},
						Function: &ast.FunctionExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{6, 14}},
							Body: &ast.Block{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 14}},
							},
						},
					},
				},
			}, n)
		})

		t.Run("annotated function declaration: comment+linefeed after annotation", func(t *testing.T) {
			n := mustparseChunk(t, "@a# x\nfn f(){}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					Span: NodeSpan{0, 14},
				},
				Statements: []ast.Node{
					&ast.FunctionDeclaration{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
						Annotations: &ast.MetadataAnnotations{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
							Expressions: []ast.Node{
								&ast.MetaIdentifier{
									NodeBase: ast.NodeBase{Span: NodeSpan{0, 2}},
									Name:     "a",
								},
							},
						},
						Name: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{9, 10}},
							Name:     "f",
						},
						Function: &ast.FunctionExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{6, 14}},
							Body: &ast.Block{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 14}},
							},
						},
					},
				},
			}, n)
		})

		t.Run("annotation followed by linefeed + comment ", func(t *testing.T) {
			n, err := parseChunk(t, "@a\n# x", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					Span: NodeSpan{0, 6},
				},
				Statements: []ast.Node{
					&ast.MissingStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							&sourcecode.ParsingError{UnspecifiedParsingError, MISSING_STMT_AFTER_ANNOTATIONS_EXPR_EXPLANATION},
							false,
						},
						Annotations: &ast.MetadataAnnotations{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
							Expressions: []ast.Node{
								&ast.MetaIdentifier{
									NodeBase: ast.NodeBase{Span: NodeSpan{0, 2}},
									Name:     "a",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("annotation followed by two linefeeds", func(t *testing.T) {
			n, err := parseChunk(t, "@a\n\nfn f(){}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					Span: NodeSpan{0, 12},
				},
				Statements: []ast.Node{
					&ast.MissingStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							&sourcecode.ParsingError{UnspecifiedParsingError, MISSING_STMT_AFTER_ANNOTATIONS_EXPR_EXPLANATION},
							false,
						},
						Annotations: &ast.MetadataAnnotations{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
							Expressions: []ast.Node{
								&ast.MetaIdentifier{
									NodeBase: ast.NodeBase{Span: NodeSpan{0, 2}},
									Name:     "a",
								},
							},
						},
					},
					&ast.FunctionDeclaration{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
						Annotations: &ast.MetadataAnnotations{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
							Expressions: []ast.Node{
								&ast.MetaIdentifier{
									NodeBase: ast.NodeBase{Span: NodeSpan{0, 2}},
									Name:     "a",
								},
							},
						},
						Name: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{7, 8}},
							Name:     "f",
						},
						Function: &ast.FunctionExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 12}},
							Body: &ast.Block{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 12}},
							},
						},
					},
				},
			}, n)
		})

		t.Run("annotation followed by statement that does not support annotations", func(t *testing.T) {
			n, err := parseChunk(t, "@a\n1", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					Span: NodeSpan{0, 4},
				},
				Statements: []ast.Node{
					&ast.MissingStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							&sourcecode.ParsingError{UnspecifiedParsingError, METADATA_ANNOTATIONS_SHOULD_BE_FOLLOWED_BY_STMT_SUPPORTING_THEM},
							false,
						},
						Annotations: &ast.MetadataAnnotations{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 3}},
							Expressions: []ast.Node{
								&ast.MetaIdentifier{
									NodeBase: ast.NodeBase{Span: NodeSpan{0, 2}},
									Name:     "a",
								},
							},
						},
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{3, 4}},
						Raw:      "1",
						Value:    1,
					},
				},
			}, n)
		})

		t.Run("annotated region header: only text", func(t *testing.T) {
			n := mustparseChunk(t, "@'a'")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					Span: NodeSpan{0, 4},
				},
				RegionHeaders: []*ast.AnnotatedRegionHeader{
					{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
						Text: &ast.AnnotatedRegionHeaderText{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
							Raw:      "@'a'",
							Value:    "a",
						},
					},
				},
			}, n)
		})

		t.Run("annotated region header: text followed by a statement on the same line", func(t *testing.T) {
			n, err := parseChunk(t, "@'a' 1", "") //missing delimiter at the end of the header
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
				RegionHeaders: []*ast.AnnotatedRegionHeader{
					{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							&sourcecode.ParsingError{UnspecifiedParsingError, MISSING_DELIMITER_AFTER_ANNOTATED_REGION_HEADER},
							false,
						},
						Text: &ast.AnnotatedRegionHeaderText{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
							Raw:      "@'a'",
							Value:    "a",
						},
					},
				},
				Statements: []ast.Node{
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{5, 6}},
						Raw:      "1",
						Value:    1,
					},
				},
			}, n)
		})

		t.Run("annotated region header: text followed by a semicolon and a statement on the same line", func(t *testing.T) {
			n := mustparseChunk(t, "@'a';1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
				RegionHeaders: []*ast.AnnotatedRegionHeader{
					{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
						Text: &ast.AnnotatedRegionHeaderText{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
							Raw:      "@'a'",
							Value:    "a",
						},
					},
				},
				Statements: []ast.Node{
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{5, 6}},
						Raw:      "1",
						Value:    1,
					},
				},
			}, n)
		})

		t.Run("annotated region header: text followed by a statement on the next line", func(t *testing.T) {
			n := mustparseChunk(t, "@'a'\n1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					Span: NodeSpan{0, 6},
				},
				RegionHeaders: []*ast.AnnotatedRegionHeader{
					{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
						Text: &ast.AnnotatedRegionHeaderText{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
							Raw:      "@'a'",
							Value:    "a",
						},
					},
				},
				Statements: []ast.Node{
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{5, 6}},
						Raw:      "1",
						Value:    1,
					},
				},
			}, n)
		})

		t.Run("annotated region header: empty text", func(t *testing.T) {
			n := mustparseChunk(t, "@''")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					Span: NodeSpan{0, 3},
				},
				RegionHeaders: []*ast.AnnotatedRegionHeader{
					{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 3}},
						Text: &ast.AnnotatedRegionHeaderText{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 3}},
							Raw:      "@''",
							Value:    "",
						},
					},
				},
			}, n)
		})

		t.Run("annotated region header: one annotation", func(t *testing.T) {
			n := mustparseChunk(t, "@'a' @a")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					Span: NodeSpan{0, 7},
				},
				RegionHeaders: []*ast.AnnotatedRegionHeader{
					{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}},
						Text: &ast.AnnotatedRegionHeaderText{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
							Raw:      "@'a'",
							Value:    "a",
						},
						Annotations: &ast.MetadataAnnotations{
							NodeBase: ast.NodeBase{Span: NodeSpan{5, 7}},
							Expressions: []ast.Node{
								&ast.MetaIdentifier{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 7}},
									Name:     "a",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("annotated region header: one annotation followed by a statement on the same line", func(t *testing.T) {
			n, err := parseChunk(t, "@'a' @a 1", "") //missing delimiter at the end of the header
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					Span: NodeSpan{0, 9},
				},
				RegionHeaders: []*ast.AnnotatedRegionHeader{
					{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 8},
							&sourcecode.ParsingError{UnspecifiedParsingError, MISSING_DELIMITER_AFTER_ANNOTATED_REGION_HEADER},
							false,
						},
						Text: &ast.AnnotatedRegionHeaderText{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
							Raw:      "@'a'",
							Value:    "a",
						},
						Annotations: &ast.MetadataAnnotations{
							NodeBase: ast.NodeBase{Span: NodeSpan{5, 8}},
							Expressions: []ast.Node{
								&ast.MetaIdentifier{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 7}},
									Name:     "a",
								},
							},
						},
					},
				},
				Statements: []ast.Node{
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{8, 9}},
						Raw:      "1",
						Value:    1,
					},
				},
			}, n)
		})

		t.Run("annotated region header: two annotations", func(t *testing.T) {
			n := mustparseChunk(t, "@'a' @a @b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					Span: NodeSpan{0, 10},
				},
				RegionHeaders: []*ast.AnnotatedRegionHeader{
					{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
						Text: &ast.AnnotatedRegionHeaderText{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
							Raw:      "@'a'",
							Value:    "a",
						},
						Annotations: &ast.MetadataAnnotations{
							NodeBase: ast.NodeBase{Span: NodeSpan{5, 10}},
							Expressions: []ast.Node{
								&ast.MetaIdentifier{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 7}},
									Name:     "a",
								},
								&ast.MetaIdentifier{
									NodeBase: ast.NodeBase{Span: NodeSpan{8, 10}},
									Name:     "b",
								},
							},
						},
					},
				},
			}, n)
		})

	})

	t.Run("top level constant declarations", func(t *testing.T) {
		t.Run("empty const declarations", func(t *testing.T) {
			n := mustparseChunk(t, "const ()")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: nil,
				Manifest:   nil,
				GlobalConstantDeclarations: &ast.GlobalConstantDeclarations{
					NodeBase:     ast.NodeBase{Span: NodeSpan{0, 8}},
					Declarations: nil,
				},
			}, n)
		})

		t.Run("empty const declarations in includable file", func(t *testing.T) {
			n := mustparseChunk(t, "includable-file\nconst ()")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: nil,
				Manifest:   nil,
				IncludableChunkDesc: &ast.IncludableChunkDescription{
					NodeBase: ast.NodeBase{Span: NodeSpan{0, 15}},
				},
				GlobalConstantDeclarations: &ast.GlobalConstantDeclarations{
					NodeBase:     ast.NodeBase{Span: NodeSpan{16, 24}},
					Declarations: nil,
				},
			}, n)
		})

		t.Run("single declaration with parenthesis", func(t *testing.T) {
			n := mustparseChunk(t, "const ( a = 1 )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: nil,
				Manifest:   nil,
				GlobalConstantDeclarations: &ast.GlobalConstantDeclarations{
					NodeBase: ast.NodeBase{Span: NodeSpan{0, 15}},
					Declarations: []*ast.GlobalConstantDeclaration{
						{
							NodeBase: ast.NodeBase{
								NodeSpan{8, 13},
								nil,
								false,
							},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Name:     "a",
							},
							Right: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
								Raw:      "1",
								Value:    1,
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis", func(t *testing.T) {
			n := mustparseChunk(t, "const a = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: nil,
				Manifest:   nil,
				GlobalConstantDeclarations: &ast.GlobalConstantDeclarations{
					NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
					Declarations: []*ast.GlobalConstantDeclaration{
						{
							NodeBase: ast.NodeBase{
								NodeSpan{6, 11},
								nil,
								false,
							},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
								Name:     "a",
							},
							Right: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
								Raw:      "1",
								Value:    1,
							},
						},
					},
				},
			}, n)
		})

		t.Run("variable identifiers should not be keywords", func(t *testing.T) {
			n, err := parseChunk(t, "const manifest = 1", "")
			assert.NotNil(t, n)
			assert.ErrorContains(t, err, KEYWORDS_SHOULD_NOT_BE_USED_IN_ASSIGNMENT_LHS)
		})

		t.Run("const keyword followed by EOF", func(t *testing.T) {
			n, err := parseChunk(t, "const", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: nil,
				Manifest:   nil,
				GlobalConstantDeclarations: &ast.GlobalConstantDeclarations{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 5},
						&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_GLOBAL_CONS_DECLS},
						false,
					},
					Declarations: nil,
				},
			}, n)
		})

		t.Run("const keyword followed by space + EOF", func(t *testing.T) {
			n, err := parseChunk(t, "const ", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: nil,
				Manifest:   nil,
				GlobalConstantDeclarations: &ast.GlobalConstantDeclarations{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 6},
						&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_GLOBAL_CONS_DECLS},
						false,
					},
					Declarations: nil,
				},
			}, n)
		})

		t.Run("const keyword followed by a literal", func(t *testing.T) {
			n, err := parseChunk(t, "const 1", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: nil,
				Manifest:   nil,
				GlobalConstantDeclarations: &ast.GlobalConstantDeclarations{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 7},
						nil,
						false,
					},
					Declarations: []*ast.GlobalConstantDeclaration{
						{
							NodeBase: ast.NodeBase{
								NodeSpan{6, 7},
								&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_GLOBAL_CONST_DECL_MISSING_EQL_SIGN},
								false,
							},
							Left: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
								Raw:      "1",
								Value:    1,
							},
						},
					},
				},
			}, n)
		})

		t.Run("const keyword followed by a literal + equal sign", func(t *testing.T) {
			n, err := parseChunk(t, "const 1 =", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase:   ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: nil,
				Manifest:   nil,
				GlobalConstantDeclarations: &ast.GlobalConstantDeclarations{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 9},
						nil,
						false,
					},
					Declarations: []*ast.GlobalConstantDeclaration{
						{
							NodeBase: ast.NodeBase{
								NodeSpan{6, 9},
								&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_GLOBAL_CONST_DECL_LHS_MUST_BE_AN_IDENT},
								false,
							},
							Left: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
								Raw:      "1",
								Value:    1,
							},
							Right: &ast.MissingExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{8, 9},
									&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("const 1 ="), 9, true)},
									false,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("const keyword followed by linefeed + manifest", func(t *testing.T) {
			n, err := parseChunk(t, "const\nmanifest {}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 17},
					nil,
					false,
				},
				Statements: nil,
				GlobalConstantDeclarations: &ast.GlobalConstantDeclarations{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 5},
						&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_GLOBAL_CONS_DECLS},
						false,
					},
					Declarations: nil,
				},
				Manifest: &ast.Manifest{
					NodeBase: ast.NodeBase{
						Span:            NodeSpan{6, 17},
						IsParenthesized: false,
					},
					Object: &ast.ObjectLiteral{
						NodeBase:   ast.NodeBase{Span: NodeSpan{15, 17}},
						Properties: nil,
					},
				},
			}, n)
		})
	})

	t.Run("top level local variables declarations", func(t *testing.T) {

		t.Run("empty declarations", func(t *testing.T) {
			n := mustparseChunk(t, "var ()")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							nil,
							false,
						},
						Declarations: nil,
					},
				},
			}, n)
		})

		t.Run("single declaration", func(t *testing.T) {
			n := mustparseChunk(t, "var ( a = 1 )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							nil,
							false,
						},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{6, 11},
									nil,
									false,
								},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Name:     "a",
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parentheses", func(t *testing.T) {
			n := mustparseChunk(t, "var a = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{4, 9}},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:     "a",
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis and with percent-prefixed type", func(t *testing.T) {
			n := mustparseChunk(t, "var a %int = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{4, 14}},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:     "a",
								},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{6, 10}, nil, false},
									Name:     "int",
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis and with unprefixed named pattern", func(t *testing.T) {
			n := mustparseChunk(t, "var a int = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 13}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{4, 13}},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:     "a",
								},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{6, 9}, nil, false},
									Unprefixed: true,
									Name:       "int",
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis and with unprefixed named pattern with a keyword name", func(t *testing.T) {
			n := mustparseChunk(t, "var a for = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 13}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{4, 13}},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:     "a",
								},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{6, 9}, nil, false},
									Unprefixed: true,
									Name:       "for",
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis and with unprefixed pattern namespace member", func(t *testing.T) {
			n := mustparseChunk(t, "var a x.y = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							nil,
							false,
						},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{4, 13},
									nil,
									false,
								},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:     "a",
								},
								Type: &ast.PatternNamespaceMemberExpression{
									NodeBase: ast.NodeBase{NodeSpan{6, 9}, nil, false},
									Namespace: &ast.PatternNamespaceIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{6, 8}, nil, false},
										Unprefixed: true,
										Name:       "x",
									},
									MemberName: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
										Name:     "y",
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis and with unprefixed pattern call", func(t *testing.T) {
			n := mustparseChunk(t, "var a int() = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 15}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{4, 15}},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:     "a",
								},
								Type: &ast.PatternCallExpression{
									NodeBase: ast.NodeBase{
										Span:            NodeSpan{6, 11},
										IsParenthesized: false,
									},
									Callee: &ast.PatternIdentifierLiteral{
										NodeBase: ast.NodeBase{
											Span: NodeSpan{6, 9},
										},
										Unprefixed: true,
										Name:       "int",
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis with an optional pattern expression as type", func(t *testing.T) {
			n := mustparseChunk(t, "var a int? = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{4, 14}},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:     "a",
								},
								Type: &ast.OptionalPatternExpression{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{6, 10},
									},
									Pattern: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{6, 9}, nil, false},
										Unprefixed: true,
										Name:       "int",
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis and with unprefixed pattern call (namespace member)", func(t *testing.T) {
			n := mustparseChunk(t, "var a a.b() = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 15},
							nil,
							false,
						},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{4, 15},
									nil,
									false,
								},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:     "a",
								},
								Type: &ast.PatternCallExpression{
									NodeBase: ast.NodeBase{
										Span:            NodeSpan{6, 11},
										IsParenthesized: false,
									},
									Callee: &ast.PatternNamespaceMemberExpression{
										NodeBase: ast.NodeBase{NodeSpan{6, 9}, nil, false},
										Namespace: &ast.PatternNamespaceIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{6, 8}, nil, false},
											Unprefixed: true,
											Name:       "a",
										},
										MemberName: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
											Name:     "b",
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis and with unprefixed pattern call (object pattern argument shorthand)", func(t *testing.T) {
			n := mustparseChunk(t, "var a int{} = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 15},
							nil,
							false,
						},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{4, 15},
									nil,
									false,
								},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:     "a",
								},
								Type: &ast.PatternCallExpression{
									NodeBase: ast.NodeBase{Span: NodeSpan{6, 11}},
									Callee: &ast.PatternIdentifierLiteral{
										NodeBase: ast.NodeBase{
											Span: NodeSpan{6, 9},
										},
										Unprefixed: true,
										Name:       "int",
									},
									Arguments: []ast.Node{
										&ast.ObjectPatternLiteral{
											NodeBase: ast.NodeBase{
												Span:            NodeSpan{9, 11},
												IsParenthesized: false,
											},
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)

			t.Run("single declaration without parenthesis and with unprefixed pattern call (namespace member, object pattern argument shorthand))", func(t *testing.T) {
				n := mustparseChunk(t, "var a a.b{} = 1")
				assert.EqualValues(t, &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
					Statements: []ast.Node{
						&ast.LocalVariableDeclarations{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 15},
								nil,
								false,
							},
							Declarations: []*ast.LocalVariableDeclarator{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{4, 15},
										nil,
										false,
									},
									Left: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
										Name:     "a",
									},
									Type: &ast.PatternCallExpression{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 11}},
										Callee: &ast.PatternNamespaceMemberExpression{
											NodeBase: ast.NodeBase{NodeSpan{6, 9}, nil, false},
											Namespace: &ast.PatternNamespaceIdentifierLiteral{
												NodeBase:   ast.NodeBase{NodeSpan{6, 8}, nil, false},
												Unprefixed: true,
												Name:       "a",
											},
											MemberName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
												Name:     "b",
											},
										},
										Arguments: []ast.Node{
											&ast.ObjectPatternLiteral{
												NodeBase: ast.NodeBase{
													Span:            NodeSpan{9, 11},
													IsParenthesized: false,
												},
											},
										},
									},
									Right: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				}, n)
			})
		})

		t.Run("single object destructuration: no properties", func(t *testing.T) {
			n := mustparseChunk(t, "var ( {} = 1 )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 12}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single object destructuration without parentheses: no properties", func(t *testing.T) {
			n := mustparseChunk(t, "var {} = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{4, 10}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single object destructuration: one property", func(t *testing.T) {
			n := mustparseChunk(t, "var ( {a} = 1 )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 15}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 13}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{6, 9}, nil, false},
									Properties: []ast.Node{
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
												Name:     "a",
											},
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single object destructuration: one property (nillable)", func(t *testing.T) {
			n := mustparseChunk(t, "var ( {a?} = 1 )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 16}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 14}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{6, 10}, nil, false},
									Properties: []ast.Node{
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
												Name:     "a",
											},
											Nillable: true,
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single object destructuration: one property: space between name and question mark", func(t *testing.T) {
			n, err := parseChunk(t, "var ( {a ?} = 1 )", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 17}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 15}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{6, 11}, nil, false},
									Properties: []ast.Node{
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{
												NodeSpan{7, 10},
												&sourcecode.ParsingError{UnspecifiedParsingError, UNEXPECTED_SPACE_BETWEEN_PROPERTY_NAME_AND_QUESTION_MARK},
												false,
											},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
												Name:     "a",
											},
											Nillable: false,
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single object destructuration: one property followed by an unexpected character", func(t *testing.T) {
			n, err := parseChunk(t, "var ( {a]} = 1 )", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 16}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 14}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{6, 10}, nil, false},
									Properties: []ast.Node{
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
												Name:     "a",
											},
										},
										&ast.UnknownNode{
											NodeBase: ast.NodeBase{
												NodeSpan{8, 9},
												&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInObjectDestructuration(']')},
												false,
											},
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single object destructuration: one property with a new name", func(t *testing.T) {
			n := mustparseChunk(t, "var ( {a as b} = 1 )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 18}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{6, 14}, nil, false},
									Properties: []ast.Node{
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{NodeSpan{7, 13}, nil, false},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
												Name:     "a",
											},
											NewName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
												Name:     "b",
											},
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single object destructuration: one property with missing new name: followed by '}'", func(t *testing.T) {
			n, err := parseChunk(t, "var ( {a as } = 1 )", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 19}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 17}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{6, 13}, nil, false},
									Properties: []ast.Node{
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{
												NodeSpan{7, 12},
												&sourcecode.ParsingError{UnspecifiedParsingError, MISSING_NEW_NAME_AFTER_AS_KEYWORD},
												false,
											},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
												Name:     "a",
											},
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single object destructuration: one property with missing new name: followed by an unexpected character", func(t *testing.T) {
			n, err := parseChunk(t, "var ( {a as ]} = 1 )", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 18}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{6, 14}, nil, false},
									Properties: []ast.Node{
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{
												NodeSpan{7, 12},
												&sourcecode.ParsingError{UnspecifiedParsingError, MISSING_NEW_NAME_AFTER_AS_KEYWORD},
												false,
											},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
												Name:     "a",
											},
										},
										&ast.UnknownNode{
											NodeBase: ast.NodeBase{
												NodeSpan{12, 13},
												&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInObjectDestructuration(']')},
												false,
											},
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single object destructuration: two properties separated by a comma", func(t *testing.T) {
			n := mustparseChunk(t, "var ( {a,b} = 1 )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 17}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 15}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{6, 11}, nil, false},
									Properties: []ast.Node{
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
												Name:     "a",
											},
										},
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
												Name:     "b",
											},
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single object destructuration: two properties separated by a comma first one is nillable", func(t *testing.T) {
			n := mustparseChunk(t, "var ( {a?,b} = 1 )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 18}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 16}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{6, 12}, nil, false},
									Properties: []ast.Node{
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
												Name:     "a",
											},
											Nillable: true,
										},
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
												Name:     "b",
											},
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single object destructuration: two properties separated by a comma: first one has a new name", func(t *testing.T) {
			n := mustparseChunk(t, "var ( {a as b,c} = 1 )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 22}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 20}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{6, 16}, nil, false},
									Properties: []ast.Node{
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{NodeSpan{7, 13}, nil, false},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
												Name:     "a",
											},
											NewName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
												Name:     "b",
											},
										},
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
												Name:     "c",
											},
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single object destructuration: two properties separated by a comma: first one is missing its new name", func(t *testing.T) {
			n, err := parseChunk(t, "var ( {a as,b} = 1 )", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 18}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{6, 14}, nil, false},
									Properties: []ast.Node{
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{
												NodeSpan{7, 11},
												&sourcecode.ParsingError{UnspecifiedParsingError, MISSING_NEW_NAME_AFTER_AS_KEYWORD},
												false,
											},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
												Name:     "a",
											},
										},
										&ast.ObjectDestructurationProperty{
											NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
											PropertyName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
												Name:     "b",
											},
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("two object destructurations: no properties", func(t *testing.T) {
			n := mustparseChunk(t, "var ( {} = 1, {} = 2 )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 22}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 12}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{14, 20}},
								Left: &ast.ObjectDestructuration{

									NodeBase: ast.NodeBase{NodeSpan{14, 16}, nil, false},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("var keyword at end of file", func(t *testing.T) {
			n, err := parseChunk(t, "var", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_LOCAL_VAR_DECLS},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("var keyword followed by line feed", func(t *testing.T) {
			n, err := parseChunk(t, "var\n", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 4},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_LOCAL_VAR_DECLS},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("var keyword followed by line feed + expression", func(t *testing.T) {
			n, err := parseChunk(t, "var\n1", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 5}},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_LOCAL_VAR_DECLS},
							false,
						},
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
						Raw:      "1",
						Value:    1,
					},
				},
			}, n)
		})

		t.Run("single declaration with invalid LHS", func(t *testing.T) {
			n, err := parseChunk(t, "var 1", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 5}},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 5},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_LOCAL_VAR_DECLS_OPENING_PAREN_EXPECTED},
							false,
						},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{4, 5},
									Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_LOCAL_VAR_DECL_LHS_MUST_BE_AN_IDENT},
								},
								Left: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration with invalid LHS followed by a space", func(t *testing.T) {
			n, err := parseChunk(t, "var 1 ", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 6},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_LOCAL_VAR_DECLS_OPENING_PAREN_EXPECTED},
							false,
						},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{4, 6},
									Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_LOCAL_VAR_DECL_LHS_MUST_BE_AN_IDENT},
								},
								Left: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration with invalid LHS followed by a linefeed and an expression", func(t *testing.T) {
			n, err := parseChunk(t, "var 1\n1", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 7},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_LOCAL_VAR_DECLS_OPENING_PAREN_EXPECTED},
							false,
						},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{4, 6},
									Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_LOCAL_VAR_DECL_LHS_MUST_BE_AN_IDENT},
								},
								Left: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
						Raw:      "1",
						Value:    1,
					},
				},
			}, n)
		})

		t.Run("single declaration with keyword LHS", func(t *testing.T) {
			mod, err := parseChunk(t, "var manifest", "")
			assert.NotNil(t, mod)
			assert.Error(t, err)
		})

		t.Run("single parenthesized declaration with invalid LHS and valid RHS", func(t *testing.T) {
			n, err := parseChunk(t, "var (1 = 2)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{5, 10},
									Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_LOCAL_VAR_DECL_LHS_MUST_BE_AN_IDENT},
								},
								Left: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 6}},
									Raw:      "1",
									Value:    1,
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{9, 10}},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single non-parenthesized declaration with invalid LHS and valid RHS", func(t *testing.T) {
			n, err := parseChunk(t, "var 1 = 2", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
				Statements: []ast.Node{
					&ast.LocalVariableDeclarations{
						NodeBase: ast.NodeBase{
							Span: NodeSpan{0, 9},
							Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_LOCAL_VAR_DECLS_OPENING_PAREN_EXPECTED},
						},
						Declarations: []*ast.LocalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{4, 9},
									Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_LOCAL_VAR_DECL_LHS_MUST_BE_AN_IDENT},
								},
								Left: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{4, 5}},
									Raw:      "1",
									Value:    1,
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{8, 9}},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration with keyword LHS", func(t *testing.T) {
			mod, err := parseChunk(t, "var manifest = 1", "")
			assert.NotNil(t, mod)
			assert.ErrorContains(t, err, KEYWORDS_SHOULD_NOT_BE_USED_IN_ASSIGNMENT_LHS)
		})

		t.Run("single declaration with unexpected char as LHS", func(t *testing.T) {
			mod, err := parseChunk(t, "var ? = 1", "")
			assert.NotNil(t, mod)
			assert.Error(t, err)
		})

		t.Run("miscellaneous", func(t *testing.T) {
			_, err := parseChunk(t, "var a #{} = 1", "")
			assert.NoError(t, err)
		})
	})

	t.Run("top level global variables declarations", func(t *testing.T) {

		t.Run("empty declarations", func(t *testing.T) {
			n := mustparseChunk(t, "globalvar ()")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							nil,
							false,
						},
						Declarations: nil,
					},
				},
			}, n)
		})

		t.Run("single declaration", func(t *testing.T) {
			n := mustparseChunk(t, "globalvar ( a = 1 )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 19},
							nil,
							false,
						},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{12, 17},
									nil,
									false,
								},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
									Name:     "a",
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis", func(t *testing.T) {
			n := mustparseChunk(t, "globalvar a = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 15},
							nil,
							false,
						},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 15},
									nil,
									false,
								},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "a",
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis and with percent-prefixed type", func(t *testing.T) {
			n := mustparseChunk(t, "globalvar a %int = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 20},
							nil,
							false,
						},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 20},
									nil,
									false,
								},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "a",
								},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 16}, nil, false},
									Name:     "int",
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis and with unprefixed named pattern", func(t *testing.T) {
			n := mustparseChunk(t, "globalvar a int = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 19},
							nil,
							false,
						},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 19},
									nil,
									false,
								},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "a",
								},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Unprefixed: true,
									Name:       "int",
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{18, 19}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis and with unprefixed pattern namespace member", func(t *testing.T) {
			n := mustparseChunk(t, "globalvar a x.y = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 19},
							nil,
							false,
						},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 19},
									nil,
									false,
								},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "a",
								},
								Type: &ast.PatternNamespaceMemberExpression{
									NodeBase: ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Namespace: &ast.PatternNamespaceIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{12, 14}, nil, false},
										Unprefixed: true,
										Name:       "x",
									},
									MemberName: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
										Name:     "y",
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{18, 19}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis and with unprefixed pattern call", func(t *testing.T) {
			n := mustparseChunk(t, "globalvar a int() = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 21},
							nil,
							false,
						},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 21},
									nil,
									false,
								},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "a",
								},
								Type: &ast.PatternCallExpression{
									NodeBase: ast.NodeBase{
										Span:            NodeSpan{12, 17},
										IsParenthesized: false,
									},
									Callee: &ast.PatternIdentifierLiteral{
										NodeBase: ast.NodeBase{
											Span: NodeSpan{12, 15},
										},
										Unprefixed: true,
										Name:       "int",
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis with an optional pattern expression as type", func(t *testing.T) {
			n := mustparseChunk(t, "globalvar a int? = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 20},
							nil,
							false,
						},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 20},
									nil,
									false,
								},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "a",
								},
								Type: &ast.OptionalPatternExpression{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{12, 16},
									},
									Pattern: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{12, 15}, nil, false},
										Unprefixed: true,
										Name:       "int",
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis and with unprefixed pattern call (namespace member)", func(t *testing.T) {
			n := mustparseChunk(t, "globalvar a a.b() = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 21},
							nil,
							false,
						},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 21},
									nil,
									false,
								},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "a",
								},
								Type: &ast.PatternCallExpression{
									NodeBase: ast.NodeBase{
										Span:            NodeSpan{12, 17},
										IsParenthesized: false,
									},
									Callee: &ast.PatternNamespaceMemberExpression{
										NodeBase: ast.NodeBase{NodeSpan{12, 15}, nil, false},
										Namespace: &ast.PatternNamespaceIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{12, 14}, nil, false},
											Unprefixed: true,
											Name:       "a",
										},
										MemberName: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
											Name:     "b",
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration without parenthesis and with unprefixed pattern call (object pattern argument shorthand)", func(t *testing.T) {
			n := mustparseChunk(t, "globalvar a int{} = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 21},
							nil,
							false,
						},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 21},
									nil,
									false,
								},
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "a",
								},
								Type: &ast.PatternCallExpression{
									NodeBase: ast.NodeBase{Span: NodeSpan{12, 17}},
									Callee: &ast.PatternIdentifierLiteral{
										NodeBase: ast.NodeBase{
											Span: NodeSpan{12, 15},
										},
										Unprefixed: true,
										Name:       "int",
									},
									Arguments: []ast.Node{
										&ast.ObjectPatternLiteral{
											NodeBase: ast.NodeBase{
												Span:            NodeSpan{15, 17},
												IsParenthesized: false,
											},
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)

			t.Run("single declaration without parenthesis and with unprefixed pattern call (namespace member, object pattern argument shorthand))", func(t *testing.T) {
				n := mustparseChunk(t, "globalvar a a.b{} = 1")
				assert.EqualValues(t, &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
					Statements: []ast.Node{
						&ast.GlobalVariableDeclarations{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 21},
								nil,
								false,
							},
							Declarations: []*ast.GlobalVariableDeclarator{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{10, 21},
										nil,
										false,
									},
									Left: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
										Name:     "a",
									},
									Type: &ast.PatternCallExpression{
										NodeBase: ast.NodeBase{Span: NodeSpan{12, 17}},
										Callee: &ast.PatternNamespaceMemberExpression{
											NodeBase: ast.NodeBase{NodeSpan{12, 15}, nil, false},
											Namespace: &ast.PatternNamespaceIdentifierLiteral{
												NodeBase:   ast.NodeBase{NodeSpan{12, 14}, nil, false},
												Unprefixed: true,
												Name:       "a",
											},
											MemberName: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
												Name:     "b",
											},
										},
										Arguments: []ast.Node{
											&ast.ObjectPatternLiteral{
												NodeBase: ast.NodeBase{
													Span:            NodeSpan{15, 17},
													IsParenthesized: false,
												},
											},
										},
									},
									Right: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				}, n)
			})
		})

		t.Run("single object destructuration: no properties", func(t *testing.T) {
			n := mustparseChunk(t, "globalvar ( {} = 1 )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 18}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{12, 14}, nil, false},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("two object destructurations: no properties", func(t *testing.T) {
			n := mustparseChunk(t, "globalvar ( {} = 1, {} = 2 )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 28}},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 18}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{12, 14}, nil, false},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{20, 26}},
								Left: &ast.ObjectDestructuration{

									NodeBase: ast.NodeBase{NodeSpan{20, 22}, nil, false},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{25, 26}, nil, false},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single object destructuration without parentheses: no properties", func(t *testing.T) {
			n := mustparseChunk(t, "globalvar {} = 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 16}},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 16}},
								Left: &ast.ObjectDestructuration{
									NodeBase: ast.NodeBase{NodeSpan{10, 12}, nil, false},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("globalvar keyword at end of file", func(t *testing.T) {
			n, err := parseChunk(t, "globalvar", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_GLOBAL_VAR_DECLS},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("globalvar keyword followed by line feed", func(t *testing.T) {
			n, err := parseChunk(t, "globalvar\n", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 10},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_GLOBAL_VAR_DECLS},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("globalvar keyword followed by line feed + expression", func(t *testing.T) {
			n, err := parseChunk(t, "globalvar\n1", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 11},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_GLOBAL_VAR_DECLS},
							false,
						},
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
						Raw:      "1",
						Value:    1,
					},
				},
			}, n)
		})

		t.Run("single declaration with invalid LHS", func(t *testing.T) {
			n, err := parseChunk(t, "globalvar 1", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_GLOBAL_VAR_DECLS_OPENING_PAREN_EXPECTED},
							false,
						},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{10, 11},
									Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_GLOBAL_VAR_DECL_LHS_MUST_BE_AN_IDENT},
								},
								Left: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration with invalid LHS followed by a space", func(t *testing.T) {
			n, err := parseChunk(t, "globalvar 1 ", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_GLOBAL_VAR_DECLS_OPENING_PAREN_EXPECTED},
							false,
						},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{10, 12},
									Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_GLOBAL_VAR_DECL_LHS_MUST_BE_AN_IDENT},
								},
								Left: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration with invalid LHS followed by a space", func(t *testing.T) {
			n, err := parseChunk(t, "globalvar 1\n1", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 13}},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_GLOBAL_VAR_DECLS_OPENING_PAREN_EXPECTED},
							false,
						},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{10, 12},
									Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_GLOBAL_VAR_DECL_LHS_MUST_BE_AN_IDENT},
								},
								Left: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
						Raw:      "1",
						Value:    1,
					},
				},
			}, n)
		})

		t.Run("single declaration with keyword LHS", func(t *testing.T) {
			mod, err := parseChunk(t, "globalvar manifest", "")
			assert.NotNil(t, mod)
			assert.Error(t, err)
		})

		t.Run("single parenthesized declaration with invalid LHS and valid RHS", func(t *testing.T) {
			n, err := parseChunk(t, "globalvar (1 = 2)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 17}},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 17}},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{11, 16},
									Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_GLOBAL_VAR_DECL_LHS_MUST_BE_AN_IDENT},
								},
								Left: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{Start: 11, End: 12}},
									Raw:      "1",
									Value:    1,
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{15, 16}},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single non-parenthesized declaration with invalid LHS and valid RHS", func(t *testing.T) {
			n, err := parseChunk(t, "globalvar 1 = 2", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 15}},
				Statements: []ast.Node{
					&ast.GlobalVariableDeclarations{
						NodeBase: ast.NodeBase{
							Span: NodeSpan{0, 15},
							Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_GLOBAL_VAR_DECLS_OPENING_PAREN_EXPECTED},
						},
						Declarations: []*ast.GlobalVariableDeclarator{
							{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{10, 15},
									Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_GLOBAL_VAR_DECL_LHS_MUST_BE_AN_IDENT},
								},
								Left: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{10, 11}},
									Raw:      "1",
									Value:    1,
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{14, 15}},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single declaration with keyword LHS", func(t *testing.T) {
			mod, err := parseChunk(t, "globalvar manifest = 1", "")
			assert.NotNil(t, mod)
			assert.ErrorContains(t, err, KEYWORDS_SHOULD_NOT_BE_USED_IN_ASSIGNMENT_LHS)
		})

		t.Run("single declaration with unexpected char as LHS", func(t *testing.T) {
			mod, err := parseChunk(t, "globalvar ? = 1", "")
			assert.NotNil(t, mod)
			assert.Error(t, err)
		})

		t.Run("miscellaneous", func(t *testing.T) {
			_, err := parseChunk(t, "globalvar a #{} = 1", "")
			assert.NoError(t, err)
		})
	})

	t.Run("variable", func(t *testing.T) {
		n := mustparseChunk(t, "$a")
		assert.EqualValues(t, &ast.Chunk{
			NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
			Statements: []ast.Node{
				&ast.Variable{
					NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
					Name:     "a",
				},
			},
		}, n)
	})

	t.Run("identifier", func(t *testing.T) {

		t.Run("single letter", func(t *testing.T) {
			n := mustparseChunk(t, "a")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
				Statements: []ast.Node{
					&ast.IdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
						Name:     "a",
					},
				},
			}, n)
		})

		t.Run("ending with a hyphen", func(t *testing.T) {
			n, err := parseChunk(t, "a-", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.IdentifierLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 2},
							&sourcecode.ParsingError{UnspecifiedParsingError, IDENTIFIER_LITERAL_MUST_NO_END_WITH_A_HYPHEN},
							false,
						},
						Name: "a-",
					},
				},
			}, n)
		})

		t.Run("followed by line feed", func(t *testing.T) {
			n := mustparseChunk(t, "a\n")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 2},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.IdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
						Name:     "a",
					},
				},
			}, n)
		})
	})

	t.Run("meta identifier", func(t *testing.T) {

		t.Run("single letter", func(t *testing.T) {
			n := mustparseChunk(t, "(@a)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.MetaIdentifier{
						NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, true},
						Name:     "a",
					},
				},
			}, n)
		})

		t.Run("ending with a hyphen", func(t *testing.T) {
			n, err := parseChunk(t, "(@a-)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.MetaIdentifier{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 4},
							&sourcecode.ParsingError{UnspecifiedParsingError, META_IDENTIFIER_MUST_NO_END_WITH_A_HYPHEN},
							true,
						},
						Name: "a-",
					},
				},
			}, n)
		})

		t.Run("followed by line feed", func(t *testing.T) {
			n := mustparseChunk(t, "(@a\n)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 5}},
				Statements: []ast.Node{
					&ast.MetaIdentifier{
						NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, true},
						Name:     "a",
					},
				},
			}, n)
		})
	})

	t.Run("boolean literals", func(t *testing.T) {
		t.Run("true", func(t *testing.T) {
			n := mustparseChunk(t, "true")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.BooleanLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Value:    true,
					},
				},
			}, n)
		})

		t.Run("false", func(t *testing.T) {
			n := mustparseChunk(t, "false")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.BooleanLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Value:    false,
					},
				},
			}, n)
		})

	})

	t.Run("property name", func(t *testing.T) {
		n := mustparseChunk(t, ".a")
		assert.EqualValues(t, &ast.Chunk{
			NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
			Statements: []ast.Node{
				&ast.PropertyNameLiteral{
					NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
					Name:     "a",
				},
			},
		}, n)
	})

	t.Run("long value path literal", func(t *testing.T) {
		t.Run("2 property names", func(t *testing.T) {
			n := mustparseChunk(t, ".a.b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.LongValuePathLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Segments: []ast.SimpleValueLiteral{
							&ast.PropertyNameLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
								Name:     "a",
							},
							&ast.PropertyNameLiteral{
								NodeBase: ast.NodeBase{NodeSpan{2, 4}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("3 property names", func(t *testing.T) {
			n := mustparseChunk(t, ".a.b.c")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.LongValuePathLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Segments: []ast.SimpleValueLiteral{
							&ast.PropertyNameLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
								Name:     "a",
							},
							&ast.PropertyNameLiteral{
								NodeBase: ast.NodeBase{NodeSpan{2, 4}, nil, false},
								Name:     "b",
							},
							&ast.PropertyNameLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
								Name:     "c",
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated", func(t *testing.T) {
			n, err := parseChunk(t, ".a.", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.LongValuePathLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
						Segments: []ast.SimpleValueLiteral{
							&ast.PropertyNameLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
								Name:     "a",
							},
							&ast.PropertyNameLiteral{
								NodeBase: ast.NodeBase{
									NodeSpan{2, 3},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_VALUE_PATH_LITERAL},
									false,
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("flag literal", func(t *testing.T) {
		t.Run("single hyphen followed by a single letter", func(t *testing.T) {
			n := mustparseChunk(t, "-a")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.FlagLiteral{
						NodeBase:   ast.NodeBase{NodeSpan{0, 2}, nil, false},
						Name:       "a",
						SingleDash: true,
						Raw:        "-a",
					},
				},
			}, n)
		})

		t.Run("single hyphen followed by several letters", func(t *testing.T) {
			n := mustparseChunk(t, "-ab")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.FlagLiteral{
						NodeBase:   ast.NodeBase{NodeSpan{0, 3}, nil, false},
						Name:       "ab",
						SingleDash: true,
						Raw:        "-ab",
					},
				},
			}, n)
		})

		t.Run("single hyphen followed by an unexpected character", func(t *testing.T) {
			n, err := parseChunk(t, "-?", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.FlagLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 1},
							&sourcecode.ParsingError{UnspecifiedParsingError, OPTION_NAME_CAN_ONLY_CONTAIN_ALPHANUM_CHARS},
							false,
						},
						Name:       "",
						SingleDash: true,
						Raw:        "-",
					},
					&ast.UnknownNode{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 2},
							&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInBlockOrModule('?')},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("flag literal : double dash", func(t *testing.T) {
			n := mustparseChunk(t, "--abc")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.FlagLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Name:     "abc",
						Raw:      "--abc",
					},
				},
			}, n)
		})
	})

	t.Run("option expression", func(t *testing.T) {

		t.Run("ok", func(t *testing.T) {
			n := mustparseChunk(t, `--name="foo"`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.OptionExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							nil,
							false,
						},
						Name: "name",
						Value: &ast.DoubleQuotedStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 12}, nil, false},
							Raw:      `"foo"`,
							Value:    "foo",
						},
						SingleDash: false,
					},
				},
			}, n)
		})

		t.Run("unterminated", func(t *testing.T) {
			n, err := parseChunk(t, `--name=`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.OptionExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							&sourcecode.ParsingError{UnterminatedOptionExpr, UNTERMINATED_OPTION_EXPR_EQUAL_ASSIGN_SHOULD_BE_FOLLOWED_BY_EXPR},
							false,
						},
						Name:       "name",
						SingleDash: false,
					},
				},
			}, n)
		})

		t.Run("unparenthesized binary expression are not supported", func(t *testing.T) {
			n := mustparseChunk(t, `--name=1 + 2`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.OptionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
						Name:     "name",
						Value: &ast.IntLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{7, 8}},
							Raw:      "1",
							Value:    1,
						},
						SingleDash: false,
					},
					&ast.UnquotedStringLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{9, 10}},
						Raw:      "+",
						Value:    "+",
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{11, 12}},
						Raw:      "2",
						Value:    2,
					},
				},
			}, n)
		})
	})

	t.Run("option patterns", func(t *testing.T) {
		t.Run("missing '='", func(t *testing.T) {
			n, err := parseChunk(t, `%--name`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.OptionPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OPTION_PATTERN_A_VALUE_IS_EXPECTED_AFTER_EQUAKL_SIGN},
							false,
						},
						Name:       "name",
						SingleDash: false,
					},
				},
			}, n)
		})

		t.Run("missing value after '='", func(t *testing.T) {
			n, err := parseChunk(t, `%--name=`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.OptionPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 8},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OPTION_PATT_EQUAL_ASSIGN_SHOULD_BE_FOLLOWED_BY_EXPR},
							false,
						},
						Name:       "name",
						SingleDash: false,
					},
				},
			}, n)
		})

		t.Run("valid option pattern", func(t *testing.T) {
			n := mustparseChunk(t, `%--name=%foo`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.OptionPatternLiteral{
						NodeBase:   ast.NodeBase{NodeSpan{0, 12}, nil, false},
						Name:       "name",
						SingleDash: false,
						Value: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{8, 12}, nil, false},
							Name:     "foo",
						},
					},
				},
			}, n)
		})

		t.Run("unprefixed", func(t *testing.T) {
			n := mustparseChunk(t, `pattern p = --name=int`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 22},
							IsParenthesized: false,
							/*[]ast.Token{
								{Type: ast.PATTERN_KEYWORD, Span: NodeSpan{0, 7}},
								{Type: ast.EQUAL, Span: NodeSpan{10, 11}},
							},*/
						},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{8, 9}},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.OptionPatternLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{12, 22}, nil, false},
							Name:       "name",
							SingleDash: false,
							Unprefixed: true,
							Value: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{19, 22}, nil, false},
								Name:       "int",
								Unprefixed: true,
							},
						},
					},
				},
			}, n)
		})
	})
	t.Run("path literal", func(t *testing.T) {

		t.Run("unquoted absolute path literal : /", func(t *testing.T) {
			n := mustparseChunk(t, "/")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
						Raw:      "/",
						Value:    "/",
					},
				},
			}, n)
		})

		t.Run("quoted absolute path literal : /`[]`", func(t *testing.T) {
			n := mustparseChunk(t, "/`[]`")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Raw:      "/`[]`",
						Value:    "/[]",
					},
				},
			}, n)
		})

		t.Run("unquoted absolute path literal : /a", func(t *testing.T) {
			n := mustparseChunk(t, "/a")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
						Raw:      "/a",
						Value:    "/a",
					},
				},
			}, n)
		})

		t.Run("relative path literal : ./", func(t *testing.T) {
			n := mustparseChunk(t, "./")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.RelativePathLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
						Raw:      "./",
						Value:    "./",
					},
				},
			}, n)
		})

		t.Run("relative path literal : ./a", func(t *testing.T) {
			n := mustparseChunk(t, "./a")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.RelativePathLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
						Raw:      "./a",
						Value:    "./a",
					},
				},
			}, n)
		})

		t.Run("relative path literal in list : [./]", func(t *testing.T) {
			n := mustparseChunk(t, "[./]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.ListLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.OPENING_BRACKET, Span: NodeSpan{0, 1}},
								{Type: ast.CLOSING_BRACKET, Span: NodeSpan{3, 4}},
							},*/
						},
						Elements: []ast.Node{
							&ast.RelativePathLiteral{
								NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
								Raw:      "./",
								Value:    "./",
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated quoted path literal: missing closing backtick + followed by EOF", func(t *testing.T) {
			n, err := parseChunk(t, "/`[]", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_QUOTED_PATH_LIT_MISSING_CLOSING_BACTICK},
							false,
						},
						Raw:   "/`[]",
						Value: "/[]",
					},
				},
			}, n)
		})

		t.Run("unterminated quoted path literal: missing closing backtick + followed by linefeed", func(t *testing.T) {
			n, err := parseChunk(t, "/`[]\na", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_QUOTED_PATH_LIT_MISSING_CLOSING_BACTICK},
							false,
						},
						Raw:   "/`[]",
						Value: "/[]",
					},
					&ast.IdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
						Name:     "a",
					},
				},
			}, n)
		})

		t.Run("non-trailing colon", func(t *testing.T) {
			n := mustparseChunk(t, "/a:b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Raw:      "/a:b",
						Value:    "/a:b",
					},
				},
			}, n)
		})

	})

	t.Run("path pattern", func(t *testing.T) {
		t.Run("absolute path pattern literal : /a*", func(t *testing.T) {
			n := mustparseChunk(t, "%/a*")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathPatternLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Raw:      "%/a*",
						Value:    "/a*",
					},
				},
			}, n)
		})

		t.Run("absolute path pattern literal : /a[a-z]", func(t *testing.T) {
			n := mustparseChunk(t, "%/`a[a-z]`")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathPatternLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
						Raw:      "%/`a[a-z]`",
						Value:    "/a[a-z]",
					},
				},
			}, n)
		})

		t.Run("absolute path pattern literal ending with /... ", func(t *testing.T) {
			n := mustparseChunk(t, "%/a/...")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathPatternLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Raw:      "%/a/...",
						Value:    "/a/...",
					},
				},
			}, n)
		})

		t.Run("absolute path pattern literal : /... ", func(t *testing.T) {
			n := mustparseChunk(t, "%/...")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathPatternLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Raw:      "%/...",
						Value:    "/...",
					},
				},
			}, n)
		})

		t.Run("absolute path pattern literal with /... in the middle ", func(t *testing.T) {
			n, err := parseChunk(t, "%/a/.../b", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							&sourcecode.ParsingError{UnspecifiedParsingError, fmtSlashDotDotDotCanOnlyBePresentAtEndOfPathPattern("/a/.../b")},
							false,
						},
						Raw:   "%/a/.../b",
						Value: "/a/.../b",
					},
				},
			}, n)
		})

		t.Run("absolute path pattern literal with /... in the middle and at the end", func(t *testing.T) {
			n, err := parseChunk(t, "%/a/.../...", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							&sourcecode.ParsingError{UnspecifiedParsingError, fmtSlashDotDotDotCanOnlyBePresentAtEndOfPathPattern("/a/.../...")},
							false,
						},
						Raw:   "%/a/.../...",
						Value: "/a/.../...",
					},
				},
			}, n)
		})

		t.Run("unterminated quoted path pattern literal: missing closing backtick + followed by EOF", func(t *testing.T) {
			n, err := parseChunk(t, "%/`[a-z]", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 8},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_QUOTED_PATH_PATTERN_LIT_MISSING_CLOSING_BACTICK},
							false,
						},
						Raw:   "%/`[a-z]",
						Value: "/[a-z]",
					},
				},
			}, n)
		})

		t.Run("unterminated quoted path pattern literal: missing closing backtick + followed by line feed", func(t *testing.T) {
			n, err := parseChunk(t, "%/`[a-z]\na", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 8},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_QUOTED_PATH_PATTERN_LIT_MISSING_CLOSING_BACTICK},
							false,
						},
						Raw:   "%/`[a-z]",
						Value: "/[a-z]",
					},
					&ast.IdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
						Name:     "a",
					},
				},
			}, n)
		})

		t.Run("non-trailing colon", func(t *testing.T) {
			n := mustparseChunk(t, "%/a:b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathPatternLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Raw:      "%/a:b",
						Value:    "/a:b",
					},
				},
			}, n)
		})
	})

	t.Run("named-segment path pattern literal  ", func(t *testing.T) {
		t.Run("ok", func(t *testing.T) {
			n := mustparseChunk(t, "%/home/{:username}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.NamedSegmentPathPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 18},
							nil,
							false,
							/* []ast.Token{
								{Type: ast.PERCENT_SYMBOL, Span: NodeSpan{0, 1}},
								{Type: ast.SINGLE_INTERP_OPENING_BRACE, Span: NodeSpan{7, 8}},
								{Type: ast.SINGLE_INTERP_CLOSING_BRACE, Span: NodeSpan{17, 18}},
							}, */
						},
						Slices: []ast.Node{
							&ast.PathPatternSlice{
								NodeBase: ast.NodeBase{NodeSpan{1, 7}, nil, false},
								Value:    "/home/",
							},
							&ast.NamedPathSegment{
								NodeBase: ast.NodeBase{NodeSpan{8, 17}, nil, false},
								Name:     "username",
							},
						},
						Raw:         "%/home/{:username}",
						StringValue: "%/home/{:username}",
					},
				},
			}, n)
		})

		t.Run("quoting is not suppported yet", func(t *testing.T) {
			n, err := parseChunk(t, "%/`home/{:username}`", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.NamedSegmentPathPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 20},
							&sourcecode.ParsingError{UnspecifiedParsingError, QUOTED_NAMED_SEGMENT_PATH_PATTERNS_ARE_NOT_SUPPORTED_YET},
							false,
						},
						Slices: []ast.Node{
							&ast.PathPatternSlice{
								NodeBase: ast.NodeBase{NodeSpan{1, 8}, nil, false},
								Value:    "/`home/",
							},
							&ast.NamedPathSegment{
								NodeBase: ast.NodeBase{NodeSpan{9, 18}, nil, false},
								Name:     "username",
							},
							&ast.PathPatternSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "`",
							},
						},
						Raw:         "",
						StringValue: "",
					},
				},
			}, n)
		})

		t.Run("unprefixed: absolute", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = /*")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Unprefixed: true,
							Name:       "p",
						},
						Right: &ast.AbsolutePathPatternLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{12, 14}, nil, false},
							Raw:        "/*",
							Value:      "/*",
							Unprefixed: true,
						},
					},
				},
			}, n)
		})

		t.Run("unprefixed: relative", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = ./*")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Unprefixed: true,
							Name:       "p",
						},
						Right: &ast.RelativePathPatternLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{12, 15}, nil, false},
							Raw:        "./*",
							Value:      "./*",
							Unprefixed: true,
						},
					},
				},
			}, n)
		})

		//TODO: improve following tests

		t.Run("invalid named-segment path pattern literals", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, "%/home/e{:}")
			})
			assert.Panics(t, func() {
				mustparseChunk(t, "%/home/e{:u:}")
			})
			assert.Panics(t, func() {
				mustparseChunk(t, "%/home/e{:username-}")
			})
			assert.Panics(t, func() {
				mustparseChunk(t, "%/home/e{:-username}")
			})
			assert.Panics(t, func() {
				mustparseChunk(t, "%/home/e{:username}")
			})
			assert.Panics(t, func() {
				mustparseChunk(t, "%/home/{:username}e")
			})
			assert.Panics(t, func() {
				mustparseChunk(t, "%/home/e{:username}e")
			})
			assert.Panics(t, func() {
				mustparseChunk(t, "%/home/e{:username}e/{$a}/")
			})
			assert.Panics(t, func() {
				mustparseChunk(t, "%/home/e{:username}e/{}")
			})
			assert.Panics(t, func() {
				mustparseChunk(t, "%/home/e{:username}e/{}/")
			})
			assert.Panics(t, func() {
				mustparseChunk(t, "%/home/{")
			})
			assert.Panics(t, func() {
				mustparseChunk(t, "%/home/{:")
			})
		})
	})

	t.Run("path pattern expression", func(t *testing.T) {
		t.Run("trailing interpolation", func(t *testing.T) {
			n := mustparseChunk(t, "%/home/{$username}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.PathPatternExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 18},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_SYMBOL, Span: NodeSpan{0, 1}},
								{Type: ast.SINGLE_INTERP_OPENING_BRACE, Span: NodeSpan{7, 8}},
								{Type: ast.SINGLE_INTERP_CLOSING_BRACE, Span: NodeSpan{17, 18}},
							},*/
						},
						Slices: []ast.Node{
							&ast.PathPatternSlice{
								NodeBase: ast.NodeBase{NodeSpan{1, 7}, nil, false},
								Value:    "/home/",
							},
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{8, 17}, nil, false},
								Name:     "username",
							},
						},
					},
				},
			}, n)
		})

		t.Run("empty trailing interpolation", func(t *testing.T) {
			n, err := parseChunk(t, "%/home/{}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.PathPatternExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_SYMBOL, Span: NodeSpan{0, 1}},
								{Type: ast.SINGLE_INTERP_OPENING_BRACE, Span: NodeSpan{7, 8}},
								{Type: ast.SINGLE_INTERP_CLOSING_BRACE, Span: NodeSpan{8, 9}},
							},*/
						},
						Slices: []ast.Node{
							&ast.PathPatternSlice{
								NodeBase: ast.NodeBase{NodeSpan{1, 7}, nil, false},
								Value:    "/home/",
							},
							&ast.UnknownNode{
								NodeBase: ast.NodeBase{
									NodeSpan{8, 8},
									&sourcecode.ParsingError{UnspecifiedParsingError, EMPTY_PATH_INTERP},
									false,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("named segments are not allowed", func(t *testing.T) {
			n, err := parseChunk(t, "%/`home/{$username}`", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.PathPatternExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 20},
							&sourcecode.ParsingError{UnspecifiedParsingError, QUOTED_PATH_PATTERN_EXPRS_ARE_NOT_SUPPORTED_YET},
							false,
						},
						Slices: []ast.Node{
							&ast.PathPatternSlice{
								NodeBase: ast.NodeBase{NodeSpan{1, 8}, nil, false},
								Value:    "/`home/",
							},
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{9, 18}, nil, false},
								Name:     "username",
							},
							&ast.PathPatternSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "`",
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("path expression", func(t *testing.T) {
		t.Run("single trailing interpolation (variable)", func(t *testing.T) {
			n := mustparseChunk(t, "/home/{$username}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 17},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.SINGLE_INTERP_OPENING_BRACE, Span: NodeSpan{6, 7}},
								{Type: ast.SINGLE_INTERP_CLOSING_BRACE, Span: NodeSpan{16, 17}},
							},*/
						},
						Slices: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
								Value:    "/home/",
							},
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{7, 16}, nil, false},
								Name:     "username",
							},
						},
					},
				},
			}, n)
		})

		t.Run("single embedded interpolation", func(t *testing.T) {
			n := mustparseChunk(t, "/home/{$username}/projects")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 26},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.SINGLE_INTERP_OPENING_BRACE, Span: NodeSpan{6, 7}},
								{Type: ast.SINGLE_INTERP_CLOSING_BRACE, Span: NodeSpan{16, 17}},
							},*/
						},
						Slices: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
								Value:    "/home/",
							},
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{7, 16}, nil, false},
								Name:     "username",
							},
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{17, 26}, nil, false},
								Value:    "/projects",
							},
						},
					},
				},
			}, n)
		})

		t.Run("single trailing interpolation (identifier)", func(t *testing.T) {
			n := mustparseChunk(t, "/home/{username}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 16},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.SINGLE_INTERP_OPENING_BRACE, Span: NodeSpan{6, 7}},
								{Type: ast.SINGLE_INTERP_CLOSING_BRACE, Span: NodeSpan{15, 16}},
							},*/
						},
						Slices: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
								Value:    "/home/",
							},
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 15}, nil, false},
								Name:     "username",
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated interpolation: code ends after '{'", func(t *testing.T) {
			n, err := parseChunk(t, "/home/{", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.SINGLE_INTERP_OPENING_BRACE, Span: NodeSpan{6, 7}},
							},*/
						},
						Slices: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
								Value:    "/home/",
							},
							&ast.PathSlice{
								NodeBase: ast.NodeBase{
									NodeSpan{7, 7},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_PATH_INTERP},
									false,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated interpolation: linefeed after '{'", func(t *testing.T) {
			n, err := parseChunk(t, "/home/{\n", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.SINGLE_INTERP_OPENING_BRACE, Span: NodeSpan{6, 7}},
							},*/
						},
						Slices: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
								Value:    "/home/",
							},
							&ast.PathSlice{
								NodeBase: ast.NodeBase{
									NodeSpan{7, 7},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_PATH_INTERP},
									false,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("named segments are not allowed", func(t *testing.T) {
			n, err := parseChunk(t, "/home/{:username}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.AbsolutePathExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 17},
							&sourcecode.ParsingError{UnspecifiedParsingError, ONLY_PATH_PATTERNS_CAN_CONTAIN_NAMED_SEGMENTS},
							false,
							/*[]ast.Token{
								{Type: ast.SINGLE_INTERP_OPENING_BRACE, Span: NodeSpan{6, 7}},
								{Type: ast.SINGLE_INTERP_CLOSING_BRACE, Span: NodeSpan{16, 17}},
							},*/
						},
						Slices: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
								Value:    "/home/",
							},
							&ast.NamedPathSegment{
								NodeBase: ast.NodeBase{NodeSpan{7, 16}, nil, false},
								Name:     "username",
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("regexp literal", func(t *testing.T) {
		t.Run("empty", func(t *testing.T) {
			n := mustparseChunk(t, "%``")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.RegularExpressionLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
						Value:    "",
						Raw:      "%``",
					},
				},
			}, n)
		})

		t.Run("not empty", func(t *testing.T) {
			n := mustparseChunk(t, "%`a+`")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.RegularExpressionLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Value:    "a+",
						Raw:      "%`a+`",
					},
				},
			}, n)
		})

		t.Run("unterminated", func(t *testing.T) {
			n, err := parseChunk(t, "%`", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.RegularExpressionLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 2},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_REGEX_LIT},
							false,
						},
						Value: "",
						Raw:   "%`",
					},
				},
			}, n)
		})

		t.Run("unprefixed", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = ``")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.RegularExpressionLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{12, 14}, nil, false},
							Value:      "",
							Raw:        "``",
							Unprefixed: true,
						},
					},
				},
			}, n)
		})

	})

	t.Run("nil literal", func(t *testing.T) {
		n := mustparseChunk(t, "nil")
		assert.EqualValues(t, &ast.Chunk{
			NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
			Statements: []ast.Node{
				&ast.NilLiteral{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				},
			},
		}, n)
	})

	t.Run("self expression", func(t *testing.T) {
		n := mustparseChunk(t, "self")
		assert.EqualValues(t, &ast.Chunk{
			NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
			Statements: []ast.Node{
				&ast.SelfExpression{
					NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				},
			},
		}, n)
	})

	t.Run("member expression", func(t *testing.T) {
		t.Run("variable '.' <single letter propname> ", func(t *testing.T) {
			n := mustparseChunk(t, "$a.b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("variable '.' <two-letter propname> ", func(t *testing.T) {
			n := mustparseChunk(t, "$a.bc")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 5}, nil, false},
							Name:     "bc",
						},
					},
				},
			}, n)
		})

		t.Run(" variable '.' <propname> '.' <single-letter propname> ", func(t *testing.T) {
			n := mustparseChunk(t, "$a.b.c")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Left: &ast.MemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
								Name:     "a",
							},
							PropertyName: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Name:     "b",
							},
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Name:     "c",
						},
					},
				},
			}, n)
		})

		t.Run("variable '.?' <name>", func(t *testing.T) {
			n := mustparseChunk(t, "$a.?b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
							Name:     "b",
						},
						Optional: true,
					},
				},
			}, n)
		})

		t.Run("variable '.?'", func(t *testing.T) {
			n, err := parseChunk(t, "$a.?", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							&sourcecode.ParsingError{UnterminatedMemberExpr, UNTERMINATED_MEMB_OR_INDEX_EXPR},
							false,
						},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						Optional: true,
					},
				},
			}, n)
		})

		t.Run("variable '.' <prop name> '.' <two-letter prop name> ", func(t *testing.T) {
			n := mustparseChunk(t, "$a.b.cd")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Left: &ast.MemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
								Name:     "a",
							},
							PropertyName: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Name:     "b",
							},
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 7}, nil, false},
							Name:     "cd",
						},
					},
				},
			}, n)
		})

		t.Run("variable '.?' <prop> '.' <prop name> ", func(t *testing.T) {
			n := mustparseChunk(t, "$a.?b.c")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Left: &ast.MemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
								Name:     "a",
							},
							PropertyName: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
								Name:     "b",
							},
							Optional: true,
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
							Name:     "c",
						},
					},
				},
			}, n)
		})

		t.Run("missing property name: followed by EOF", func(t *testing.T) {
			n, err := parseChunk(t, "$a.", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							&sourcecode.ParsingError{UnterminatedMemberExpr, UNTERMINATED_MEMB_OR_INDEX_EXPR},
							false,
						},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						PropertyName: nil,
					},
				},
			}, n)
		})

		t.Run("missing property name: followed by identifier on next line", func(t *testing.T) {
			n, err := parseChunk(t, "$a.\nb", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 5},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							&sourcecode.ParsingError{UnterminatedMemberExpr, UNTERMINATED_MEMB_OR_INDEX_EXPR},
							false,
						},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						PropertyName: nil,
					},
					&ast.IdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
						Name:     "b",
					},
				},
			}, n)
		})

		t.Run("missing property name: followed by closing delim", func(t *testing.T) {
			n, err := parseChunk(t, "$a.]", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							&sourcecode.ParsingError{UnterminatedMemberExpr, UNTERMINATED_MEMB_OR_INDEX_EXPR},
							false,
						},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						PropertyName: nil,
					},
					&ast.UnknownNode{
						NodeBase: ast.NodeBase{
							NodeSpan{3, 4},
							&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInBlockOrModule(']')},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("long member expression : unterminated", func(t *testing.T) {
			n, err := parseChunk(t, "$a.b.", "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 5},
							&sourcecode.ParsingError{UnterminatedMemberExpr, UNTERMINATED_MEMB_OR_INDEX_EXPR},
							false,
						},
						Left: &ast.MemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
								Name:     "a",
							},
							PropertyName: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Name:     "b",
							},
						},
						PropertyName: nil,
					},
				},
			}, n)
		})

		t.Run("self '.' <two-letter propname> ", func(t *testing.T) {
			n := mustparseChunk(t, "(self.bc)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 8},
							nil,
							true,
						},
						Left: &ast.SelfExpression{
							NodeBase: ast.NodeBase{NodeSpan{1, 5}, nil, false},
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
							Name:     "bc",
						},
					},
				},
			}, n)
		})

		t.Run("meta identifier '.' <two-letter propname> ", func(t *testing.T) {
			n := mustparseChunk(t, "(@a.bc)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}, IsParenthesized: true},
						Left: &ast.MetaIdentifier{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
							Name:     "bc",
						},
					},
				},
			}, n)
		})

		t.Run("call '.' <two-letter propname> ", func(t *testing.T) {
			n := mustparseChunk(t, "a().bc")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Left: &ast.CallExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 3},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{1, 2}},
									{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{2, 3}},
								},*/
							},
							Callee: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
							Name:     "bc",
						},
					},
				},
			}, n)
		})

		t.Run("member of a parenthesized expression", func(t *testing.T) {
			n := mustparseChunk(t, "($a).name")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{
								NodeSpan{1, 3},
								nil,
								true,
								/*[]ast.Token{
									{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{0, 1}},
									{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{3, 4}},
								},*/
							},
							Name: "a",
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 9}, nil, false},
							Name:     "name",
						},
					},
				},
			}, n)
		})

		t.Run("optional member of an identifier member expression", func(t *testing.T) {
			n := mustparseChunk(t, "a.b.?c")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Left: &ast.IdentifierMemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
							PropertyNames: []*ast.IdentifierLiteral{
								{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Name:     "b",
								},
							},
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Name:     "c",
						},
						Optional: true,
					},
				},
			}, n)
		})

		t.Run("double-colon expression", func(t *testing.T) {
			n := mustparseChunk(t, "a::b.c")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.MemberExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Left: &ast.DoubleColonExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 4},
								nil,
								false,
							},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
							Element: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Name:     "b",
							},
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Name:     "c",
						},
					},
				},
			}, n)
		})

	})

	t.Run("computed member expression", func(t *testing.T) {
		t.Run("variable '.' '(' <var> ')'", func(t *testing.T) {
			n := mustparseChunk(t, "$a.(b)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.ComputedMemberExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{4, 5},
								nil,
								true,
								/*[]ast.Token{
									{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{3, 4}},
									{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{5, 6}},
								},*/
							},
							Name: "b",
						},
					},
				},
			}, n)
		})

		t.Run("identifier '.' '(' <var> ')'", func(t *testing.T) {
			n := mustparseChunk(t, "a.(b)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.ComputedMemberExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "a",
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{3, 4},
								nil,
								true,
								/*[]ast.Token{
									{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{2, 3}},
									{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{4, 5}},
								},*/
							},
							Name: "b",
						},
					},
				},
			}, n)
		})

		t.Run(" variable '.' '(' <var> ')' '.'  '(' <var> ')' ", func(t *testing.T) {
			n := mustparseChunk(t, "$a.(b).(c)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.ComputedMemberExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
						Left: &ast.ComputedMemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
								Name:     "a",
							},
							PropertyName: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{
									NodeSpan{4, 5},
									nil,
									true,
									/*[]ast.Token{
										{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{3, 4}},
										{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{5, 6}},
									},*/
								},
								Name: "b",
							},
						},
						PropertyName: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{8, 9},
								nil,
								true,
								/*[]ast.Token{
									{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{7, 8}},
									{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{9, 10}},
								},*/
							},
							Name: "c",
						},
					},
				},
			}, n)
		})

		//TODO: add tests
	})

	t.Run("identifier member expression", func(t *testing.T) {
		t.Run("identifier member expression", func(t *testing.T) {
			n := mustparseChunk(t, "http.get")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.IdentifierMemberExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "http",
						},
						PropertyNames: []*ast.IdentifierLiteral{
							{
								NodeBase: ast.NodeBase{NodeSpan{5, 8}, nil, false},
								Name:     "get",
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized identifier member expression", func(t *testing.T) {
			n := mustparseChunk(t, "(http.get)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.IdentifierMemberExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 9},
							nil,
							true,
							/*[]ast.Token{
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{0, 1}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{9, 10}},
							},*/
						},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{1, 5}, nil, false},
							Name:     "http",
						},
						PropertyNames: []*ast.IdentifierLiteral{
							{
								NodeBase: ast.NodeBase{NodeSpan{6, 9}, nil, false},
								Name:     "get",
							},
						},
					},
				},
			}, n)
		})
		t.Run("parenthesized identifier member expression followed by a space", func(t *testing.T) {
			n := mustparseChunk(t, "(http.get) ")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.IdentifierMemberExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 9},
							nil,
							true,
							/*[]ast.Token{
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{0, 1}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{9, 10}},
							},*/
						},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{1, 5}, nil, false},
							Name:     "http",
						},
						PropertyNames: []*ast.IdentifierLiteral{
							{
								NodeBase: ast.NodeBase{NodeSpan{6, 9}, nil, false},
								Name:     "get",
							},
						},
					},
				},
			}, n)
		})

		t.Run("missing last property name: followed by EOF", func(t *testing.T) {
			n, err := parseChunk(t, "http.", "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.IdentifierMemberExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 5},
							&sourcecode.ParsingError{UnterminatedMemberExpr, UNTERMINATED_IDENT_MEMB_EXPR},
							false,
						},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "http",
						},
						PropertyNames: nil,
					},
				},
			}, n)
		})

		t.Run("missing last property name, followed by an identifier on the next line", func(t *testing.T) {
			n, err := parseChunk(t, "http.\na", "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 7},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.IdentifierMemberExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 5},
							&sourcecode.ParsingError{UnterminatedMemberExpr, UNTERMINATED_IDENT_MEMB_EXPR},
							false,
						},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "http",
						},
						PropertyNames: nil,
					},
					&ast.IdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
						Name:     "a",
					},
				},
			}, n)
		})

		t.Run("missing last property name, followed by a closing delimiter", func(t *testing.T) {
			n, err := parseChunk(t, "http.]", "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.IdentifierMemberExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 5},
							&sourcecode.ParsingError{UnterminatedMemberExpr, UNTERMINATED_IDENT_MEMB_EXPR},
							false,
						},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "http",
						},
						PropertyNames: nil,
					},
					&ast.UnknownNode{
						NodeBase: ast.NodeBase{
							NodeSpan{5, 6},
							&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInBlockOrModule(']')},
							false,
						},
					},
				},
			}, n)
		})

	})

	t.Run("extraction expression", func(t *testing.T) {
		t.Run("variable", func(t *testing.T) {
			n := mustparseChunk(t, "$a.{name}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.ExtractionExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
						Object: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						Keys: &ast.KeyListExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{2, 9},
								nil,
								false,
							},
							Keys: []ast.Node{
								&ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
									Name:     "name",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("identifier", func(t *testing.T) {
			n := mustparseChunk(t, "a.{name}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.ExtractionExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
						Object: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "a",
						},
						Keys: &ast.KeyListExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 8}},
							Keys: []ast.Node{
								&ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 7}, nil, false},
									Name:     "name",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("identifier member expression", func(t *testing.T) {
			n := mustparseChunk(t, "a.b.{name}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.ExtractionExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
						Object: &ast.IdentifierMemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
							PropertyNames: []*ast.IdentifierLiteral{
								{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Name:     "b",
								},
							},
						},
						Keys: &ast.KeyListExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{3, 10}},
							Keys: []ast.Node{
								&ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 9}, nil, false},
									Name:     "name",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("computed member expression", func(t *testing.T) {
			n := mustparseChunk(t, `a.("b").{name}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.ExtractionExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
						Object: &ast.ComputedMemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
							PropertyName: &ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{
									NodeSpan{3, 6},
									nil,
									true,
								},
								Raw:   `"b"`,
								Value: "b",
							},
						},
						Keys: &ast.KeyListExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{7, 14}},
							Keys: []ast.Node{
								&ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{9, 13}, nil, false},
									Name:     "name",
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("parenthesized expression", func(t *testing.T) {
		n := mustparseChunk(t, "($a)")
		assert.EqualValues(t, &ast.Chunk{
			NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
			Statements: []ast.Node{
				&ast.Variable{
					NodeBase: ast.NodeBase{
						NodeSpan{1, 3},
						nil,
						true,
						/*[]ast.Token{
							{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{0, 1}},
							{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{3, 4}},
						},*/
					},
					Name: "a",
				},
			},
		}, n)
	})

	t.Run("index expression", func(t *testing.T) {

		t.Run("variable '[' <integer literal> '] ", func(t *testing.T) {
			n := mustparseChunk(t, "$a[0]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.IndexExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Indexed: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						Index: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
							Raw:      "0",
							Value:    0,
						},
					},
				},
			}, n)
		})

		t.Run("<member expression> '[' <integer literal> '] ", func(t *testing.T) {
			n := mustparseChunk(t, "$a.b[0]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.IndexExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Indexed: &ast.MemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
								Name:     "a",
							},
							PropertyName: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Name:     "b",
							},
						},
						Index: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Raw:      "0",
							Value:    0,
						},
					},
				},
			}, n)
		})

		t.Run("<double-colon expression> '[' <integer literal> '] ", func(t *testing.T) {
			n := mustparseChunk(t, "a::b[0]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.IndexExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Indexed: &ast.DoubleColonExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 4},
								nil,
								false,
							},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
							Element: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Name:     "b",
							},
						},
						Index: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Raw:      "0",
							Value:    0,
						},
					},
				},
			}, n)
		})

		t.Run("unterminated : variable '[' ", func(t *testing.T) {
			n, err := parseChunk(t, "$a[", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.InvalidMemberLike{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_MEMB_OR_INDEX_EXPR},
							false,
						},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
					},
				},
			}, n)
		})

		t.Run("identifier '[' <integer literal> '] ", func(t *testing.T) {
			n := mustparseChunk(t, "a[0]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.IndexExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Indexed: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "a",
						},
						Index: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
							Raw:      "0",
							Value:    0,
						},
					},
				},
			}, n)
		})

		t.Run("short identifier member expression '[' <integer literal> '] ", func(t *testing.T) {
			n := mustparseChunk(t, "a.b[0]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.IndexExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Indexed: &ast.IdentifierMemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
							PropertyNames: []*ast.IdentifierLiteral{
								{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Name:     "b",
								},
							},
						},
						Index: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
							Raw:      "0",
							Value:    0,
						},
					},
				},
			}, n)
		})

		t.Run("long identifier member expression '[' <integer literal> '] ", func(t *testing.T) {
			n := mustparseChunk(t, "a.b.c[0]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.IndexExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
						Indexed: &ast.IdentifierMemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
							PropertyNames: []*ast.IdentifierLiteral{
								{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Name:     "b",
								},
								{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:     "c",
								},
							},
						},
						Index: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
							Raw:      "0",
							Value:    0,
						},
					},
				},
			}, n)
		})

		t.Run("call '[' <integer literal> '] ", func(t *testing.T) {
			n := mustparseChunk(t, "a()[0]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.IndexExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Indexed: &ast.CallExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 3},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{1, 2}},
									{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{2, 3}},
								},*/
							},

							Callee: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
						},
						Index: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
							Raw:      "0",
							Value:    0,
						},
					},
				},
			}, n)
		})
	})

	t.Run("slice expression", func(t *testing.T) {
		t.Run("variable '[' <integer literal> ':' ] ", func(t *testing.T) {
			n := mustparseChunk(t, "$a[0:]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.SliceExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Indexed: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						StartIndex: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
							Raw:      "0",
							Value:    0,
						},
					},
				},
			}, n)
		})

		t.Run("variable '['  ':' <integer literal> ] ", func(t *testing.T) {
			n := mustparseChunk(t, "$a[:1]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.SliceExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Indexed: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						EndIndex: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
							Raw:      "1",
							Value:    1,
						},
					},
				},
			}, n)
		})

		t.Run("variable '[' ':' ']' : invalid ", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, "$a[:]")
			})
		})

		t.Run("variable '[' ':' <integer literal> ':' ']' : invalid ", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, "$a[:1:]")
			})
		})

	})

	t.Run("double-colon expression", func(t *testing.T) {
		t.Run("single element", func(t *testing.T) {
			n := mustparseChunk(t, "a::b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.DoubleColonExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							nil,
							false,
						},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "a",
						},
						Element: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("single element: unterminated", func(t *testing.T) {
			n, err := parseChunk(t, "a::", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.DoubleColonExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							&sourcecode.ParsingError{UnterminatedDoubleColonExpr, UNTERMINATED_DOUBLE_COLON_EXPR},
							false,
						},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "a",
						},
					},
				},
			}, n)
		})

		t.Run("element: identifier member expression", func(t *testing.T) {
			n := mustparseChunk(t, "a.b::c")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.DoubleColonExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							nil,
							false,
						},
						Left: &ast.IdentifierMemberExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 3}},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
							PropertyNames: []*ast.IdentifierLiteral{
								{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Name:     "b",
								},
							},
						},
						Element: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Name:     "c",
						},
					},
				},
			}, n)
		})

		t.Run("two elements", func(t *testing.T) {
			n := mustparseChunk(t, "a::b::c")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.DoubleColonExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							nil,
							false,
						},
						Left: &ast.DoubleColonExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 4},
								nil,
								false,
							},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
							Element: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Name:     "b",
							},
						},
						Element: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
							Name:     "c",
						},
					},
				},
			}, n)
		})

		t.Run("two elements: unterminated", func(t *testing.T) {
			n, err := parseChunk(t, "a::b::", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.DoubleColonExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							&sourcecode.ParsingError{UnterminatedDoubleColonExpr, UNTERMINATED_DOUBLE_COLON_EXPR},
							false,
						},
						Left: &ast.DoubleColonExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 4},
								nil,
								false,
							},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
							Element: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("key list expression", func(t *testing.T) {

		t.Run("empty", func(t *testing.T) {
			n := mustparseChunk(t, ".{}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.KeyListExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							nil,
							false,
						},
						Keys: nil,
					},
				},
			}, n)
		})

		t.Run("one key", func(t *testing.T) {
			n := mustparseChunk(t, ".{name}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.KeyListExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							nil,
							false,
						},
						Keys: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{2, 6}, nil, false},
								Name:     "name",
							},
						},
					},
				},
			}, n)
		})

		t.Run("unexpected char", func(t *testing.T) {
			n, err := parseChunk(t, ".{:}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.KeyListExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							nil,
							false,
						},
						Keys: []ast.Node{
							&ast.UnknownNode{
								NodeBase: ast.NodeBase{
									NodeSpan{2, 3},
									&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInKeyList(':')},
									false,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("two keys separated by space", func(t *testing.T) {
			n := mustparseChunk(t, ".{name age}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.KeyListExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							nil,
							false,
						},
						Keys: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{2, 6}, nil, false},
								Name:     "name",
							},
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 10}, nil, false},
								Name:     "age",
							},
						},
					},
				},
			}, n)
		})

	})

	t.Run("url literal", func(t *testing.T) {

		t.Run("host contains a -", func(t *testing.T) {
			n := mustparseChunk(t, `https://an-example.com/`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
						Value:    "https://an-example.com/",
					},
				},
			}, n)
		})

		t.Run("long sub domain", func(t *testing.T) {
			n := mustparseChunk(t, `https://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.example.com/`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 60}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 60}, nil, false},
						Value:    "https://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.example.com/",
					},
				},
			}, n)
		})

		t.Run("long domain", func(t *testing.T) {
			n := mustparseChunk(t, `https://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.com/`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 52}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 52}, nil, false},
						Value:    "https://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.com/",
					},
				},
			}, n)
		})

		t.Run("port out of range: max char count", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com:9999999/`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 28},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_URL + ": " + NET_PORT_INVALID_OR_OUT_OR_RANGE},
							false,
						},
						Value: "https://example.com:9999999/",
					},
				},
			}, n)
		})

		t.Run("port out of range", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com:999999999/`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 30}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 30},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_URL + ": " + NET_PORT_INVALID_OR_OUT_OR_RANGE},
							false,
						},
						Value: "https://example.com:999999999/",
					},
				},
			}, n)
		})

		t.Run(".. in hostname", func(t *testing.T) {
			n, err := parseChunk(t, `https://example..com/`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 21},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_URL},
							false,
						},
						Value: "https://example..com/",
					},
				},
			}, n)
		})

		t.Run("subdomain", func(t *testing.T) {
			n := mustparseChunk(t, `https://sub.example.com/`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
						Value:    "https://sub.example.com/",
					},
				},
			}, n)
		})

		t.Run("subdomain contains -", func(t *testing.T) {
			n := mustparseChunk(t, `https://sub-x.example.com/`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
						Value:    "https://sub-x.example.com/",
					},
				},
			}, n)
		})

		t.Run("root path", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com/`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
						Value:    "https://example.com/",
					},
				},
			}, n)
		})

		t.Run("path ends with ..", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com/..`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
						Value:    "https://example.com/..",
					},
				},
			}, n)
		})

		t.Run("path ends with ...", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com/...`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
						Value:    "https://example.com/...",
					},
				},
			}, n)
		})

		t.Run("empty query", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com/?`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
						Value:    "https://example.com/?",
					},
				},
			}, n)
		})

		t.Run("not empty query", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com/?a=1`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
						Value:    "https://example.com/?a=1",
					},
				},
			}, n)
		})

		t.Run("host followed by ')'", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, `https://example.com)`)
			})
		})

		t.Run("host followed by > in binary expression", func(t *testing.T) {
			n := mustparseChunk(t, `(https://example.com> 1)`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, true},
						Operator: ast.GreaterThan,
						Left: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{1, 20}, nil, false},
							Value:    "https://example.com",
						},
						Right: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{22, 23}, nil, false},
							Raw:      "1",
							Value:    1,
						},
					},
				},
			}, n)
		})

		t.Run("URL followed by > in binary expression", func(t *testing.T) {
			n := mustparseChunk(t, `(https://example.com/> 1)`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, true},
						Operator: ast.GreaterThan,
						Left: &ast.URLLiteral{
							NodeBase: ast.NodeBase{NodeSpan{1, 21}, nil, false},
							Value:    "https://example.com/",
						},
						Right: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{23, 24}, nil, false},
							Raw:      "1",
							Value:    1,
						},
					},
				},
			}, n)
		})

		t.Run("long path", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 106}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 106}, nil, false},
						Value:    "https://example.com/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
					},
				},
			}, n)
		})

		t.Run("non-trailing colon", func(t *testing.T) {
			n := mustparseChunk(t, "https://example.com/a:b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.URLLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
						Value:    "https://example.com/a:b",
					},
				},
			}, n)
		})
	})

	t.Run("url pattern literal", func(t *testing.T) {
		t.Run("prefix pattern, root", func(t *testing.T) {
			n := mustparseChunk(t, `%https://example.com/...`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.URLPatternLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
						Value:    "https://example.com/...",
						Raw:      "%https://example.com/...",
					},
				},
			}, n)
		})

		t.Run("prefix pattern", func(t *testing.T) {
			n := mustparseChunk(t, `%https://example.com/a/...`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
				Statements: []ast.Node{
					&ast.URLPatternLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
						Value:    "https://example.com/a/...",
						Raw:      "%https://example.com/a/...",
					},
				},
			}, n)
		})

		t.Run("prefix pattern containing two dots", func(t *testing.T) {
			n := mustparseChunk(t, `%https://example.com/../...`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
				Statements: []ast.Node{
					&ast.URLPatternLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
						Value:    "https://example.com/../...",
						Raw:      "%https://example.com/../...",
					},
				},
			}, n)
		})

		t.Run("prefix pattern containing non trailing /...", func(t *testing.T) {
			n, err := parseChunk(t, `%https://example.com/.../a`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
				Statements: []ast.Node{
					&ast.URLPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 26},
							&sourcecode.ParsingError{UnspecifiedParsingError, URL_PATTERN_SUBSEQUENT_DOT_EXPLANATION},
							false,
						},
						Value: "https://example.com/.../a",
						Raw:   "%https://example.com/.../a",
					},
				},
			}, n)
		})

		t.Run("prefix pattern containing non trailing /... and trailing /...", func(t *testing.T) {
			n, err := parseChunk(t, `%https://example.com/.../...`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.URLPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 28},
							&sourcecode.ParsingError{UnspecifiedParsingError, URL_PATTERN_SUBSEQUENT_DOT_EXPLANATION},
							false,
						},
						Value: "https://example.com/.../...",
						Raw:   "%https://example.com/.../...",
					},
				},
			}, n)
		})

		t.Run("trailing /....", func(t *testing.T) {
			n, err := parseChunk(t, `%https://example.com/....`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.URLPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 25},
							&sourcecode.ParsingError{UnspecifiedParsingError, URL_PATTERNS_CANNOT_END_WITH_SLASH_MORE_THAN_4_DOTS},
							false,
						},
						Value: "https://example.com/....",
						Raw:   "%https://example.com/....",
					},
				},
			}, n)
		})

		t.Run("non-trailing colon", func(t *testing.T) {
			n := mustparseChunk(t, "%https://example.com/a:b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.URLPatternLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
						Raw:      "%https://example.com/a:b",
						Value:    "https://example.com/a:b",
					},
				},
			}, n)
		})

		t.Run("port out of range: max char count", func(t *testing.T) {
			n, err := parseChunk(t, `%https://example.com:9999999/`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 29}, nil, false},
				Statements: []ast.Node{
					&ast.URLPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 29},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_URL_PATT + ": " + NET_PORT_INVALID_OR_OUT_OR_RANGE},
							false,
						},
						Raw:   "%https://example.com:9999999/",
						Value: "https://example.com:9999999/",
					},
				},
			}, n)
		})

		t.Run("port out of range", func(t *testing.T) {
			n, err := parseChunk(t, `%https://example.com:999999999/`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
				Statements: []ast.Node{
					&ast.URLPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 31},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_URL_PATT + ": " + NET_PORT_INVALID_OR_OUT_OR_RANGE},
							false,
						},
						Raw:   "%https://example.com:999999999/",
						Value: "https://example.com:999999999/",
					},
				},
			}, n)
		})

		t.Run(".. in hostname", func(t *testing.T) {
			n, err := parseChunk(t, `%https://example..com/`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.URLPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 22},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_URL_PATT},
							false,
						},
						Raw:   "%https://example..com/",
						Value: "https://example..com/",
					},
				},
			}, n)
		})

		t.Run("unprefixed", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = https://example.com/")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 32}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 32}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.URLPatternLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{12, 32}, nil, false},
							Raw:        "https://example.com/",
							Value:      "https://example.com/",
							Unprefixed: true,
						},
					},
				},
			}, n)
		})
	})

	t.Run("host literal", func(t *testing.T) {

		testCases := map[string]struct {
			result *ast.Chunk
			err    bool
		}{
			`https://example.com`: {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
					Statements: []ast.Node{
						&ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
					},
				},
			},
			`wss://example.com`: {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
					Statements: []ast.Node{
						&ast.HostLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 17},
							},
							Value: "wss://example.com",
						},
					},
				},
			},
			"://example.com": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
					Statements: []ast.Node{
						&ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
							Value:    "://example.com",
						},
					},
				},
			},
			`https://example..com`: {
				err: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
					Statements: []ast.Node{
						&ast.HostLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 20},
								Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_HOST_LIT},
							},
							Value: "https://example..com",
						},
					},
				},
			},
			`https://user@example.com`: {
				err: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
					Statements: []ast.Node{
						&ast.HostLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 24},
								Err:  &sourcecode.ParsingError{UnspecifiedParsingError, CREDENTIALS_NOT_ALLOWED_IN_HOST_LITERALS},
							},
							Value: "https://user@example.com",
						},
					},
				},
			},
			`https:/`: {
				err: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
					Statements: []ast.Node{
						&ast.InvalidURL{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 7},
								Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_SCHEME_HOST_OR_URL_SLASH_EXPECTED},
							},
							Value: "https:/",
						},
					},
				},
			},
			`https:/a`: {
				err: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
					Statements: []ast.Node{
						&ast.InvalidURL{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 8},
								Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_SCHEME_HOST_OR_URL_SLASH_EXPECTED},
							},
							Value: "https:/a",
						},
					},
				},
			},
			`https://*.com`: {
				err: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
					Statements: []ast.Node{
						&ast.InvalidURL{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 13},
								Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_URL_OR_HOST},
							},
							Value: "https://*.com",
						},
					},
				},
			},
			`https://**`: {
				err: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
					Statements: []ast.Node{
						&ast.InvalidURL{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 10},
								Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_URL_OR_HOST},
							},
							Value: "https://**",
						},
					},
				},
			},
			`https://example.com:99999`: {
				err: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
					Statements: []ast.Node{
						&ast.HostLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 25},
								Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_HOST_LIT + ": " + NET_PORT_INVALID_OR_OUT_OR_RANGE},
							},
							Value: "https://example.com:99999",
						},
					},
				},
			},
			`https://example.com:9999999`: {
				err: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
					Statements: []ast.Node{
						&ast.HostLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 27},
								Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_HOST_LIT + ": " + NET_PORT_INVALID_OR_OUT_OR_RANGE},
							},
							Value: "https://example.com:9999999",
						},
					},
				},
			},
		}

		for name, testCase := range testCases {
			t.Run(name, func(t *testing.T) {
				if testCase.err {
					n, err := parseChunk(t, name, "")
					if assert.Error(t, err) {
						assert.EqualValues(t, testCase.result, n)
					}
				} else {
					n := mustparseChunk(t, name)
					assert.EqualValues(t, testCase.result, n)
				}
			})
		}
	})

	t.Run("scheme literal", func(t *testing.T) {
		t.Run("HTTP", func(t *testing.T) {
			n := mustparseChunk(t, `http://`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.SchemeLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Name:     "http",
					},
				},
			}, n)
		})

		t.Run("Websocket", func(t *testing.T) {
			n := mustparseChunk(t, "wss://")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.SchemeLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Name:     "wss",
					},
				},
			}, n)
		})

		t.Run("in pattern region", func(t *testing.T) {
			n := mustparseChunk(t, `pattern p = http://`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.SchemeLiteral{
							NodeBase: ast.NodeBase{NodeSpan{12, 19}, nil, false},
							Name:     "http",
						},
					},
				},
			}, n)
		})

		t.Run("in pattern region, one slash missing", func(t *testing.T) {
			n, err := parseChunk(t, `pattern p = http:/`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.InvalidURL{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 18},
								&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_SCHEME_LIT_SLASH_EXPECTED},
								false,
							},
							Value: "http:/",
						},
					},
				},
			}, n)
		})

		t.Run("missing scheme name", func(t *testing.T) {
			n, err := parseChunk(t, `://`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.SchemeLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_SCHEME_LIT_MISSING_SCHEME},
							false,
						},
						Name: "",
					},
				},
			}, n)
		})
	})

	t.Run("host pattern", func(t *testing.T) {
		t.Run("%https://**:443", func(t *testing.T) {
			n := mustparseChunk(t, `%https://**:443`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.HostPatternLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
						Value:    "https://**:443",
						Raw:      "%https://**:443",
					},
				},
			}, n)
		})

		t.Run("%https://*.<tld>", func(t *testing.T) {
			n := mustparseChunk(t, `%https://*.com`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.HostPatternLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
						Value:    "https://*.com",
						Raw:      "%https://*.com",
					},
				},
			}, n)
		})

		t.Run("%https://a*.<tld>", func(t *testing.T) {
			n := mustparseChunk(t, `%https://a*.com`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.HostPatternLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
						Value:    "https://a*.com",
						Raw:      "%https://a*.com",
					},
				},
			}, n)
		})

		t.Run("%https://* (invalid)", func(t *testing.T) {
			n, err := parseChunk(t, `%https://*`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.HostPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 10},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_HOST_PATT_SUGGEST_DOUBLE_STAR},
							false,
						},
						Value: "https://*",
						Raw:   "%https://*",
					},
				},
			}, n)
		})

		t.Run("%https://**", func(t *testing.T) {
			n := mustparseChunk(t, `%https://**`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.HostPatternLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
						Value:    "https://**",
						Raw:      "%https://**",
					},
				},
			}, n)
		})

		t.Run("%https://*.* (invalid)", func(t *testing.T) {
			n, err := parseChunk(t, `%https://*.*`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.HostPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_HOST_PATT},
							false,
						},
						Value: "https://*.*",
						Raw:   "%https://*.*",
					},
				},
			}, n)
		})

		t.Run("%https://example..com (invalid)", func(t *testing.T) {
			n, err := parseChunk(t, `%https://example..com`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.HostPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 21},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_HOST_PATT},
							false,
						},
						Value: "https://example..com",
						Raw:   "%https://example..com",
					},
				},
			}, n)
		})

		t.Run("credentials are not allowed", func(t *testing.T) {
			n, err := parseChunk(t, `%https://user@example.com`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.HostPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 25},
							&sourcecode.ParsingError{UnspecifiedParsingError, CREDENTIALS_NOT_ALLOWED_IN_HOST_PATTERN_LITERALS},
							false,
						},
						Value: "https://user@example.com",
						Raw:   "%https://user@example.com",
					},
				},
			}, n)
		})

		t.Run("%https://localhost", func(t *testing.T) {
			n := mustparseChunk(t, `%https://localhost`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.HostPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 18}},
						Value:    "https://localhost",
						Raw:      "%https://localhost",
					},
				},
			}, n)
		})

		t.Run("port out of range: max char count", func(t *testing.T) {
			n, err := parseChunk(t, `%https://**:99999`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.HostPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 17},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_HOST_PATT + ": " + NET_PORT_INVALID_OR_OUT_OR_RANGE},
							false,
						},
						Value: "https://**:99999",
						Raw:   "%https://**:99999",
					},
				},
			}, n)
		})

		t.Run("port out of range", func(t *testing.T) {
			n, err := parseChunk(t, `%https://**:9999999`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.HostPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 19},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_HOST_PATT + ": " + NET_PORT_INVALID_OR_OUT_OR_RANGE},
							false,
						},
						Value: "https://**:9999999",
						Raw:   "%https://**:9999999",
					},
				},
			}, n)
		})

		t.Run("missing hostname", func(t *testing.T) {
			n, err := parseChunk(t, `%https://`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.HostPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_HOST_PATT_MISSING_HOSTNAME},
							false,
						},
						Value: "https://",
						Raw:   "%https://",
					},
				},
			}, n)
		})

		t.Run("missing one slash after scheme", func(t *testing.T) {
			n, err := parseChunk(t, `pattern p = http:/*.com`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.InvalidURLPattern{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 23},
								&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_URL_OR_HOST_PATT_SCHEME_SHOULD_BE_FOLLOWED_BY_COLON_SLASH_SLASH},
								false,
							},
							Value: "http:/*.com",
						},
					},
				},
			}, n)
		})

		t.Run("unprefixed", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = https://**")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.HostPatternLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{12, 22}, nil, false},
							Raw:        "https://**",
							Value:      "https://**",
							Unprefixed: true,
						},
					},
				},
			}, n)
		})

		t.Run("unprefixed, missing one slash after scheme", func(t *testing.T) {
			n, err := parseChunk(t, `pattern p = http:/*.com`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.InvalidURLPattern{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 23},
								&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_URL_OR_HOST_PATT_SCHEME_SHOULD_BE_FOLLOWED_BY_COLON_SLASH_SLASH},
								false,
							},
							Value: "http:/*.com",
						},
					},
				},
			}, n)
		})

	})

	t.Run("url expressions", func(t *testing.T) {
		t.Run("no query, host interpolation", func(t *testing.T) {
			n := mustparseChunk(t, `https://{$host}/`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 16}},
						Raw:      "https://{$host}/",
						HostPart: &ast.HostExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
							Scheme: &ast.SchemeLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
								Name:     "https",
							},
							Raw: `https://{$host}`,
							Host: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{9, 14}, nil, false},
								Name:     "host",
							},
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("whole host interpolation", func(t *testing.T) {
			n := mustparseChunk(t, `$host/`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
						Raw:      "$host/",
						HostPart: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "host",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("whole host interpolation: uppercase", func(t *testing.T) {
			n := mustparseChunk(t, `$HOST/`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
						Raw:      "$HOST/",
						HostPart: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "HOST",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("no query, single trailing path interpolation, no '/'", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com{$path}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 26}},
						Raw:      "https://example.com{$path}",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 19}, nil, false},
								Value:    "",
							},
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{20, 25}, nil, false},
								Name:     "path",
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("no query, single trailing path interpolation preceded by a port, no '/'", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com:80{$path}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 29}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 29}},
						Raw:      "https://example.com:80{$path}",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
							Value:    "https://example.com:80",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{22, 22}, nil, false},
								Value:    "",
							},
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{23, 28}, nil, false},
								Name:     "path",
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("no query, host interpolation & path interpolation, no '/'", func(t *testing.T) {
			n := mustparseChunk(t, `https://{$host}{$path}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 22}},
						Raw:      "https://{$host}{$path}",
						HostPart: &ast.HostExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},

							Scheme: &ast.SchemeLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
								Name:     "https",
							},
							Raw: `https://{$host}`,
							Host: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{9, 14}, nil, false},
								Name:     "host",
							},
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{15, 15}, nil, false},
								Value:    "",
							},
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{16, 21}, nil, false},
								Name:     "path",
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("trailing path interpolation after '/'", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com/{$path}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 27}},
						Raw:      "https://example.com/{$path}",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{21, 26}, nil, false},
								Name:     "path",
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run(".. in hostname", func(t *testing.T) {
			n, err := parseChunk(t, `https://example..com{$path}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 27}},
						Raw:      "https://example..com{$path}",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 20},
								&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_HOST_LIT},
								false,
							},
							Value: "https://example..com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{20, 20}, nil, false},
								Value:    "",
							},
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{21, 26}, nil, false},
								Name:     "path",
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("two path interpolations", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com/{$a}{$b}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 28}},
						Raw:      "https://example.com/{$a}{$b}",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{21, 23}, nil, false},
								Name:     "a",
							},
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{24, 24}, nil, false},
								Value:    "",
							},
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{25, 27}, nil, false},
								Name:     "b",
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("unterminated path interpolation: missing value after '{'", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com/{`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 21}},
						Raw:      "https://example.com/{",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
							&ast.PathSlice{
								NodeBase: ast.NodeBase{
									NodeSpan{21, 21},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_PATH_INTERP},
									false,
								},
								Value: "",
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("unterminated path interpolation: linefeed after '{'", func(t *testing.T) {
			n, err := parseChunk(t, "https://example.com/{\n", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 21}},
						Raw:      "https://example.com/{",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
							&ast.PathSlice{
								NodeBase: ast.NodeBase{
									NodeSpan{21, 21},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_PATH_INTERP},
									false,
								},
								Value: "",
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("unterminated path interpolation: missing '}'", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com/{1`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 22}},
						Raw:      "https://example.com/{1",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
							&ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{21, 22}, nil, false},
								Value:    1,
								Raw:      "1",
							},
							&ast.PathSlice{
								NodeBase: ast.NodeBase{
									NodeSpan{22, 22},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_PATH_INTERP_MISSING_CLOSING_BRACE},
									false,
								},
								Value: "",
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("empty path interpolation", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com/{}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 22}},
						Raw:      "https://example.com/{}",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
							&ast.UnknownNode{
								NodeBase: ast.NodeBase{
									NodeSpan{21, 21},
									&sourcecode.ParsingError{UnspecifiedParsingError, EMPTY_PATH_INTERP},
									false,
								},
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("invalid path interpolation", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com/{.}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 23}},
						Raw:      "https://example.com/{.}",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
							&ast.UnknownNode{
								NodeBase: ast.NodeBase{
									NodeSpan{21, 22},
									&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_PATH_INTERP},
									false,
								},
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("invalid path interpolation followed by a path slice", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com/{.}/`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 24}},
						Raw:      "https://example.com/{.}/",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
							&ast.UnknownNode{
								NodeBase: ast.NodeBase{
									NodeSpan{21, 22},
									&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_PATH_INTERP},
									false,
								},
							},
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{23, 24}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("path interpolation with a forbidden character", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com/{@}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 23}},
						Raw:      "https://example.com/{@}",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
							&ast.UnknownNode{
								NodeBase: ast.NodeBase{
									NodeSpan{21, 22},
									&sourcecode.ParsingError{UnspecifiedParsingError, PATH_INTERP_EXPLANATION},
									false,
								},
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("path interpolation with a forbidden character followed by a path slice", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com/{@}/`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 24}},
						Raw:      "https://example.com/{@}/",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
							&ast.UnknownNode{
								NodeBase: ast.NodeBase{
									NodeSpan{21, 22},
									&sourcecode.ParsingError{UnspecifiedParsingError, PATH_INTERP_EXPLANATION},
									false,
								},
							},
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{23, 24}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{},
					},
				},
			}, n)
		})

		t.Run("trailing query interpolation", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com/?v={$x}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 27}},
						Raw:      "https://example.com/?v={$x}",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{NodeSpan{21, 27}, nil, false},
								Name:     "v",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{NodeSpan{23, 23}, nil, false},
										Value:    "",
									},
									&ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{24, 26}, nil, false},
										Name:     "x",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("trailing query interpolation, no path", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com?v={$x}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 26}},
						Raw:      "https://example.com?v={$x}",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{},
						QueryParams: []ast.Node{
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{NodeSpan{20, 26}, nil, false},
								Name:     "v",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{NodeSpan{22, 22}, nil, false},
										Value:    "",
									},
									&ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{23, 25}, nil, false},
										Name:     "x",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("query interpolation followed by ampersand", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com/?v={$x}&`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 28}},
						Raw:      "https://example.com/?v={$x}&",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{NodeSpan{21, 27}, nil, false},
								Name:     "v",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{NodeSpan{23, 23}, nil, false},
										Value:    "",
									},
									&ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{24, 26}, nil, false},
										Name:     "x",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("query interpolation followed by two ampersands", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com/?v={$x}&&`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 29}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 29}},
						Raw:      "https://example.com/?v={$x}&&",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{NodeSpan{21, 27}, nil, false},
								Name:     "v",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{NodeSpan{23, 23}, nil, false},
										Value:    "",
									},
									&ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{24, 26}, nil, false},
										Name:     "x",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("query interpolation followed by parameter with empty name", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com/?v={$x}&=3`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 30}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 30}},
						Raw:      "https://example.com/?v={$x}&=3",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{NodeSpan{21, 27}, nil, false},
								Name:     "v",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{NodeSpan{23, 23}, nil, false},
										Value:    "",
									},
									&ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{24, 26}, nil, false},
										Name:     "x",
									},
								},
							},
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{NodeSpan{28, 30}, nil, false},
								Name:     "",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{NodeSpan{29, 30}, nil, false},
										Value:    "3",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("two query interpolations", func(t *testing.T) {
			n := mustparseChunk(t, `https://example.com/?v={$x}&w={$y}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 34}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 34}},
						Raw:      "https://example.com/?v={$x}&w={$y}",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{NodeSpan{21, 27}, nil, false},
								Name:     "v",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{NodeSpan{23, 23}, nil, false},
										Value:    "",
									},
									&ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{24, 26}, nil, false},
										Name:     "x",
									},
								},
							},
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{NodeSpan{28, 34}, nil, false},
								Name:     "w",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{NodeSpan{30, 30}, nil, false},
										Value:    "",
									},
									&ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{31, 33}, nil, false},
										Name:     "y",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated query interpolation: missing value after '{'", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com/?v={`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 24},
							nil,
							false,
						},
						Raw: "https://example.com/?v={",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{Span: NodeSpan{21, 24}},
								Name:     "v",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{Span: NodeSpan{23, 23}},
										Value:    "",
									},
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{
											NodeSpan{24, 24},
											&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_QUERY_PARAM_INTERP},
											false,
										},
										Value: "",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated query interpolation: missing '}'", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com/?v={1`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 25},
							nil,
							false,
						},
						Raw: "https://example.com/?v={1",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{Span: NodeSpan{21, 25}},
								Name:     "v",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{Span: NodeSpan{23, 23}},
										Value:    "",
									},
									&ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{24, 25}, nil, false},
										Value:    1,
										Raw:      "1",
									},
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{
											NodeSpan{25, 25},
											&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_QUERY_PARAM_INTERP_MISSING_CLOSING_BRACE},
											false,
										},
										Value: "",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("empty query interpolation", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com/?v={}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 25}},
						Raw:      "https://example.com/?v={}",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{Span: NodeSpan{21, 25}},
								Name:     "v",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{Span: NodeSpan{23, 23}},
										Value:    "",
									},
									&ast.UnknownNode{
										NodeBase: ast.NodeBase{
											NodeSpan{24, 24},
											&sourcecode.ParsingError{UnspecifiedParsingError, EMPTY_QUERY_PARAM_INTERP},
											false,
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("invalid query interpolation", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com/?v={:}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 26}},
						Raw:      "https://example.com/?v={:}",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{NodeSpan{21, 26}, nil, false},
								Name:     "v",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{Span: NodeSpan{23, 23}},
										Value:    "",
									},
									&ast.UnknownNode{
										NodeBase: ast.NodeBase{
											NodeSpan{24, 25},
											&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_QUERY_PARAM_INTERP},
											false,
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("invalid query interpolation followed by a query parameter", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com/?v={:}&w=3`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 30}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 30}},
						Raw:      "https://example.com/?v={:}&w=3",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{NodeSpan{21, 26}, nil, false},
								Name:     "v",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{Span: NodeSpan{23, 23}},
										Value:    "",
									},
									&ast.UnknownNode{
										NodeBase: ast.NodeBase{
											NodeSpan{24, 25},
											&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_QUERY_PARAM_INTERP},
											false,
										},
									},
								},
							},
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{NodeSpan{27, 30}, nil, false},
								Name:     "w",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{NodeSpan{29, 30}, nil, false},
										Value:    "3",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("query interpolation with a forbidden character", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com/?v={?}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 26}},
						Raw:      "https://example.com/?v={?}",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{NodeSpan{21, 26}, nil, false},
								Name:     "v",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{Span: NodeSpan{23, 23}},
										Value:    "",
									},
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{
											NodeSpan{24, 25},
											&sourcecode.ParsingError{UnspecifiedParsingError, QUERY_PARAM_INTERP_EXPLANATION},
											false,
										},
										Value: "?",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("query interpolation with a forbidden character followed by a query parameter", func(t *testing.T) {
			n, err := parseChunk(t, `https://example.com/?v={?}&w=3`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 30}, nil, false},
				Statements: []ast.Node{
					&ast.URLExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 30}},
						Raw:      "https://example.com/?v={?}&w=3",
						HostPart: &ast.HostLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
							Value:    "https://example.com",
						},
						Path: []ast.Node{
							&ast.PathSlice{
								NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
								Value:    "/",
							},
						},
						QueryParams: []ast.Node{
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{NodeSpan{21, 26}, nil, false},
								Name:     "v",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{Span: NodeSpan{23, 23}},
										Value:    "",
									},
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{
											NodeSpan{24, 25},
											&sourcecode.ParsingError{UnspecifiedParsingError, QUERY_PARAM_INTERP_EXPLANATION},
											false,
										},
										Value: "?",
									},
								},
							},
							&ast.URLQueryParameter{
								NodeBase: ast.NodeBase{NodeSpan{27, 30}, nil, false},
								Name:     "w",
								Value: []ast.Node{
									&ast.URLQueryParameterValueSlice{
										NodeBase: ast.NodeBase{NodeSpan{29, 30}, nil, false},
										Value:    "3",
									},
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("integer literal", func(t *testing.T) {
		t.Run("decimal", func(t *testing.T) {
			n := mustparseChunk(t, "12")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
						Raw:      "12",
						Value:    12,
					},
				},
			}, n)
		})

		t.Run("hexadecimal", func(t *testing.T) {
			n := mustparseChunk(t, "0x33")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Raw:      "0x33",
						Value:    0x33,
					},
				},
			}, n)
		})

		t.Run("octal", func(t *testing.T) {
			n := mustparseChunk(t, "0o33")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Raw:      "0o33",
						Value:    0o33,
					},
				},
			}, n)
		})

		t.Run("negative", func(t *testing.T) {
			n := mustparseChunk(t, "-0")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
						Raw:      "-0",
						Value:    -0,
					},
				},
			}, n)
		})

		t.Run("minimum", func(t *testing.T) {
			n := mustparseChunk(t, "-9223372036854775808")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
						Raw:      "-9223372036854775808",
						Value:    -9223372036854775808,
					},
				},
			}, n)
		})
	})

	t.Run("float literal", func(t *testing.T) {
		t.Run("float literal", func(t *testing.T) {
			n := mustparseChunk(t, "12.0")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.FloatLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Raw:      "12.0",
						Value:    12.0,
					},
				},
			}, n)
		})

		t.Run("underscore in whole part", func(t *testing.T) {
			n := mustparseChunk(t, "1_000.0")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.FloatLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Raw:      "1_000.0",
						Value:    1_000.0,
					},
				},
			}, n)
		})

		t.Run("underscore in fractionam part", func(t *testing.T) {
			n := mustparseChunk(t, "1.000_000")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.FloatLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
						Raw:      "1.000_000",
						Value:    1.0,
					},
				},
			}, n)
		})

		t.Run("positive exponent", func(t *testing.T) {
			n := mustparseChunk(t, "12.0e2")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.FloatLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Raw:      "12.0e2",
						Value:    1200.0,
					},
				},
			}, n)
		})

		t.Run("negative exponent", func(t *testing.T) {
			n := mustparseChunk(t, "12.0e-2")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.FloatLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Raw:      "12.0e-2",
						Value:    0.12,
					},
				},
			}, n)
		})
	})

	t.Run("quantity literal", func(t *testing.T) {
		t.Run("non zero integer", func(t *testing.T) {
			n := mustparseChunk(t, "1s")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.QuantityLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
						Raw:      "1s",
						Units:    []string{"s"},
						Values:   []float64{1.0},
					},
				},
			}, n)
		})

		t.Run("zero integer", func(t *testing.T) {
			n := mustparseChunk(t, "0s")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.QuantityLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
						Raw:      "0s",
						Units:    []string{"s"},
						Values:   []float64{0},
					},
				},
			}, n)
		})

		t.Run("hexadecimal integer", func(t *testing.T) {
			n, err := parseChunk(t, "0x3s", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.QuantityLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							&sourcecode.ParsingError{UnspecifiedParsingError, QUANTITY_LIT_NOT_ALLOWED_WITH_HEXADECIMAL_NUM},
							false,
						},
						Raw:    "0x3s",
						Units:  []string{"s"},
						Values: []float64{3},
					},
				},
			}, n)
		})

		t.Run("octal integer", func(t *testing.T) {
			n, err := parseChunk(t, "0o3s", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.QuantityLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							&sourcecode.ParsingError{UnspecifiedParsingError, QUANTITY_LIT_NOT_ALLOWED_WITH_OCTAL_NUM},
							false,
						},
						Raw:    "0o3s",
						Units:  []string{"s"},
						Values: []float64{3},
					},
				},
			}, n)
		})

		t.Run("non-zero float", func(t *testing.T) {
			n := mustparseChunk(t, "1.5s")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.QuantityLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Raw:      "1.5s",
						Units:    []string{"s"},
						Values:   []float64{1.5},
					},
				},
			}, n)
		})

		t.Run("zero float", func(t *testing.T) {
			n := mustparseChunk(t, "0.0s")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.QuantityLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Raw:      "0.0s",
						Units:    []string{"s"},
						Values:   []float64{0},
					},
				},
			}, n)
		})

		t.Run("multiplier", func(t *testing.T) {
			n := mustparseChunk(t, "1ks")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.QuantityLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
						Raw:      "1ks",
						Units:    []string{"ks"},
						Values:   []float64{1.0},
					},
				},
			}, n)
		})

		t.Run("multiple parts", func(t *testing.T) {
			n := mustparseChunk(t, "1s10ms")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.QuantityLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Raw:      "1s10ms",
						Units:    []string{"s", "ms"},
						Values:   []float64{1.0, 10},
					},
				},
			}, n)
		})
	})

	t.Run("date-like literals", func(t *testing.T) {
		t.Run("year literal", func(t *testing.T) {
			n := mustparseChunk(t, "2020y-UTC")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.YearLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
						Raw:      "2020y-UTC",
						Value:    time.Date(2020, 1, 1, 0, 0, 0, 0, time.UTC),
					},
				},
			}, n)
		})

		t.Run("year literal: missing location after dash", func(t *testing.T) {
			n, err := parseChunk(t, "2020y-", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.YearLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DATELIKE_LITERAL_MISSING_LOCATION_PART_AT_THE_END},
							false,
						},
						Raw: "2020y-",
					},
				},
			}, n)
		})

		t.Run("year literal: parenthesized, missing location after dash", func(t *testing.T) {
			n, err := parseChunk(t, "(2020y-)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.YearLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 7},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DATELIKE_LITERAL_MISSING_LOCATION_PART_AT_THE_END},
							true,
						},
						Raw: "2020y-",
					},
				},
				// Tokens: []ast.Token{
				// 	{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{0, 1}},
				// 	{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{7, 8}},
				// },
			}, n)
		})

		t.Run("date: missing day", func(t *testing.T) {
			n, err := parseChunk(t, "2020y-5mt-UTC", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.DateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DATE_LITERAL_DAY_COUNT_PROBABLY_MISSING},
							false,
						},
						Raw: "2020y-5mt-UTC",
					},
				},
			}, n)
		})

		t.Run("date: invalid day: 0", func(t *testing.T) {
			n, err := parseChunk(t, "2020y-1mt-0d-UTC", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.DateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 16},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DAY_VALUE},
							false,
						},
						Raw: "2020y-1mt-0d-UTC",
					},
				},
			}, n)
		})

		t.Run("date: day 05", func(t *testing.T) {
			n := mustparseChunk(t, "2020y-1mt-05d-UTC")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.DateLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
						Raw:      "2020y-1mt-05d-UTC",
						Value:    time.Date(2020, 1, 5, 0, 0, 0, 0, time.UTC),
					},
				},
			}, n)
		})

		t.Run("date: missing month", func(t *testing.T) {
			n, err := parseChunk(t, "2020y-5d-UTC", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.DateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DATE_LITERAL_MONTH_COUNT_PROBABLY_MISSING},
							false,
						},
						Raw: "2020y-5d-UTC",
					},
				},
			}, n)
		})

		t.Run("date: invalid month value: 0", func(t *testing.T) {
			n, err := parseChunk(t, "2020y-0mt-1d-UTC", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.DateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 16},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_MONTH_VALUE},
							false,
						},
						Raw: "2020y-0mt-1d-UTC",
					},
				},
			}, n)
		})

		t.Run("date: month 05", func(t *testing.T) {
			n := mustparseChunk(t, "2020y-05mt-1d-UTC")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.DateLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
						Raw:      "2020y-05mt-1d-UTC",
						Value:    time.Date(2020, 5, 1, 0, 0, 0, 0, time.UTC),
					},
				},
			}, n)
		})

		t.Run("date: missing location part", func(t *testing.T) {
			n, err := parseChunk(t, "2020y-5mt-1d", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.DateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DATELIKE_LITERAL_MISSING_LOCATION_PART_AT_THE_END},
							false,
						},
						Raw: "2020y-5mt-1d",
					},
				},
			}, n)
		})

		t.Run("datetime: microseconds", func(t *testing.T) {
			n := mustparseChunk(t, "2020y-1mt-1d-5us-UTC")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.DateTimeLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
						Raw:      "2020y-1mt-1d-5us-UTC",
						Value:    time.Date(2020, 1, 1, 0, 0, 0, 5_000, time.UTC),
					},
				},
			}, n)
		})

		t.Run("datetime: up to minutes", func(t *testing.T) {
			n := mustparseChunk(t, "2020y-10mt-5d-5h-4m-UTC")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.DateTimeLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
						Raw:      "2020y-10mt-5d-5h-4m-UTC",
						Value:    time.Date(2020, 10, 5, 5, 4, 0, 0, time.UTC),
					},
				},
			}, n)
		})

		t.Run("datetime: up to microseconds", func(t *testing.T) {
			n := mustparseChunk(t, "2020y-10mt-5d-5h-4m-5s-400ms-100us-UTC")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 38}, nil, false},
				Statements: []ast.Node{
					&ast.DateTimeLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 38}, nil, false},
						Raw:      "2020y-10mt-5d-5h-4m-5s-400ms-100us-UTC",
						Value:    time.Date(2020, 10, 5, 5, 4, 5, 400_000_000+100_000, time.UTC),
					},
				},
			}, n)
		})

		t.Run("datetime: up to microseconds (longer)", func(t *testing.T) {
			n := mustparseChunk(t, "2020y-6mt-12d-18h-4m-4s-349ms-665us-Local")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 41}, nil, false},
				Statements: []ast.Node{
					&ast.DateTimeLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 41}, nil, false},
						Raw:      "2020y-6mt-12d-18h-4m-4s-349ms-665us-Local",
						Value:    time.Date(2020, 6, 12, 18, 4, 4, (349*1_000_000)+(665*1000), time.Local),
					},
				},
			}, n)
		})

		t.Run("datetime: up to microseconds (long location)", func(t *testing.T) {
			n := mustparseChunk(t, "2020y-6mt-12d-18h-4m-4s-349ms-665us-America/Los_Angeles")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 55}, nil, false},
				Statements: []ast.Node{
					&ast.DateTimeLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 55}, nil, false},
						Raw:      "2020y-6mt-12d-18h-4m-4s-349ms-665us-America/Los_Angeles",
						Value:    time.Date(2020, 6, 12, 18, 4, 4, (349*1_000_000)+(665*1000), utils.Must(time.LoadLocation("America/Los_Angeles"))),
					},
				},
			}, n)
		})

	})

	t.Run("rate literal", func(t *testing.T) {
		t.Run("rate literal", func(t *testing.T) {
			n := mustparseChunk(t, "1kB/s")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.RateLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Units:    []string{"kB"},
						Values:   []float64{1.0},
						DivUnit:  "s",
						Raw:      "1kB/s",
					},
				},
			}, n)

			t.Run("missing unit after '/'", func(t *testing.T) {
				n, err := parseChunk(t, "1kB/", "")
				assert.Error(t, err)
				assert.EqualValues(t, &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
					Statements: []ast.Node{
						&ast.RateLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 4},
								&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_RATE_LIT_DIV_SYMBOL_SHOULD_BE_FOLLOWED_BY_UNIT},
								false,
							},
							Units:  []string{"kB"},
							Values: []float64{1.0},
							Raw:    "1kB/",
						},
					},
				}, n)
			})

			t.Run("invalid unit after '/'", func(t *testing.T) {
				n, err := parseChunk(t, "1kB/1", "")
				assert.Error(t, err)
				assert.EqualValues(t, &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
					Statements: []ast.Node{
						&ast.RateLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 4},
								&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_RATE_LIT},
								false,
							},
							Units:  []string{"kB"},
							Values: []float64{1.0},
							Raw:    "1kB/",
						},
						&ast.IntLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{4, 5},
								&sourcecode.ParsingError{UnspecifiedParsingError, STMTS_SHOULD_BE_SEPARATED_BY},
								false,
							},
							Raw:   "1",
							Value: 1,
						},
					},
				}, n)
			})

			t.Run("invalid unit after '/'", func(t *testing.T) {
				n, err := parseChunk(t, "1kB/a1", "")
				assert.Error(t, err)
				assert.EqualValues(t, &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Statements: []ast.Node{
						&ast.RateLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 5},
								&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_RATE_LIT},
								false,
							},
							Units:   []string{"kB"},
							Values:  []float64{1.0},
							DivUnit: "a",
							Raw:     "1kB/a",
						},
						&ast.IntLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{5, 6},
								&sourcecode.ParsingError{UnspecifiedParsingError, STMTS_SHOULD_BE_SEPARATED_BY},
								false,
							},
							Raw:   "1",
							Value: 1,
						},
					},
				}, n)
			})
		})

		t.Run("unterminated rate literal", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, "1kB/")
			})
		})
	})

	t.Run("string literal", func(t *testing.T) {

		testCases := map[string]struct {
			result ast.Node
			error  bool
		}{
			`""`: {
				result: &ast.DoubleQuotedStringLiteral{
					NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
					Raw:      `""`,
					Value:    ``,
				},
			},

			`" "`: {
				result: &ast.DoubleQuotedStringLiteral{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Raw:      `" "`,
					Value:    ` `,
				},
			},

			`"é"`: {
				result: &ast.DoubleQuotedStringLiteral{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Raw:      `"é"`,
					Value:    `é`,
				},
			},

			`"\\"`: {
				result: &ast.DoubleQuotedStringLiteral{
					NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
					Raw:      `"\\"`,
					Value:    `\`,
				},
			},

			`"\\\\"`: {
				result: &ast.DoubleQuotedStringLiteral{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Raw:      `"\\\\"`,
					Value:    `\\`,
				},
			},

			`"\u0061"`: {
				result: &ast.DoubleQuotedStringLiteral{
					NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
					Raw:      `"\u0061"`,
					Value:    `a`,
				},
			},

			`"ab`: {
				result: &ast.DoubleQuotedStringLiteral{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 3},
						&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_QUOTED_STRING_LIT},
						false,
					},
					Raw:            `"ab`,
					Value:          ``,
					IsUnterminated: true,
				},
				error: true,
			},
			"\"ab\n1": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 5},
						nil,
						false,
					},
					Statements: []ast.Node{
						&ast.DoubleQuotedStringLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 3},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_QUOTED_STRING_LIT},
								false,
							},
							Raw:            `"ab`,
							Value:          ``,
							IsUnterminated: true,
						},
						&ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
							Raw:      "1",
							Value:    1,
						},
					},
				},

				error: true,
			},

			`+`: {
				result: &ast.UnquotedStringLiteral{
					NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
					Raw:      `+`,
					Value:    `+`,
				},
			},

			`-`: {
				result: &ast.UnquotedStringLiteral{
					NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
					Raw:      `-`,
					Value:    `-`,
				},
			},

			`--`: {
				result: &ast.UnquotedStringLiteral{
					NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
					Raw:      `--`,
					Value:    `--`,
				},
			},

			`[--]`: {
				result: &ast.ListLiteral{
					NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
					Elements: []ast.Node{
						&ast.UnquotedStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Raw:      `--`,
							Value:    `--`,
						},
					},
				},
			},

			`+\:`: {
				result: &ast.UnquotedStringLiteral{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Raw:      `+\:`,
					Value:    `+:`,
				},
			},

			`-- 2`: {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
					Statements: []ast.Node{
						&ast.UnquotedStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Raw:      `--`,
							Value:    `--`,
						},
						&ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
							Raw:      "2",
							Value:    2,
						},
					},
				},
			},

			"``": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Raw:      "``",
							Value:    "",
						},
					},
				},
			},

			"`1`": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
							Raw:      "`1`",
							Value:    "1",
						},
					},
				},
			},
			"`\n`": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
							Raw:      "`\n`",
							Value:    "\n",
						},
					},
				},
			},
			"`\n\r\n`": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Raw:      "`\n\r\n`",
							Value:    "\n\r\n",
						},
					},
				},
			},

			"`\\n\\r\\t`": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
							Raw:      "`\\n\\r\\t`",
							Value:    "\n\r\t",
						},
					},
				},
			},
			"`\"`": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
							Raw:      "`\"`",
							Value:    "\"",
						},
					},
				},
			},
			"`\"a\"`": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Raw:      "`\"a\"`",
							Value:    "\"a\"",
						},
					},
				},
			},
			"`\\u0061`": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
							Raw:      "`\\u0061`",
							Value:    "a",
						},
					},
				},
			},
			"`\\``": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Raw:      "`\\``",
							Value:    "`",
						},
					},
				},
			},
			"`\\\\\\``": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
							Raw:      "`\\\\\\``",
							Value:    "\\`",
						},
					},
				},
			},
			"`\\`\\``": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
							Raw:      "`\\`\\``",
							Value:    "``",
						},
					},
				},
			},
			"`\\\\`": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Raw:      "`\\\\`",
							Value:    "\\",
						},
					},
				},
			},
			"`\\`e`": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Raw:      "`\\`e`",
							Value:    "`e",
						},
					},
				},
			},
			"`e\\``": {
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Raw:      "`e\\``",
							Value:    "e`",
						},
					},
				},
			},
			//unterminated multiline string literals
			"`": {
				error: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 1},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_MULTILINE_STRING_LIT},
								false,
							},
							Raw:            "`",
							Value:          "",
							IsUnterminated: true,
						},
					},
				},
			},
			"`\n": {
				error: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 2},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_MULTILINE_STRING_LIT},
								false,
							},
							Raw:            "`\n",
							Value:          "",
							IsUnterminated: true,
						},
					},
				},
			},
			"`a": {
				error: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
					Statements: []ast.Node{
						&ast.MultilineStringLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 2},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_MULTILINE_STRING_LIT},
								false,
							},
							Raw:            "`a",
							Value:          "",
							IsUnterminated: true,
						},
					},
				},
			},
		}

		for input, testCase := range testCases {
			t.Run(input, func(t *testing.T) {
				n, err := parseChunk(t, input, "")

				if !testCase.error {
					if !assert.NoError(t, err) {
						return
					}
				} else {
					assert.Error(t, err)
				}

				if _, ok := testCase.result.(*ast.Chunk); ok {
					assert.Equal(t, testCase.result, n)
				} else {
					assert.Equal(t, &ast.Chunk{
						NodeBase:   ast.NodeBase{NodeSpan{0, testCase.result.Base().Span.End}, nil, false},
						Statements: []ast.Node{testCase.result},
					}, n)
				}
			})
		}

	})

	t.Run("byte slice literal", func(t *testing.T) {
		testCases := []struct {
			input string
			value []byte
			err   string
		}{
			//hexadecimal
			{
				"0x[]",
				[]byte{},
				"",
			},
			{
				"0x[1]",
				[]byte{},
				INVALID_HEX_BYTE_SICE_LIT_LENGTH_SHOULD_BE_EVEN,
			},
			{
				"0x[12]",
				[]byte{0x12},
				"",
			},
			{
				"0x[12 12]",
				[]byte{0x12, 0x12},
				"",
			},
			{
				"0x[121 2]",
				[]byte{0x12, 0x12},
				"",
			},
			{
				"0x[1 212]",
				[]byte{0x12, 0x12},
				"",
			},
			{
				"(0x[12)",
				[]byte{0x12},
				UNTERMINATED_BYTE_SICE_LIT_MISSING_CLOSING_BRACKET,
			},

			//binary
			{
				"0b[]",
				[]byte{},
				"",
			},
			{
				"0b[1]",
				[]byte{1},
				"",
			},
			{
				"0b[0]",
				[]byte{0},
				"",
			},
			{
				"0b[01]",
				[]byte{0b1},
				"",
			},
			{
				"0b[10]",
				[]byte{0b10},
				"",
			},
			{
				"0b[1000 0000]",
				[]byte{0b1000_0000},
				"",
			},
			{
				"0b[0000 0000]",
				[]byte{0b0000_0000},
				"",
			},
			{
				"0b[1000 0000 1]",
				[]byte{0b1000_0000, 1},
				"",
			},
			{
				"0b[0000 0000 1]",
				[]byte{0b0000_0000, 1},
				"",
			},
			{
				"0b[0000 0000 0000 0000]",
				[]byte{0b0000_0000, 0b0000_0000},
				"",
			},
			{
				"(0b[1)",
				[]byte{0x1},
				UNTERMINATED_BYTE_SICE_LIT_MISSING_CLOSING_BRACKET,
			},

			//decimal
			{
				"0d[]",
				[]byte{},
				"",
			},
			{
				"0d[1]",
				[]byte{1},
				"",
			},
			{
				"0d[12]",
				[]byte{12},
				"",
			},
			{
				"0d[12 12]",
				[]byte{12, 12},
				"",
			},
			{
				"0d[121 2]",
				[]byte{121, 2},
				"",
			},
			{
				"0d[1 212]",
				[]byte{1, 212},
				"",
			},
			{
				"0d[1 256]",
				nil,
				fmtInvalidByteInDecimalByteSliceLiteral([]byte("256")),
			},
			{
				"(0d[1)",
				[]byte{0x1},
				UNTERMINATED_BYTE_SICE_LIT_MISSING_CLOSING_BRACKET,
			},
		}

		for _, testCase := range testCases {
			t.Run(testCase.input, func(t *testing.T) {
				n, err := parseChunk(t, testCase.input, "")
				assert.IsType(t, &ast.ByteSliceLiteral{}, n.Statements[0])

				literal := n.Statements[0].(*ast.ByteSliceLiteral)

				if testCase.err == "" {
					assert.NoError(t, err)
					assert.Equal(t, testCase.value, literal.Value)
				} else {
					assert.Contains(t, literal.Err.Message, testCase.err)
				}
			})
		}
	})

	t.Run("rune literal", func(t *testing.T) {

		t.Run("rune literal : simple character", func(t *testing.T) {
			n := mustparseChunk(t, `'a'`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.RuneLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
						Value:    'a',
					},
				},
			}, n)
		})

		t.Run("rune literal : valid escaped character", func(t *testing.T) {
			n := mustparseChunk(t, `'\n'`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.RuneLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Value:    '\n',
					},
				},
			}, n)
		})

		t.Run("rune literal : invalid escaped character", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, `'\z'`)
			})
		})

		t.Run("rune literal : missing character", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, `''`)
			})
		})

	})

	t.Run("single letter", func(t *testing.T) {
		t.Run("single letter", func(t *testing.T) {
			n := mustparseChunk(t, `e`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},

				Statements: []ast.Node{
					&ast.IdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
						Name:     "e",
					},
				},
			}, n)
		})

		t.Run("letter followed by a digit", func(t *testing.T) {
			n := mustparseChunk(t, `e2`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.IdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
						Name:     "e2",
					},
				},
			}, n)
		})

		t.Run("empty unambiguous identifier", func(t *testing.T) {
			n, err := parseChunk(t, `#`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},

				Statements: []ast.Node{
					&ast.UnambiguousIdentifierLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 1},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_IDENTIFIER_LIT},
							false,
						},
						Name: "",
					},
				},
			}, n)
		})

		t.Run("single letter unambiguous identifier", func(t *testing.T) {
			n := mustparseChunk(t, `#e`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},

				Statements: []ast.Node{
					&ast.UnambiguousIdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
						Name:     "e",
					},
				},
			}, n)
		})

		t.Run("unambiguous identifier literal : letter followed by a digit", func(t *testing.T) {
			n := mustparseChunk(t, `#e2`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.UnambiguousIdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
						Name:     "e2",
					},
				},
			}, n)
		})

	})

	t.Run("assignment", func(t *testing.T) {
		t.Run("var = <value>", func(t *testing.T) {
			n := mustparseChunk(t, "$a = $b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							nil,
							false,
						},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{5, 7}, nil, false},
							Name:     "b",
						},
						Operator: ast.Assign,
					},
				},
			}, n)
		})

		t.Run("var += <value>", func(t *testing.T) {
			n := mustparseChunk(t, "$a += $b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 8},
							nil,
							false,
						},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
							Name:     "b",
						},
						Operator: ast.PlusAssign,
					},
				},
			}, n)
		})

		t.Run("identifier = <value>", func(t *testing.T) {
			n := mustparseChunk(t, "a = $b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							nil,
							false,
						},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
							Name:     "b",
						},
						Operator: ast.Assign,
					},
				},
			}, n)
		})

		t.Run("keyword = <value>", func(t *testing.T) {
			res, err := parseChunk(t, "const ()\nmanifest {}\nmanifest = $b", "")
			assert.Error(t, err)
			assert.NotNil(t, res)
			assert.ErrorContains(t, err, KEYWORDS_SHOULD_NOT_BE_USED_IN_ASSIGNMENT_LHS)
		})

		t.Run("<index expr> = <value>", func(t *testing.T) {
			n := mustparseChunk(t, "$a[0] = $b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 10},
							nil,
							false,
						},
						Left: &ast.IndexExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Indexed: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
								Name:     "a",
							},
							Index: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Raw:      "0",
								Value:    0,
							},
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{8, 10}, nil, false},
							Name:     "b",
						},
						Operator: ast.Assign,
					},
				},
			}, n)
		})

		t.Run("<identifier member expr> = <value>", func(t *testing.T) {
			n := mustparseChunk(t, "a.b = $b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 8},
							nil,
							false,
						},
						Left: &ast.IdentifierMemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
							PropertyNames: []*ast.IdentifierLiteral{
								{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Name:     "b",
								},
							},
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
							Name:     "b",
						},
						Operator: ast.Assign,
					},
				},
			}, n)
		})

		t.Run("missing terminator", func(t *testing.T) {
			n, err := parseChunk(t, "$a = $b 2", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							&sourcecode.ParsingError{InvalidNext, UNTERMINATED_ASSIGNMENT_MISSING_TERMINATOR},
							false,
						},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{5, 7}, nil, false},
							Name:     "b",
						},
						Operator: ast.Assign,
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
						Raw:      "2",
						Value:    2,
					},
				},
			}, n)
		})

		t.Run("missing RHS: '=' followed by EOF", func(t *testing.T) {
			n, err := parseChunk(t, "$a =", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_ASSIGNMENT_MISSING_VALUE_AFTER_EQL_SIGN},
							false,
						},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						Operator: ast.Assign,
					},
				},
			}, n)
		})

		t.Run("missing RHS: '=' followed by space + EOF", func(t *testing.T) {
			n, err := parseChunk(t, "$a = ", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 5},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_ASSIGNMENT_MISSING_VALUE_AFTER_EQL_SIGN},
							false,
						},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						Operator: ast.Assign,
					},
				},
			}, n)
		})

		t.Run("missing RHS: '=' followed by linefeed", func(t *testing.T) {
			n, err := parseChunk(t, "$a =\n", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_ASSIGNMENT_MISSING_VALUE_AFTER_EQL_SIGN},
							false,
						},
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						Operator: ast.Assign,
					},
				},
			}, n)
		})
	})

	t.Run("multi assignement statement", func(t *testing.T) {
		t.Run("assign <ident> = <var>", func(t *testing.T) {
			n := mustparseChunk(t, "assign a = $b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.MultiAssignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.ASSIGN_KEYWORD, Span: NodeSpan{0, 6}},
								{Type: ast.EQUAL, Span: NodeSpan{9, 10}},
							},*/
						},
						Variables: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Name:     "a",
							},
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{11, 13}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("assign var var = var", func(t *testing.T) {
			n := mustparseChunk(t, "assign a b = $c")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.MultiAssignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 15},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.ASSIGN_KEYWORD, Span: NodeSpan{0, 6}},
								{Type: ast.EQUAL, Span: NodeSpan{11, 12}},
							},*/
						},
						Variables: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Name:     "a",
							},
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
								Name:     "b",
							},
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{13, 15}, nil, false},
							Name:     "c",
						},
					},
				},
			}, n)
		})

		t.Run("nillable", func(t *testing.T) {
			n := mustparseChunk(t, "assign? a = $b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.MultiAssignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 14},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.ASSIGN_KEYWORD, Span: NodeSpan{0, 6}},
								{Type: ast.QUESTION_MARK, Span: NodeSpan{6, 7}},
								{Type: ast.EQUAL, Span: NodeSpan{10, 11}},
							},*/
						},
						Variables: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Name:     "a",
							},
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{12, 14}, nil, false},
							Name:     "b",
						},
						Nillable: true,
					},
				},
			}, n)
		})

		t.Run("keyword LHS", func(t *testing.T) {
			res, err := parseChunk(t, "const ()\nmanifest {}\nassign manifest = $b", "")
			assert.Error(t, err)
			assert.NotNil(t, res)
			assert.ErrorContains(t, err, KEYWORDS_SHOULD_NOT_BE_USED_IN_ASSIGNMENT_LHS)
		})

		t.Run("missing terminator", func(t *testing.T) {
			n, err := parseChunk(t, "assign a = $b 2", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.MultiAssignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							&sourcecode.ParsingError{InvalidNext, UNTERMINATED_ASSIGNMENT_MISSING_TERMINATOR},
							false,
							/*[]ast.Token{
								{Type: ast.ASSIGN_KEYWORD, Span: NodeSpan{0, 6}},
								{Type: ast.EQUAL, Span: NodeSpan{9, 10}},
							},*/
						},
						Variables: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Name:     "a",
							},
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{11, 13}, nil, false},
							Name:     "b",
						},
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
						Raw:      "2",
						Value:    2,
					},
				},
			}, n)
		})

		t.Run("only LHS", func(t *testing.T) {
			n, err := parseChunk(t, "assign a", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.MultiAssignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 8},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_MULTI_ASSIGN_MISSING_EQL_SIGN},
							false,
						},
						Variables: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Name:     "a",
							},
						},
					},
				},
			}, n)
		})

		t.Run("missing value after equal sign", func(t *testing.T) {
			n, err := parseChunk(t, "assign a =", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.MultiAssignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 10},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.ASSIGN_KEYWORD, Span: NodeSpan{0, 6}},
								{Type: ast.EQUAL, Span: NodeSpan{9, 10}},
							},*/
						},
						Variables: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Name:     "a",
							},
						},
						Right: &ast.MissingExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 10},
								&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("assign a ="), 10, true)},
								false,
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("call with parenthesis", func(t *testing.T) {
		t.Run("no args", func(t *testing.T) {
			n := mustparseChunk(t, "print()")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "print",
						},
						Arguments: nil,
					},
				},
			}, n)
		})

		t.Run("no args 2", func(t *testing.T) {
			n := mustparseChunk(t, "print( )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "print",
						},
						Arguments: nil,
					},
				},
			}, n)
		})

		t.Run("exclamation mark", func(t *testing.T) {
			n := mustparseChunk(t, "print!()")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "print",
						},
						Arguments: nil,
						Must:      true,
					},
				},
			}, n)
		})

		t.Run("single arg", func(t *testing.T) {
			n := mustparseChunk(t, "print($a)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "print",
						},
						Arguments: []ast.Node{
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
								Name:     "a",
							},
						},
					},
				},
			}, n)
		})

		t.Run("two args", func(t *testing.T) {
			n := mustparseChunk(t, "print($a $b)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "print",
						},
						Arguments: []ast.Node{
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
								Name:     "a",
							},
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{9, 11}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("single arg: spread argument", func(t *testing.T) {
			n := mustparseChunk(t, "print(...$a)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "print",
						},
						Arguments: []ast.Node{
							&ast.SpreadArgument{
								NodeBase: ast.NodeBase{
									NodeSpan{6, 11},
									nil,
									false,
								},
								Expr: &ast.Variable{
									NodeBase: ast.NodeBase{NodeSpan{9, 11}, nil, false},
									Name:     "a",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unexpected char", func(t *testing.T) {
			n, err := parseChunk(t, "print(?1)", "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "print",
						},
						Arguments: []ast.Node{
							&ast.UnknownNode{
								NodeBase: ast.NodeBase{
									NodeSpan{6, 7},
									&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInCallArguments('?')},
									false,
								},
							},
							&ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Raw:      "1",
								Value:    1,
							},
						},
					},
				},
			}, n)
		})

		t.Run("callee is an identifier member expression", func(t *testing.T) {
			n := mustparseChunk(t, "http.get()")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
						Callee: &ast.IdentifierMemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
								Name:     "http",
							},
							PropertyNames: []*ast.IdentifierLiteral{
								{
									NodeBase: ast.NodeBase{NodeSpan{5, 8}, nil, false},
									Name:     "get",
								},
							},
						},
						Arguments: nil,
					},
				},
			}, n)
		})

		t.Run("callee is a member expression", func(t *testing.T) {
			n := mustparseChunk(t, `$a.b("a")`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
						Callee: &ast.MemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
								Name:     "a",
							},
							PropertyName: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Name:     "b",
							},
						},
						Arguments: []ast.Node{
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{5, 8}, nil, false},
								Raw:      `"a"`,
								Value:    "a",
							},
						},
					},
				},
			}, n)
		})

		t.Run("callee is a meta identifier", func(t *testing.T) {
			n := mustparseChunk(t, `(@a())`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{1, 5}, IsParenthesized: true},
						Callee: &ast.MetaIdentifier{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
					},
				},
			}, n)
		})

		t.Run("double call", func(t *testing.T) {
			n := mustparseChunk(t, "print()()")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
						Callee: &ast.CallExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}},
							Callee: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
								Name:     "print",
							},
							Arguments: nil,
						},
						Arguments: nil,
					},
				},
			}, n)
		})
	})

	t.Run("command-like call", func(t *testing.T) {

		t.Run("no arg", func(t *testing.T) {
			n := mustparseChunk(t, "print;")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						Must:              true,
						CommandLikeSyntax: true,
						NodeBase:          ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "print",
						},
						Arguments: nil,
					},
				},
			}, n)
		})

		t.Run("one arg", func(t *testing.T) {
			n := mustparseChunk(t, "print $a")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						Must:              true,
						CommandLikeSyntax: true,
						NodeBase:          ast.NodeBase{NodeSpan{0, 8}, nil, false},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "print",
						},
						Arguments: []ast.Node{
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
								Name:     "a",
							},
						},
					},
				},
			}, n)
		})

		t.Run("one arg followed by a line feed", func(t *testing.T) {
			n := mustparseChunk(t, "print $a\n")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 9},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.CallExpression{
						Must:              true,
						CommandLikeSyntax: true,
						NodeBase:          ast.NodeBase{NodeSpan{0, 8}, nil, false},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "print",
						},
						Arguments: []ast.Node{
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
								Name:     "a",
							},
						},
					},
				},
			}, n)
		})

		t.Run("two args", func(t *testing.T) {
			n := mustparseChunk(t, "print $a $b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						Must:              true,
						CommandLikeSyntax: true,
						NodeBase:          ast.NodeBase{NodeSpan{0, 11}, nil, false},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "print",
						},
						Arguments: []ast.Node{
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
								Name:     "a",
							},
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{9, 11}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("single arg with a delimiter", func(t *testing.T) {
			n := mustparseChunk(t, "print []")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						Must:              true,
						CommandLikeSyntax: true,
						NodeBase:          ast.NodeBase{NodeSpan{0, 8}, nil, false},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "print",
						},
						Arguments: []ast.Node{
							&ast.ListLiteral{
								NodeBase: ast.NodeBase{
									NodeSpan{6, 8},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.OPENING_BRACKET, Span: NodeSpan{6, 7}},
										{Type: ast.CLOSING_BRACKET, Span: NodeSpan{7, 8}},
									},*/
								},
								Elements: nil,
							},
						},
					},
				},
			}, n)
		})

		t.Run("single arg starting with the same character as an assignment operator", func(t *testing.T) {
			n := mustparseChunk(t, "print /")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						Must:              true,
						CommandLikeSyntax: true,
						NodeBase:          ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "print",
						},
						Arguments: []ast.Node{
							&ast.AbsolutePathLiteral{
								NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
								Raw:      "/",
								Value:    "/",
							},
						},
					},
				},
			}, n)
		})

		t.Run("call followed by a single line comment", func(t *testing.T) {
			n := mustparseChunk(t, "print $a $b # comment")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						Must:              true,
						CommandLikeSyntax: true,
						NodeBase: ast.NodeBase{
							NodeSpan{0, 21},
							nil,
							false,
						},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Name:     "print",
						},
						Arguments: []ast.Node{
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
								Name:     "a",
							},
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{9, 11}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("callee is an identifier member expression", func(t *testing.T) {
			n := mustparseChunk(t, `a.b "a"`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						Must:              true,
						CommandLikeSyntax: true,
						NodeBase:          ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Callee: &ast.IdentifierMemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
							PropertyNames: []*ast.IdentifierLiteral{
								{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Name:     "b",
								},
							},
						},
						Arguments: []ast.Node{
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 7}, nil, false},
								Raw:      `"a"`,
								Value:    "a",
							},
						},
					},
				},
			}, n)
		})

	})

	t.Run("pipeline statement", func(t *testing.T) {
		t.Run("empty second stage", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, "print $a |")
			})
		})

		t.Run("second stage is not a call", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, "print $a | 1")
			})
		})

		t.Run("second stage is a call with no arguments", func(t *testing.T) {
			n := mustparseChunk(t, "print $a | do-something")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.PipelineStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 23},
							nil,
							false,
						},
						Stages: []*ast.PipelineStage{
							{
								Kind: ast.NormalStage,
								Expr: &ast.CallExpression{
									Must:              true,
									CommandLikeSyntax: true,
									NodeBase:          ast.NodeBase{NodeSpan{0, 9}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
										Name:     "print",
									},
									Arguments: []ast.Node{
										&ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
											Name:     "a",
										},
									},
								},
							},
							{
								Kind: ast.NormalStage,
								Expr: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{11, 23}, nil, false},
									Name:     "do-something",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("second stage is a call with no arguments, followed by a ';'", func(t *testing.T) {
			n := mustparseChunk(t, "print $a | do-something;")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 24},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.PipelineStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 23},
							nil,
							false,
						},
						Stages: []*ast.PipelineStage{
							{
								Kind: ast.NormalStage,
								Expr: &ast.CallExpression{
									Must:              true,
									CommandLikeSyntax: true,
									NodeBase:          ast.NodeBase{NodeSpan{0, 9}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
										Name:     "print",
									},
									Arguments: []ast.Node{
										&ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
											Name:     "a",
										},
									},
								},
							},
							{
								Kind: ast.NormalStage,
								Expr: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{11, 23}, nil, false},
									Name:     "do-something",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("second stage is a call with no arguments, followed by another statement on the following line", func(t *testing.T) {
			n := mustparseChunk(t, "print $a | do-something\n1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 25},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.PipelineStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 23},
							nil,
							false,
						},
						Stages: []*ast.PipelineStage{
							{
								Kind: ast.NormalStage,
								Expr: &ast.CallExpression{
									Must:              true,
									CommandLikeSyntax: true,
									NodeBase:          ast.NodeBase{NodeSpan{0, 9}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
										Name:     "print",
									},
									Arguments: []ast.Node{
										&ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
											Name:     "a",
										},
									},
								},
							},
							{
								Kind: ast.NormalStage,
								Expr: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{11, 23}, nil, false},
									Name:     "do-something",
								},
							},
						},
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{24, 25}, nil, false},
						Raw:      "1",
						Value:    1,
					},
				},
			}, n)
		})

		t.Run("first and second stages are calls with no arguments", func(t *testing.T) {
			n := mustparseChunk(t, "print | do-something")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.PipelineStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 20},
							nil,
							false,
						},
						Stages: []*ast.PipelineStage{
							{
								Kind: ast.NormalStage,
								Expr: &ast.CallExpression{
									Must:              true,
									CommandLikeSyntax: true,
									NodeBase:          ast.NodeBase{NodeSpan{0, 6}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
										Name:     "print",
									},
								},
							},
							{
								Kind: ast.NormalStage,
								Expr: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{8, 20}, nil, false},
									Name:     "do-something",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("second stage is a call with a single argument", func(t *testing.T) {
			n := mustparseChunk(t, "print $a | do-something $")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.PipelineStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 25}},
						Stages: []*ast.PipelineStage{
							{
								Kind: ast.NormalStage,
								Expr: &ast.CallExpression{
									Must:              true,
									CommandLikeSyntax: true,
									NodeBase:          ast.NodeBase{NodeSpan{0, 9}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
										Name:     "print",
									},
									Arguments: []ast.Node{
										&ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
											Name:     "a",
										},
									},
								},
							},
							{
								Kind: ast.NormalStage,
								Expr: &ast.CallExpression{
									Must:              true,
									CommandLikeSyntax: true,
									NodeBase:          ast.NodeBase{NodeSpan{11, 25}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{11, 23}, nil, false},
										Name:     "do-something",
									},
									Arguments: []ast.Node{
										&ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{24, 25}, nil, false},
											Name:     "",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("third stage is a call with no arguments", func(t *testing.T) {
			n := mustparseChunk(t, "print $a | do-something $ | do-something-else")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 45}, nil, false},
				Statements: []ast.Node{
					&ast.PipelineStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 45}},
						Stages: []*ast.PipelineStage{
							{
								Kind: ast.NormalStage,
								Expr: &ast.CallExpression{
									Must:              true,
									CommandLikeSyntax: true,
									NodeBase:          ast.NodeBase{NodeSpan{0, 9}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
										Name:     "print",
									},
									Arguments: []ast.Node{
										&ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
											Name:     "a",
										},
									},
								},
							},
							{
								Kind: ast.NormalStage,
								Expr: &ast.CallExpression{
									Must:              true,
									CommandLikeSyntax: true,
									NodeBase:          ast.NodeBase{NodeSpan{11, 25}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{11, 23}, nil, false},
										Name:     "do-something",
									},
									Arguments: []ast.Node{
										&ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{24, 25}, nil, false},
											Name:     "",
										},
									},
								},
							},
							{
								Kind: ast.NormalStage,
								Expr: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{28, 45}, nil, false},
									Name:     "do-something-else",
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("pipeline expression", func(t *testing.T) {
		t.Run("empty second stage", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, "($a |)")
			})
		})

		t.Run("second stage is not a call", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, "($a | 1)")
			})
		})

		t.Run("second stage is a call with no arguments", func(t *testing.T) {
			n := mustparseChunk(t, "(print($a) | do-something)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
				Statements: []ast.Node{
					&ast.PipelineExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 26}, IsParenthesized: true},
						Stages: []*ast.PipelineStage{
							{
								Kind: ast.NormalStage,
								Expr: &ast.CallExpression{
									NodeBase: ast.NodeBase{NodeSpan{1, 10}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{1, 6}, nil, false},
										Name:     "print",
									},
									Arguments: []ast.Node{
										&ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
											Name:     "a",
										},
									},
								},
							},
							{
								Kind: ast.NormalStage,
								Expr: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 25}, nil, false},
									Name:     "do-something",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("second stage is a call with no arguments, followed by an unexpected expression on the following line", func(t *testing.T) {
			n, err := parseChunk(t, "( print($a) | do-something\n1)", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					Span: NodeSpan{0, 29},
				},
				Statements: []ast.Node{
					&ast.PipelineExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 26},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_PARENTHESIZED_PIPE_EXPR_MISSING_CLOSING_PAREN},
							true,
						},
						Stages: []*ast.PipelineStage{
							{
								Kind: ast.NormalStage,
								Expr: &ast.CallExpression{
									NodeBase: ast.NodeBase{NodeSpan{2, 11}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 7}, nil, false},
										Name:     "print",
									},
									Arguments: []ast.Node{
										&ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{8, 10}, nil, false},
											Name:     "a",
										},
									},
								},
							},
							{
								Kind: ast.NormalStage,
								Expr: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 26}, nil, false},
									Name:     "do-something",
								},
							},
						},
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{27, 28}, nil, false},
						Raw:      "1",
						Value:    1,
					},
					&ast.UnknownNode{
						NodeBase: ast.NodeBase{
							NodeSpan{28, 29},
							&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInBlockOrModule(')')},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("first and second stages are calls with no arguments", func(t *testing.T) {
			n := mustparseChunk(t, "( print | do-something)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.PipelineExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 23}, IsParenthesized: true},
						Stages: []*ast.PipelineStage{
							{
								Kind: ast.NormalStage,
								Expr: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 7}, nil, false},
									Name:     "print",
								},
							},
							{
								Kind: ast.NormalStage,
								Expr: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 22}, nil, false},
									Name:     "do-something",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("second stage is a call with a single argument", func(t *testing.T) {
			n := mustparseChunk(t, "( print($a) | do-something($))")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 30}, nil, false},
				Statements: []ast.Node{
					&ast.PipelineExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 30}, IsParenthesized: true},
						Stages: []*ast.PipelineStage{
							{
								Kind: ast.NormalStage,
								Expr: &ast.CallExpression{
									NodeBase: ast.NodeBase{NodeSpan{2, 11}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 7}, nil, false},
										Name:     "print",
									},
									Arguments: []ast.Node{
										&ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{8, 10}, nil, false},
											Name:     "a",
										},
									},
								},
							},
							{
								Kind: ast.NormalStage,
								Expr: &ast.CallExpression{
									NodeBase: ast.NodeBase{NodeSpan{14, 29}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{14, 26}, nil, false},
										Name:     "do-something",
									},
									Arguments: []ast.Node{
										&ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{27, 28}, nil, false},
											Name:     "",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("third stage is a call with no arguments", func(t *testing.T) {
			n := mustparseChunk(t, "( print($a) | do-something($) | do-something-else)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 50}, nil, false},
				Statements: []ast.Node{
					&ast.PipelineExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 50}, IsParenthesized: true},
						Stages: []*ast.PipelineStage{
							{
								Kind: ast.NormalStage,
								Expr: &ast.CallExpression{
									NodeBase: ast.NodeBase{NodeSpan{2, 11}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 7}, nil, false},
										Name:     "print",
									},
									Arguments: []ast.Node{
										&ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{8, 10}, nil, false},
											Name:     "a",
										},
									},
								},
							},
							{
								Kind: ast.NormalStage,
								Expr: &ast.CallExpression{
									NodeBase: ast.NodeBase{NodeSpan{14, 29}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{14, 26}, nil, false},
										Name:     "do-something",
									},
									Arguments: []ast.Node{
										&ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{27, 28}, nil, false},
											Name:     "",
										},
									},
								},
							},
							{
								Kind: ast.NormalStage,
								Expr: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{32, 49}, nil, false},
									Name:     "do-something-else",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized", func(t *testing.T) {
			n := mustparseChunk(t, "a = 1 | f")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.PipelineExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 9}},
							Stages: []*ast.PipelineStage{
								{
									Kind: ast.NormalStage,
									Expr: &ast.IntLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{4, 5}},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									Kind: ast.NormalStage,
									Expr: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
										Name:     "f",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized", func(t *testing.T) {
			n := mustparseChunk(t, "a = 1 | f")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.PipelineExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 9}},
							Stages: []*ast.PipelineStage{
								{
									Kind: ast.NormalStage,
									Expr: &ast.IntLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{4, 5}},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									Kind: ast.NormalStage,
									Expr: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
										Name:     "f",
									},
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("call <string> shorthand", func(t *testing.T) {
		t.Run("callee is an identifier", func(t *testing.T) {
			n := mustparseChunk(t, `mime"json"`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
						Must:     true,
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "mime",
						},
						Arguments: []ast.Node{
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 10}, nil, false},
								Raw:      `"json"`,
								Value:    "json",
							},
						},
					},
				},
			}, n)

		})

		t.Run("callee is meta identier", func(t *testing.T) {
			n := mustparseChunk(t, `(@a"")`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{NodeSpan{1, 5}, nil, true},
						Must:     true,
						Callee: &ast.MetaIdentifier{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Arguments: []ast.Node{
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 5}},
								Raw:      `""`,
							},
						},
					},
				},
			}, n)
		})

	})

	t.Run("call <object> shorthand", func(t *testing.T) {
		t.Run("base case", func(t *testing.T) {
			n := mustparseChunk(t, `f{}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
						Must:     true,
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "f",
						},
						Arguments: []ast.Node{
							&ast.ObjectLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 3}},
							},
						},
					},
				},
			}, n)
		})

		t.Run("callee is meta identier", func(t *testing.T) {
			n := mustparseChunk(t, `(@a{})`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.CallExpression{
						NodeBase: ast.NodeBase{NodeSpan{1, 5}, nil, true},
						Must:     true,
						Callee: &ast.MetaIdentifier{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Arguments: []ast.Node{
							&ast.ObjectLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 5}},
							},
						},
					},
				},
			}, n)
		})

	})

	t.Run("object literal", func(t *testing.T) {

		testCases := []struct {
			input    string
			hasError bool
			result   ast.Node
		}{
			{
				input:    "{}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 2},
							},
							Properties: nil,
						},
					},
				},
			},
			{
				input:    "{",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 1},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_MISSING_CLOSING_BRACE},
								false,
							},
							Properties: nil,
						},
					},
				},
			},
			{
				input:    "{ ",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 2},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_MISSING_CLOSING_BRACE},
								false,
							},
							Properties: nil,
						},
					},
				},
			},
			{
				input:    "{ }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{0, 3}},
							Properties: nil,
						},
					},
				},
			},
			{
				input:    "{\n}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{0, 3}},
							Properties: nil,
						},
					},
				},
			},
			{
				input:    "{,}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{0, 3}},
							Properties: nil,
						},
					},
				},
			},
			{
				input:    "{,",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 2},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_MISSING_CLOSING_BRACE},
								false,
							},
							Properties: nil,
						},
					},
				},
			},
			{
				input:    "({)",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{1, 2},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_MISSING_CLOSING_BRACE},
								true,
							},
							Properties: nil,
						},
					},
				},
			},
			{
				input:    "{ a: 1 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 6},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a:1 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 5},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "@({ <{a}>: 1 })",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
					Statements: []ast.Node{
						&ast.QuotedExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 15}},
							Expression: &ast.ObjectLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 14}, IsParenthesized: true},
								Properties: []*ast.ObjectProperty{
									{
										NodeBase: ast.NodeBase{
											Span: NodeSpan{4, 12},
										},
										Key: &ast.UnquotedRegion{
											NodeBase: ast.NodeBase{NodeSpan{4, 9}, nil, false},
											Expression: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
												Name:     "a",
											},
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a : 1 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 7},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "@({ <{a}> : 1 })",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
					Statements: []ast.Node{
						&ast.QuotedExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 16}},
							Expression: &ast.ObjectLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 15}, IsParenthesized: true},
								Properties: []*ast.ObjectProperty{
									{
										NodeBase: ast.NodeBase{
											Span: NodeSpan{4, 13},
										},
										Key: &ast.UnquotedRegion{
											NodeBase: ast.NodeBase{NodeSpan{4, 9}, nil, false},
											Expression: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
												Name:     "a",
											},
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{a:1?}",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{1, 4},
										&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_OBJ_REC_ENTRY_ENTRY_SEPARATION},
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{
										NodeSpan{4, 5},
										&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInObjectRecord('?')},
										false,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "({a:1)",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{1, 5},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_MISSING_CLOSING_BRACE},
								true,
							},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{2, 5}},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a: 1, a: 2}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 13}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 6},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{
										NodeSpan{8, 12},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{a\n",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 3},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_MISSING_CLOSING_BRACE},
								false,
							},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{1, 2}},
									Value: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
										Name:     "a",
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "@({ <{a}>\n)",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
					Statements: []ast.Node{
						&ast.QuotedExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
							Expression: &ast.ObjectLiteral{
								NodeBase: ast.NodeBase{
									NodeSpan{2, 10},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_MISSING_CLOSING_BRACE},
									true,
								},
								Properties: []*ast.ObjectProperty{
									{
										NodeBase: ast.NodeBase{
											Span: NodeSpan{4, 9},
										},
										Value: &ast.UnquotedRegion{
											NodeBase: ast.NodeBase{NodeSpan{4, 9}, nil, false},
											Expression: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
												Name:     "a",
											},
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a :\n1 }",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 5},
										&sourcecode.ParsingError{UnspecifiedParsingError, UNEXPECTED_NEWLINE_AFTER_COLON},
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
								},
								{
									NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
									Key:      nil,
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a:\n}",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 4},
										&sourcecode.ParsingError{UnspecifiedParsingError, UNEXPECTED_NEWLINE_AFTER_COLON},
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a:}",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 5}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 4},
										&sourcecode.ParsingError{MissingObjectPropertyValue, MISSING_PROPERTY_VALUE},
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a %int: 1 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 13}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 11},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Type: &ast.PatternIdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
										Name:     "int",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "@({ <{a}> %int: 1 })",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
					Statements: []ast.Node{
						&ast.QuotedExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
							Expression: &ast.ObjectLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 19}, IsParenthesized: true},
								Properties: []*ast.ObjectProperty{
									{
										NodeBase: ast.NodeBase{
											Span: NodeSpan{4, 17},
										},
										Key: &ast.UnquotedRegion{
											NodeBase: ast.NodeBase{NodeSpan{4, 9}, nil, false},
											Expression: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
												Name:     "a",
											},
										},
										Type: &ast.PatternIdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{10, 14}, nil, false},
											Name:     "int",
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ # comment \n}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{0, 14}},
							Properties: nil,
						},
					},
				},
			},
			{
				input:    "{ a : 1 # comment \n}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{2, 7}},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ # comment \n a : 1}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{14, 19}},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{18, 19}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a : # comment \n 1}",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 19},
										&sourcecode.ParsingError{UnspecifiedParsingError, fmtInvalidObjRecordKeyCommentBeforeValueOfKey("a")},
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{18, 19}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ 1 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 5}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{NodeSpan{2, 4}, nil, false},
									Key:      nil,
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "@({ <{a}> })",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
					Statements: []ast.Node{
						&ast.QuotedExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
							Expression: &ast.ObjectLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 11}, IsParenthesized: true},
								Properties: []*ast.ObjectProperty{
									{
										NodeBase: ast.NodeBase{
											Span: NodeSpan{4, 10},
										},
										Value: &ast.UnquotedRegion{
											NodeBase: ast.NodeBase{NodeSpan{4, 9}, nil, false},
											Expression: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
												Name:     "a",
											},
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{1",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 2},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_MISSING_CLOSING_BRACE},
								false,
							},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
									Key:      nil,
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ 1",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 3},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_MISSING_CLOSING_BRACE},
								false,
							},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Key:      nil,
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{\n1",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 3},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_MISSING_CLOSING_BRACE},
								false,
							},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Key:      nil,
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{1\n",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 3},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_MISSING_CLOSING_BRACE},
								false,
							},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
									Key:      nil,
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ (\"1\") }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{NodeSpan{3, 8}, nil, false},
									Key:      nil,
									Value: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{
											NodeSpan{3, 6},
											nil,
											true,
										},
										Raw:   `"1"`,
										Value: "1",
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ 1 %int }",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 8},
										&sourcecode.ParsingError{UnspecifiedParsingError, ONLY_KEYS_CAN_HAVE_A_TYPE_ANNOT},
										false,
									},
									Key: nil,
									Type: &ast.PatternIdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
										Name:     "int",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ 1 2 }",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 4},
										&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_OBJ_REC_ENTRY_ENTRY_SEPARATION},
										false,
									},
									Key: nil,
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
									Key:      nil,
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a : 1  b : 2 }",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 16}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 7},
										&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_OBJ_REC_ENTRY_ENTRY_SEPARATION},
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{
										NodeSpan{9, 14},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
										Name:     "b",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a : 1 , b : 2 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 17}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 7},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{
										NodeSpan{10, 15},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
										Name:     "b",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a : 1 \n }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 7},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			}, {
				input:    "{ \n a : 1 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{4, 9},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ .name }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{NodeSpan{2, 8}, nil, false},
									Value: &ast.PropertyNameLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 7}, nil, false},
										Name:     "name",
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a : 1 \n b : 2 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 17}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 7},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{
										NodeSpan{10, 15},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
										Name:     "b",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a : 1 \n\n b : 2 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 18}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 7},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{
										NodeSpan{11, 16},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
										Name:     "b",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a : 1 \n \n b : 2 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 19}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 7},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{
										NodeSpan{12, 17},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
										Name:     "b",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ a : 1 \n  \n b : 2 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 7},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{
										NodeSpan{13, 18},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
										Name:     "b",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ ... $e.{name} }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{0, 17}},
							Properties: nil,
							SpreadElements: []*ast.PropertySpreadElement{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 15},
										nil,
										false,
									},
									Expr: &ast.ExtractionExpression{
										NodeBase: ast.NodeBase{NodeSpan{6, 15}, nil, false},
										Object: &ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
											Name:     "e",
										},
										Keys: &ast.KeyListExpression{
											NodeBase: ast.NodeBase{Span: NodeSpan{8, 15}},
											Keys: []ast.Node{
												&ast.IdentifierLiteral{
													NodeBase: ast.NodeBase{NodeSpan{10, 14}, nil, false},
													Name:     "name",
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ _constraints_ { } }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 21}},
							MetaProperties: []*ast.ObjectMetaProperty{
								{
									NodeBase: ast.NodeBase{NodeSpan{2, 19}, nil, false},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{2, 15}, nil, false},
										Name:     "_constraints_",
									},
									Initialization: &ast.InitializationBlock{
										NodeBase: ast.NodeBase{Span: NodeSpan{16, 19}},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ ... $e }",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{0, 10}},
							Properties: nil,
							SpreadElements: []*ast.PropertySpreadElement{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 8},
										&sourcecode.ParsingError{ExtractionExpressionExpected, fmtInvalidSpreadElemExprShouldBeExtrExprNot((*ast.Variable)(nil))},
										false,
									},
									Expr: &ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
										Name:     "e",
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "{ ... $e.{name} 1 }",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
					Statements: []ast.Node{
						&ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 19}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{NodeSpan{16, 18}, nil, false},
									Key:      nil,
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
							SpreadElements: []*ast.PropertySpreadElement{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 15},
										&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_OBJ_REC_ENTRY_ENTRY_SEPARATION},
										false,
									},
									Expr: &ast.ExtractionExpression{
										NodeBase: ast.NodeBase{NodeSpan{6, 15}, nil, false},
										Object: &ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
											Name:     "e",
										},
										Keys: &ast.KeyListExpression{
											NodeBase: ast.NodeBase{Span: NodeSpan{8, 15}},
											Keys: []ast.Node{
												&ast.IdentifierLiteral{
													NodeBase: ast.NodeBase{NodeSpan{10, 14}, nil, false},
													Name:     "name",
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			{
				input:    "{]}",
				hasError: true,
			},
			{
				input:    "{] }",
				hasError: true,
			},
			{
				input:    "{ ]}",
				hasError: true,
			},
			{
				input:    "{ ] }",
				hasError: true,
			},
			//
			{
				input:    "{], a: 1}",
				hasError: true,
			},
			{
				input:    "{] a: 1}",
				hasError: true,
			},
			//
			{
				input:    "{ a : ] }",
				hasError: true,
			},
			{
				input:    "{ a : 1] }",
				hasError: true,
			},
			{
				input:    "{ a : 1,] }",
				hasError: true,
			},
			{
				input:    "{ a : 1 ] }",
				hasError: true,
			},
			//
			{
				input:    "{ a : ]b: 2 }",
				hasError: true,
			},
			{
				input:    "{ a : ] b: 2 }",
				hasError: true,
			},
			{
				input:    "{ a : 1]b: 2 }",
				hasError: true,
			},
			{
				input:    "{ a : 1] b: 2 }",
				hasError: true,
			},
			{
				input:    "{ a : 1,]b: 2 }",
				hasError: true,
			},
			{
				input:    "{ a : 1 ]b: 2 }",
				hasError: true,
			},
			//
			{
				input:    "{:}",
				hasError: true,
			},
			{
				input:    "{: }",
				hasError: true,
			},
			{
				input:    "{ :}",
				hasError: true,
			},
			{
				input:    "{ : }",
				hasError: true,
			},
			//
			{
				input:    "{:, a: 1}",
				hasError: true,
			},
			{
				input:    "{: a: 1}",
				hasError: true,
			},
		}

		for _, testCase := range testCases {
			t.Run(testCase.input, func(t *testing.T) {
				n, err := parseChunk(t, testCase.input, "")
				if testCase.hasError {
					assert.Error(t, err)
				} else {
					assert.NoError(t, err)
				}

				if testCase.result != nil {
					assert.Equal(t, testCase.result, n)
				}
			})
		}
	})

	t.Run("record literal", func(t *testing.T) {

		testCases := []struct {
			input    string
			hasError bool
			result   ast.Node
		}{
			{
				input:    "#{}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{0, 3}},
							Properties: nil,
						},
					},
				},
			}, {
				input:    "#{ }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{0, 4}},
							Properties: nil,
						},
					},
				},
			},
			{
				input:    "#{\n}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{0, 4}},
							Properties: nil,
						},
					},
				},
			},
			{
				input:    "#{ a: 1 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 7}},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ a:1 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 6}},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ a : 1 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 8}},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ a: 1, a: 2}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 7}},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{
										NodeSpan{9, 13},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ a :\n1 }",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 6},
										&sourcecode.ParsingError{UnspecifiedParsingError, UNEXPECTED_NEWLINE_AFTER_COLON},
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Name:     "a",
									},
								},
								{
									NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
									Key:      nil,
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ a:}",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 5},
										&sourcecode.ParsingError{MissingObjectPropertyValue, MISSING_PROPERTY_VALUE},
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Name:     "a",
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ # comment \n}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{0, 15}},
							Properties: nil,
						},
					},
				},
			},
			{
				input:    "#{ a : 1 # comment \n}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 21}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 8},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ # comment \n a : 1}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 21}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{15, 20}},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ a : # comment \n 1}",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 21}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 20},
										&sourcecode.ParsingError{UnspecifiedParsingError, fmtInvalidObjRecordKeyCommentBeforeValueOfKey("a")},
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ 1 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{NodeSpan{3, 5}, nil, false},
									Key:      nil,
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ (\"1\") }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{NodeSpan{4, 9}, nil, false},
									Key:      nil,
									Value: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{
											NodeSpan{4, 7},
											nil,
											true,
										},
										Raw:   `"1"`,
										Value: "1",
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ 1 2 }",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 5},
										&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_OBJ_REC_ENTRY_ENTRY_SEPARATION},
										false,
									},
									Key: nil,
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{NodeSpan{5, 7}, nil, false},
									Key:      nil,
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ a : 1  b : 2 }",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 17},
								nil,
								false,
							},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 8},
										&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_OBJ_REC_ENTRY_ENTRY_SEPARATION},
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{
										NodeSpan{10, 15},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
										Name:     "b",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			}, {
				input:    "#{ a : 1 , b : 2 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 18}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 8}},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{11, 16}},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
										Name:     "b",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ a : 1 \n }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 8}},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			}, {
				input:    "#{ \n a : 1 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 10}},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ a : 1 \n b : 2 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 18}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 8}},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{11, 16}},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
										Name:     "b",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ .name }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{NodeSpan{3, 9}, nil, false},
									Value: &ast.PropertyNameLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 8}, nil, false},
										Name:     "name",
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ ... $e.{name} }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{0, 18}},
							Properties: nil,
							SpreadElements: []*ast.PropertySpreadElement{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 16}},
									Expr: &ast.ExtractionExpression{
										NodeBase: ast.NodeBase{NodeSpan{7, 16}, nil, false},
										Object: &ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
											Name:     "e",
										},
										Keys: &ast.KeyListExpression{
											NodeBase: ast.NodeBase{Span: NodeSpan{9, 16}},
											Keys: []ast.Node{
												&ast.IdentifierLiteral{
													NodeBase: ast.NodeBase{NodeSpan{11, 15}, nil, false},
													Name:     "name",
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ ... $e }",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{0, 11}},
							Properties: nil,
							SpreadElements: []*ast.PropertySpreadElement{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 9},
										&sourcecode.ParsingError{ExtractionExpressionExpected, fmtInvalidSpreadElemExprShouldBeExtrExprNot((*ast.Variable)(nil))},
										false,
									},
									Expr: &ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
										Name:     "e",
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{ ... $e.{name} 1 }",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
					Statements: []ast.Node{
						&ast.RecordLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
							Properties: []*ast.ObjectProperty{
								{
									NodeBase: ast.NodeBase{NodeSpan{17, 19}, nil, false},
									Key:      nil,
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
							SpreadElements: []*ast.PropertySpreadElement{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 16},
										&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_OBJ_REC_ENTRY_ENTRY_SEPARATION},
										false,
									},
									Expr: &ast.ExtractionExpression{
										NodeBase: ast.NodeBase{NodeSpan{7, 16}, nil, false},
										Object: &ast.Variable{
											NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
											Name:     "e",
										},
										Keys: &ast.KeyListExpression{
											NodeBase: ast.NodeBase{Span: NodeSpan{9, 16}},
											Keys: []ast.Node{
												&ast.IdentifierLiteral{
													NodeBase: ast.NodeBase{NodeSpan{11, 15}, nil, false},
													Name:     "name",
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#{]}",
				hasError: true,
			},
			{
				input:    "#{] }",
				hasError: true,
			},
			{
				input:    "#{ ]}",
				hasError: true,
			},
			{
				input:    "#{ ] }",
				hasError: true,
			},
			//
			{
				input:    "#{], a: 1}",
				hasError: true,
			},
			{
				input:    "#{] a: 1}",
				hasError: true,
			},
			//
			{
				input:    "#{ a : ] }",
				hasError: true,
			},
			{
				input:    "#{ a : 1] }",
				hasError: true,
			},
			{
				input:    "#{ a : 1,] }",
				hasError: true,
			},
			{
				input:    "#{ a : 1 ] }",
				hasError: true,
			},
			//
			{
				input:    "#{ a : ]b: 2 }",
				hasError: true,
			},
			{
				input:    "#{ a : ] b: 2 }",
				hasError: true,
			},
			{
				input:    "#{ a : 1]b: 2 }",
				hasError: true,
			},
			{
				input:    "#{ a : 1] b: 2 }",
				hasError: true,
			},
			{
				input:    "#{ a : 1,]b: 2 }",
				hasError: true,
			},
			{
				input:    "#{ a : 1 ]b: 2 }",
				hasError: true,
			},
			//
			{
				input:    "#{:}",
				hasError: true,
			},
			{
				input:    "#{: }",
				hasError: true,
			},
			{
				input:    "#{ :}",
				hasError: true,
			},
			{
				input:    "#{ : }",
				hasError: true,
			},
			//
			{
				input:    "#{:, a: 1}",
				hasError: true,
			},
			{
				input:    "#{: a: 1}",
				hasError: true,
			},
		}

		for _, testCase := range testCases {
			t.Run(testCase.input, func(t *testing.T) {
				n, err := parseChunk(t, testCase.input, "")
				if testCase.hasError {
					assert.Error(t, err)
				} else {
					assert.NoError(t, err)
				}

				if testCase.result != nil {
					assert.Equal(t, testCase.result, n)
				}
			})
		}
	})

	t.Run("list literal", func(t *testing.T) {

		testCases := []struct {
			input    string
			hasError bool
			result   ast.Node
		}{
			{
				input: "[]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
					Statements: []ast.Node{
						&ast.ListLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 2},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_BRACKET, Span: NodeSpan{0, 1}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{1, 2}},
								},*/
							},
							Elements: nil,
						},
					},
				},
			},
			{
				input: "[ ]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.ListLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 3},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_BRACKET, Span: NodeSpan{0, 1}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{2, 3}},
								},*/
							},
							Elements: nil,
						},
					},
				},
			},
			{
				input: "[ 1 ]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
					Statements: []ast.Node{
						&ast.ListLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 5},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_BRACKET, Span: NodeSpan{0, 1}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{4, 5}},
								},*/
							},
							Elements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			},
			{
				input: "[ 1 2 ]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
					Statements: []ast.Node{
						&ast.ListLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 7},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_BRACKET, Span: NodeSpan{0, 1}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{6, 7}},
								},*/
							}, Elements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Raw:      "1",
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			},
			{
				input: "[ 1 , 2 ]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
					Statements: []ast.Node{
						&ast.ListLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 9},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_BRACKET, Span: NodeSpan{0, 1}},
									{Type: ast.COMMA, Span: NodeSpan{4, 5}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{8, 9}},
								},*/
							},
							Elements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Raw:      "1",
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			},
			{
				input: "[ 1 \n 2 ]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
					Statements: []ast.Node{
						&ast.ListLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 9},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_BRACKET, Span: NodeSpan{0, 1}},
									{Type: ast.NEWLINE, Span: NodeSpan{4, 5}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{8, 9}},
								},*/
							},
							Elements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Raw:      "1",
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			},
			{
				input: "[ 1, ]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Statements: []ast.Node{
						&ast.ListLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 6},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_BRACKET, Span: NodeSpan{0, 1}},
									{Type: ast.COMMA, Span: NodeSpan{3, 4}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{5, 6}},
								},*/
							},
							Elements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			},
			{
				input:    "[ 1, 2",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Statements: []ast.Node{
						&ast.ListLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 6},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_LIST_LIT_MISSING_CLOSING_BRACKET},
								false,
							},
							Elements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Raw:      "1",
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			},
			{
				input: "[ ...$a ]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
					Statements: []ast.Node{
						&ast.ListLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 9},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_BRACKET, Span: NodeSpan{0, 1}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{8, 9}},
								},*/
							},
							Elements: []ast.Node{
								&ast.ElementSpreadElement{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 7},
										nil,
										false,
										/*[]ast.Token{
											{Type: ast.THREE_DOTS, Span: NodeSpan{2, 5}},
										},*/
									},
									Expr: &ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{5, 7}, nil, false},
										Name:     "a",
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "[ ..., ]",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
					Statements: []ast.Node{
						&ast.ListLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 8},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_BRACKET, Span: NodeSpan{0, 1}},
									{Type: ast.COMMA, Span: NodeSpan{5, 6}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{7, 8}},
								},*/
							},
							Elements: []ast.Node{
								&ast.ElementSpreadElement{
									NodeBase: ast.NodeBase{
										NodeSpan{2, 6},
										nil,
										false,
										/*[]ast.Token{
											{Type: ast.THREE_DOTS, Span: NodeSpan{2, 5}},
										},*/
									},
									Expr: &ast.MissingExpression{
										NodeBase: ast.NodeBase{
											NodeSpan{5, 6},
											&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("[ ..., ]"), 5, true)},
											false,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input: "[]%int[]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
					Statements: []ast.Node{
						&ast.ListLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 8},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_BRACKET, Span: NodeSpan{0, 1}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{1, 2}},
									{Type: ast.OPENING_BRACKET, Span: NodeSpan{6, 7}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{7, 8}},
								},*/
							},
							Elements: nil,
							TypeAnnotation: &ast.PatternIdentifierLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 6}},
								Name:     "int",
							},
						},
					},
				},
			},
			{
				input:    "[]%int",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Statements: []ast.Node{
						&ast.ListLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 6},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_LIST_LIT_MISSING_OPENING_BRACKET_AFTER_TYPE},
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_BRACKET, Span: NodeSpan{0, 1}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{1, 2}},
								},*/
							},
							Elements: nil,
							TypeAnnotation: &ast.PatternIdentifierLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 6}},
								Name:     "int",
							},
						},
					},
				},
			},
			{
				input:    "[]%int[",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
					Statements: []ast.Node{
						&ast.ListLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 7},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_LIST_LIT_MISSING_CLOSING_BRACKET},
								false,
							},
							Elements: nil,
							TypeAnnotation: &ast.PatternIdentifierLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 6}},
								Name:     "int",
							},
						},
					},
				},
			},
		}

		for _, testCase := range testCases {
			t.Run(testCase.input, func(t *testing.T) {
				n, err := parseChunk(t, testCase.input, "")
				if testCase.hasError {
					assert.Error(t, err)
				} else {
					assert.NoError(t, err)
				}

				assert.Equal(t, testCase.result, n)
			})
		}
	})

	t.Run("tuple literal", func(t *testing.T) {

		testCases := []struct {
			input    string
			hasError bool
			result   ast.Node
		}{
			{
				input: "#[]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.TupleLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 3},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_TUPLE_BRACKET, Span: NodeSpan{0, 2}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{2, 3}},
								},*/
							},
							Elements: nil,
						},
					},
				},
			},
			{
				input: "#[ ]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
					Statements: []ast.Node{
						&ast.TupleLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 4},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_TUPLE_BRACKET, Span: NodeSpan{0, 2}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{3, 4}},
								},*/
							},
							Elements: nil,
						},
					},
				},
			},
			{
				input: "#[ 1 ]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Statements: []ast.Node{
						&ast.TupleLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 6},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_TUPLE_BRACKET, Span: NodeSpan{0, 2}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{5, 6}},
								},*/
							},
							Elements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			},
			{
				input: "#[ 1 2 ]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
					Statements: []ast.Node{
						&ast.TupleLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 8},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_TUPLE_BRACKET, Span: NodeSpan{0, 2}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{7, 8}},
								},*/
							}, Elements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Raw:      "1",
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			},
			{
				input: "#[ 1 , 2 ]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
					Statements: []ast.Node{
						&ast.TupleLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 10},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_TUPLE_BRACKET, Span: NodeSpan{0, 2}},
									{Type: ast.COMMA, Span: NodeSpan{5, 6}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{9, 10}},
								},*/
							},
							Elements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Raw:      "1",
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			},
			{
				input: "#[ 1 \n 2 ]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
					Statements: []ast.Node{
						&ast.TupleLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 10},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_TUPLE_BRACKET, Span: NodeSpan{0, 2}},
									{Type: ast.NEWLINE, Span: NodeSpan{5, 6}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{9, 10}},
								},*/
							},
							Elements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Raw:      "1",
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			},
			{
				input: "#[ 1, ]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
					Statements: []ast.Node{
						&ast.TupleLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 7},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_TUPLE_BRACKET, Span: NodeSpan{0, 2}},
									{Type: ast.COMMA, Span: NodeSpan{4, 5}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{6, 7}},
								},*/
							},
							Elements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			},
			{
				input:    "#[ 1, 2",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
					Statements: []ast.Node{
						&ast.TupleLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 7},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_TUPLE_LIT_MISSING_CLOSING_BRACKET},
								false,
							},
							Elements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Raw:      "1",
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			},
			{
				input: "#[ ...$a ]",
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
					Statements: []ast.Node{
						&ast.TupleLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 10},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_TUPLE_BRACKET, Span: NodeSpan{0, 2}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{9, 10}},
								},*/
							},
							Elements: []ast.Node{
								&ast.ElementSpreadElement{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 8},
										nil,
										false,
										/*[]ast.Token{
											{Type: ast.THREE_DOTS, Span: NodeSpan{3, 6}},
										},*/
									},
									Expr: &ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
										Name:     "a",
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "#[ ..., ]",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
					Statements: []ast.Node{
						&ast.TupleLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 9},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_TUPLE_BRACKET, Span: NodeSpan{0, 2}},
									{Type: ast.COMMA, Span: NodeSpan{6, 7}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{8, 9}},
								},*/
							},
							Elements: []ast.Node{
								&ast.ElementSpreadElement{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 7},
										nil,
										false,
										/*[]ast.Token{
											{Type: ast.THREE_DOTS, Span: NodeSpan{3, 6}},
										},*/
									},
									Expr: &ast.MissingExpression{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 7},
											&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("[ ..., ]"), 5, true)},
											false,
										},
									},
								},
							},
						},
					},
				},
			},
		}

		for _, testCase := range testCases {
			t.Run(testCase.input, func(t *testing.T) {
				n, err := parseChunk(t, testCase.input, "")
				if testCase.hasError {
					assert.Error(t, err)
				} else {
					assert.NoError(t, err)
				}

				assert.Equal(t, testCase.result, n)
			})
		}
	})

	t.Run("dictionary literal", func(t *testing.T) {

		testCases := []struct {
			input    string
			hasError bool
			result   ast.Node
		}{
			{
				input:    ":{}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 3}},
						},
					},
				},
			},
			{
				input:    ":{ }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
						},
					},
				},
			},
			{
				input:    `:{ "a" : 1 }`,
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 10}},
									Key: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
										Raw:      `"a"`,
										Value:    "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input: `:{ https://aa/: 1 }`,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 19}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 17}},
									Key: &ast.URLLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{3, 14}},
										Value:    "https://aa/",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input: `:{ /aa: 1 }`,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 9}},
									Key: &ast.AbsolutePathLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{3, 6}},
										Value:    "/aa",
										Raw:      "/aa",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `:{ /aa:1 }`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{3, 9},
										Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DICT_ENTRY_MISSING_SPACE_BETWEEN_KEY_AND_COLON},
									},
									Key: &ast.AbsolutePathLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{3, 8}},
										Value:    "/aa:1",
										Raw:      "/aa:1",
									},
								},
							},
						},
					},
				},
			},
			{
				input: `:{ %/aa: 1 }`,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 10}},
									Key: &ast.AbsolutePathPatternLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{3, 7}},
										Value:    "/aa",
										Raw:      "%/aa",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input: `:{ https://aa/: 1 }`,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 19}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 17}},
									Key: &ast.URLLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{3, 14}},
										Value:    "https://aa/",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input: `:{ %https://aa/: 1 }`,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 18}},
									Key: &ast.URLPatternLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{3, 15}},
										Value:    "https://aa/",
										Raw:      "%https://aa/",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input: `:{ https://aa: 1 }`,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 18}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 16}},
									Key: &ast.HostLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{3, 13}},
										Value:    "https://aa",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `:{ https://aa:1 }`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 17}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{3, 16},
										Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DICT_ENTRY_MISSING_SPACE_BETWEEN_KEY_AND_COLON},
									},
									Key: &ast.HostLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{3, 15}},
										Value:    "https://aa:1",
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `:{ https://aa:1:1 }`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 19}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{3, 18},
										Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DICT_ENTRY_MISSING_SPACE_BETWEEN_KEY_AND_COLON},
									},
									Key: &ast.InvalidURL{
										NodeBase: ast.NodeBase{
											Span: NodeSpan{3, 17},
											Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_URL_OR_HOST},
										},
										Value: "https://aa:1:1",
									},
								},
							},
						},
					},
				},
			},
			{
				input: `:{ %https://aa: 1 }`,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 19}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 17}},
									Key: &ast.HostPatternLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{3, 14}},
										Value:    "https://aa",
										Raw:      "%https://aa",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `:{ "a" :   }`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 12},
										nil,
										false,
									},
									Key: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
										Raw:      `"a"`,
										Value:    "a",
									},
									Value: &ast.MissingExpression{
										NodeBase: ast.NodeBase{
											NodeSpan{11, 12},
											&sourcecode.ParsingError{
												MissingExpr,
												fmtExprExpectedHere([]rune(`:{ "a" :   }`), 11, true),
											},
											false,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `(:{ "a":)`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{1, 8},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_DICT_MISSING_CLOSING_BRACE},
								true,
							},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{4, 9},
										nil,
										false,
									},
									Key: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{NodeSpan{4, 7}, nil, false},
										Raw:      `"a"`,
										Value:    "a",
									},
									Value: &ast.MissingExpression{
										NodeBase: ast.NodeBase{
											NodeSpan{8, 9},
											&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune(`(:{ "a":)`), 8, true)},
											false,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `:{ "a"   }`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 9},
										&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DICT_ENTRY_MISSING_COLON_AFTER_KEY},
										false,
									},
									Key: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
										Raw:      `"a"`,
										Value:    "a",
									},
									Value: nil,
								},
							},
						},
					},
				},
			},
			{
				input:    `:{ a   }`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 7},
										&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DICT_ENTRY_MISSING_COLON_AFTER_KEY},
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Name:     "a",
									},
									Value: nil,
								},
							},
						},
					},
				},
			},
			{
				input:    `:{ a  `,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 6},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_DICT_MISSING_CLOSING_BRACE},
								false,
							},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 6},
										&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DICT_ENTRY_MISSING_COLON_AFTER_KEY},
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
										Name:     "a",
									},
									Value: nil,
								},
							},
						},
					},
				},
			},
			{
				input:    `:{ "a" : 1  "b" : 2 }`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 21}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{3, 10},
										&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DICT_LIT_ENTRY_SEPARATION},
										false,
									},
									Key: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
										Raw:      `"a"`,
										Value:    "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{12, 19}},
									Key: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{NodeSpan{12, 15}, nil, false},
										Raw:      `"b"`,
										Value:    "b",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{18, 19}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `:{ "a" : 1 , "b" : 2 }`,
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 22}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 10}},
									Key: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
										Raw:      `"a"`,
										Value:    "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{13, 20}},
									Key: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{NodeSpan{13, 16}, nil, false},
										Raw:      `"b"`,
										Value:    "b",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    ":{ \"a\" : 1 \n }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 10}},
									Key: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
										Raw:      `"a"`,
										Value:    "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    ":{ \n \"a\" : 1 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 12}},
									Key: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{NodeSpan{5, 8}, nil, false},
										Raw:      `"a"`,
										Value:    "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    ":{ \"a\" : 1 \n \"b\" : 2 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 22}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 10}},
									Key: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
										Raw:      `"a"`,
										Value:    "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								{
									NodeBase: ast.NodeBase{
										NodeSpan{13, 20},
										nil,
										false,
									},
									Key: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{NodeSpan{13, 16}, nil, false},
										Raw:      `"b"`,
										Value:    "b",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `:{?}`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
					Statements: []ast.Node{
						&ast.DictionaryLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
							Entries: []*ast.DictionaryEntry{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{2, 3}},
									Key: &ast.UnknownNode{
										NodeBase: ast.NodeBase{
											NodeSpan{2, 3},
											&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInDictionary('?')},
											false,
										},
									},
								},
							},
						},
					},
				},
			},
		}

		for _, testCase := range testCases {
			t.Run(testCase.input, func(t *testing.T) {
				n, err := parseChunk(t, testCase.input, "")
				if testCase.hasError {
					assert.Error(t, err)
				} else {
					assert.NoError(t, err)
				}

				if testCase.result != nil {
					assert.Equal(t, testCase.result, n)
				}
			})
		}
	})

	t.Run("dictionary pattern literal", func(t *testing.T) {

		testCases := []struct {
			input    string
			hasError bool
			result   ast.Node
		}{
			{
				input:    "pattern p = :{}",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 15}},
							},
						},
					},
				},
			},
			{
				input:    "pattern p = :{ }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 16}},
							},
						},
					},
				},
			},
			{
				input:    `pattern p = :{ "a" : 1 }`,
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 24}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{15, 22}},
										Key: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{21, 22}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input: `pattern p = :{ https://aa/: 1 }`,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 31}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{15, 29}},
										Key: &ast.URLPatternLiteral{
											NodeBase:   ast.NodeBase{Span: NodeSpan{15, 26}},
											Value:      "https://aa/",
											Raw:        "https://aa/",
											Unprefixed: true,
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{28, 29}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input: `pattern p = :{ /aa: 1 }`,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 23}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{15, 21}},
										Key: &ast.AbsolutePathPatternLiteral{
											NodeBase:   ast.NodeBase{Span: NodeSpan{15, 18}},
											Value:      "/aa",
											Raw:        "/aa",
											Unprefixed: true,
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `pattern p = :{ /aa:1 }`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 22}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{
											Span: NodeSpan{15, 21},
											Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DICT_PATT_ENTRY_MISSING_SPACE_BETWEEN_KEY_AND_COLON},
										},
										Key: &ast.AbsolutePathPatternLiteral{
											NodeBase:   ast.NodeBase{Span: NodeSpan{15, 20}},
											Value:      "/aa:1",
											Raw:        "/aa:1",
											Unprefixed: true,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input: `pattern p = :{ %/aa: 1 }`,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 24}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{15, 22}},
										Key: &ast.AbsolutePathPatternLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{15, 19}},
											Value:    "/aa",
											Raw:      "%/aa",
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{21, 22}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input: `pattern p = :{ %https://aa/: 1 }`,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 32}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 32}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 32}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{15, 30}},
										Key: &ast.URLPatternLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{15, 27}},
											Value:    "https://aa/",
											Raw:      "%https://aa/",
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{29, 30}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input: `pattern p = :{ https://aa: 1 }`,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 30}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 30}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 30}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{15, 28}},
										Key: &ast.HostPatternLiteral{
											NodeBase:   ast.NodeBase{Span: NodeSpan{15, 25}},
											Value:      "https://aa",
											Raw:        "https://aa",
											Unprefixed: true,
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{27, 28}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `pattern p = :{ https://aa:1 }`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 29}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 29}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 29}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{
											Span: NodeSpan{15, 28},
											Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DICT_PATT_ENTRY_MISSING_SPACE_BETWEEN_KEY_AND_COLON},
										},
										Key: &ast.HostPatternLiteral{
											NodeBase:   ast.NodeBase{Span: NodeSpan{15, 27}},
											Value:      "https://aa:1",
											Raw:        "https://aa:1",
											Unprefixed: true,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `pattern p = :{ https://aa:1:1 }`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 31}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{
											Span: NodeSpan{15, 30},
											Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DICT_PATT_ENTRY_MISSING_COLON_AFTER_KEY},
										},
										Key: &ast.URLPatternLiteral{
											NodeBase: ast.NodeBase{
												Span: NodeSpan{15, 29},
												Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_URL_PATT},
											},
											Value:      "https://aa:1:1",
											Raw:        "https://aa:1:1",
											Unprefixed: true,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input: `pattern p = :{ %https://aa: 1 }`,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 31}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{15, 29}},
										Key: &ast.HostPatternLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{15, 26}},
											Value:    "https://aa",
											Raw:      "%https://aa",
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{28, 29}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `pattern p = :{ "a" :   }`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 24}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{15, 24}},
										Key: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										Value: &ast.MissingExpression{
											NodeBase: ast.NodeBase{
												NodeSpan{23, 24},
												&sourcecode.ParsingError{
													MissingExpr,
													fmtExprExpectedHere([]rune(`:{ "a" :   }`), 11, true),
												},
												false,
											},
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `pattern p = (:{ "a":)`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{
									NodeSpan{13, 20},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_DICT_PATT_MISSING_CLOSING_BRACE},
									true,
								},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{16, 21}},
										Key: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{16, 19}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										Value: &ast.MissingExpression{
											NodeBase: ast.NodeBase{
												NodeSpan{20, 21},
												&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune(`(:{ "a":)`), 8, true)},
												false,
											},
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `pattern p = :{ "a"   }`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 22}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{
											NodeSpan{15, 21},
											&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DICT_PATT_ENTRY_MISSING_COLON_AFTER_KEY},
											false,
										},
										Key: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										Value: nil,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `pattern p = :{ a   }`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 20}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{
											NodeSpan{15, 19},
											&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DICT_PATT_ENTRY_MISSING_COLON_AFTER_KEY},
											false,
										},
										Key: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{15, 16}, nil, false},
											Name:       "a",
											Unprefixed: true,
										},
										Value: nil,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `pattern p = :{ a  `,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{
									NodeSpan{12, 18},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_DICT_PATT_MISSING_CLOSING_BRACE},
									false,
								},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{
											NodeSpan{15, 18},
											&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DICT_PATT_ENTRY_MISSING_COLON_AFTER_KEY},
											false,
										},
										Key: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{15, 16}, nil, false},
											Name:       "a",
											Unprefixed: true,
										},
										Value: nil,
									},
								},
							},
						},
					},
				},
			},
			{ //
				input:    `pattern p = :{ "a" : 1  "b" : 2 }`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 33}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 33}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 33}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{
											NodeSpan{15, 22},
											&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_DICT_PATT_LIT_ENTRY_SEPARATION},
											false,
										},
										Key: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{21, 22}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{24, 31}},
										Key: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{24, 27}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{30, 31}, nil, false},
											Raw:      "2",
											Value:    2,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `pattern p = :{ "a" : 1 , "b" : 2 }`,
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 34}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 34}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 34}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{15, 22}},
										Key: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{21, 22}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{25, 32}},
										Key: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{25, 28}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{31, 32}, nil, false},
											Raw:      "2",
											Value:    2,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "pattern p = :{ \"a\" : 1 \n }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 26}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{15, 22}},
										Key: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{21, 22}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "pattern p = :{ \n \"a\" : 1 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{Span: NodeSpan{0, 26}},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 26}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{17, 24}},
										Key: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{17, 20}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{23, 24}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "pattern p = :{ \"a\" : 1 \n \"b\" : 2 }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 34}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 34}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 34}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{15, 22}},
										Key: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{21, 22}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{25, 32}},
										Key: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{25, 28}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
										Value: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{31, 32}, nil, false},
											Raw:      "2",
											Value:    2,
										},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    `pattern p = :{?}`,
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
					Statements: []ast.Node{
						&ast.PatternDefinition{
							NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
							Left: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Unprefixed: true,
								Name:       "p",
							},
							Right: &ast.DictionaryPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 16}},
								Entries: []*ast.DictionaryPatternEntry{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{14, 15}},
										Key: &ast.UnknownNode{
											NodeBase: ast.NodeBase{
												NodeSpan{14, 15},
												&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInDictionaryPattern('?')},
												false,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		}

		for _, testCase := range testCases {
			t.Run(testCase.input, func(t *testing.T) {
				n, err := parseChunk(t, testCase.input, "")
				if testCase.hasError {
					assert.Error(t, err)
				} else {
					assert.NoError(t, err)
				}

				if testCase.result != nil {
					assert.Equal(t, testCase.result, n)
				}
			})
		}
	})

	t.Run("if statement", func(t *testing.T) {
		t.Run("empty", func(t *testing.T) {
			n := mustparseChunk(t, "if true { }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.IfStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IF_KEYWORD, Span: NodeSpan{0, 2}},
							},*/
						}, Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 7}, nil, false},
							Value:    true,
						},
						Consequent: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{8, 11},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{8, 9}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{10, 11}},
								},*/
							},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		//also used for checking block parsing
		t.Run("non empty", func(t *testing.T) {
			n := mustparseChunk(t, "if true { 1 }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.IfStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IF_KEYWORD, Span: NodeSpan{0, 2}},
							},*/
						}, Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 7}, nil, false},
							Value:    true,
						},
						Consequent: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{8, 13},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{8, 9}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{12, 13}},
								},*/
							},
							Statements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		//also used for checking call parsing
		t.Run("body contains a call without parenthesis", func(t *testing.T) {
			n := mustparseChunk(t, "if true { a 1 }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.IfStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 15},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IF_KEYWORD, Span: NodeSpan{0, 2}},
							},*/
						},
						Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 7}, nil, false},
							Value:    true,
						},
						Consequent: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{8, 15},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{8, 9}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{14, 15}},
								},*/
							},
							Statements: []ast.Node{
								&ast.CallExpression{
									Must:              true,
									CommandLikeSyntax: true,
									NodeBase:          ast.NodeBase{NodeSpan{10, 14}, nil, false},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
										Name:     "a",
									},
									Arguments: []ast.Node{
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
											Raw:      `1`,
											Value:    1,
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("missing block after if", func(t *testing.T) {
			n, err := parseChunk(t, "if true", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.IfStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							&sourcecode.ParsingError{MissingBlock, UNTERMINATED_IF_STMT_MISSING_BLOCK},
							false,
							/*[]ast.Token{
								{Type: ast.IF_KEYWORD, Span: NodeSpan{0, 2}},
							},*/
						},
						Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 7}, nil, false},
							Value:    true,
						},
					},
				},
			}, n)
		})

		t.Run("multiline", func(t *testing.T) {
			n := mustparseChunk(t, "if true { \n }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.IfStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IF_KEYWORD, Span: NodeSpan{0, 2}},
							},*/
						},
						Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 7}, nil, false},
							Value:    true,
						},
						Consequent: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{8, 13},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{8, 9}},
									{Type: ast.NEWLINE, Span: NodeSpan{10, 11}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{12, 13}},
								},*/
							},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("if-else", func(t *testing.T) {
			n := mustparseChunk(t, "if true { } else {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.IfStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 19},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IF_KEYWORD, Span: NodeSpan{0, 2}},
								{Type: ast.ELSE_KEYWORD, Span: NodeSpan{12, 16}},
							},*/
						}, Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 7}, nil, false},
							Value:    true,
						},
						Consequent: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{8, 11},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{8, 9}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{10, 11}},
								},*/
							},
							Statements: nil,
						},
						Alternate: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{17, 19},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{17, 18}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{18, 19}},
								},*/
							},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("if-else within an if-else statement", func(t *testing.T) {
			n := mustparseChunk(t, "if true { if true {} else {} } else {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 38}, nil, false},
				Statements: []ast.Node{
					&ast.IfStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 38},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IF_KEYWORD, Span: NodeSpan{0, 2}},
								{Type: ast.ELSE_KEYWORD, Span: NodeSpan{31, 35}},
							},*/
						},
						Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 7}, nil, false},
							Value:    true,
						},
						Consequent: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{8, 30},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{8, 9}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{29, 30}},
								},*/
							},
							Statements: []ast.Node{
								&ast.IfStatement{
									NodeBase: ast.NodeBase{
										NodeSpan{10, 28},
										nil,
										false,
										/*[]ast.Token{
											{Type: ast.IF_KEYWORD, Span: NodeSpan{10, 12}},
											{Type: ast.ELSE_KEYWORD, Span: NodeSpan{21, 25}},
										},*/
									},
									Test: &ast.BooleanLiteral{
										NodeBase: ast.NodeBase{NodeSpan{13, 17}, nil, false},
										Value:    true,
									},
									Consequent: &ast.Block{
										NodeBase: ast.NodeBase{
											NodeSpan{18, 20},
											nil,
											false,
											/*[]ast.Token{
												{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{18, 19}},
												{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{19, 20}},
											},*/
										},
										Statements: nil,
									},
									Alternate: &ast.Block{
										NodeBase: ast.NodeBase{
											NodeSpan{26, 28},
											nil,
											false,
											/*[]ast.Token{
												{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{26, 27}},
												{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{27, 28}},
											},*/
										},
										Statements: nil,
									},
								},
							},
						},
						Alternate: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{36, 38},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{36, 37}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{37, 38}},
								},*/
							},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("(multiline) if-else within an if-else statement", func(t *testing.T) {
			n := mustparseChunk(t, `
				if a {
					if true {

					} else {
						false
					}
				} else {
					b
				}
			`)

			outerIfStmt := n.Statements[0].(*ast.IfStatement)
			assert.IsType(t, &ast.IdentifierLiteral{}, outerIfStmt.Test)
			assert.IsType(t, &ast.IdentifierLiteral{}, outerIfStmt.Alternate.(*ast.Block).Statements[0])

			innerIfStmt := ast.FindNode(outerIfStmt, &ast.IfStatement{}, nil)
			assert.IsType(t, &ast.BooleanLiteral{}, innerIfStmt.Test)
			assert.IsType(t, &ast.BooleanLiteral{}, innerIfStmt.Alternate.(*ast.Block).Statements[0])
		})

		t.Run("if-else-if", func(t *testing.T) {
			n := mustparseChunk(t, "if true { } else if true {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
				Statements: []ast.Node{
					&ast.IfStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 27}}, Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 7}, nil, false},
							Value:    true,
						},
						Consequent: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{8, 11}},
							Statements: nil,
						},
						Alternate: &ast.IfStatement{
							NodeBase: ast.NodeBase{Span: NodeSpan{17, 27}}, Test: &ast.BooleanLiteral{
								NodeBase: ast.NodeBase{NodeSpan{20, 24}, nil, false},
								Value:    true,
							},
							Consequent: &ast.Block{
								NodeBase: ast.NodeBase{Span: NodeSpan{25, 27}},
							},
						},
					},
				},
			}, n)
		})

		t.Run("if-else-if<ident char>", func(t *testing.T) {
			n, err := parseChunk(t, "if true { } else if9", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.IfStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							&sourcecode.ParsingError{MissingBlock, fmtUnterminatedIfStmtElseShouldBeFollowedByBlock('i')},
							false,
						},
						Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 7}, nil, false},
							Value:    true,
						},
						Consequent: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{8, 11}},
							Statements: nil,
						},
					},
					&ast.IdentifierLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{17, 20}},
						Name:     "if9",
					},
				},
			}, n)
		})
	})

	t.Run("if expression", func(t *testing.T) {

		t.Run("(if <test> <consequent>)", func(t *testing.T) {
			n := mustparseChunk(t, "(if true 1)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.IfExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							nil,
							true,
						}, Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
							Value:    true,
						},
						Consequent: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "1",
							Value:    1,
						},
					},
				},
			}, n)
		})

		t.Run("(if <test> (missing value)", func(t *testing.T) {
			code := "(if true"

			n, err := parseChunk(t, code, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.IfExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 8},
							nil,
							true,
						}, Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
							Value:    true,
						},
						Consequent: &ast.MissingExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{7, 8},
								&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune(code), 8, true)},
								false,
							},
						},
					},
				},
			}, n)
		})

		t.Run("(if <test> <consequent> (missing parenthesis)", func(t *testing.T) {
			n, err := parseChunk(t, "(if true 1", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.IfExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 10},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_IF_EXPR_IF_CLAUSE_SHOULD_BE_FOLLOWED_BY_CLOSING_PAREN_OR_ELSE_CLAUSE},
							true,
						}, Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
							Value:    true,
						},
						Consequent: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "1",
							Value:    1,
						},
					},
				},
			}, n)
		})

		t.Run("in list literal: (if <test> <consequent> (missing parenthesis)", func(t *testing.T) {
			n, err := parseChunk(t, "[(if true 1]", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.ListLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
						Elements: []ast.Node{
							&ast.IfExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 11},
									&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_IF_EXPR_IF_CLAUSE_SHOULD_BE_FOLLOWED_BY_CLOSING_PAREN_OR_ELSE_CLAUSE},
									true,
								}, Test: &ast.BooleanLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 9}, nil, false},
									Value:    true,
								},
								Consequent: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("(if <test> <consequent> else <alternate>)", func(t *testing.T) {
			n := mustparseChunk(t, "(if true 1 else 2)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.IfExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 18},
							nil,
							true,
						}, Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
							Value:    true,
						},
						Consequent: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "1",
							Value:    1,
						},
						Alternate: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
							Raw:      "2",
							Value:    2,
						},
					},
				},
			}, n)
		})

		t.Run("(if <test> <consequent> else <alternate> (missing parenthesis)", func(t *testing.T) {
			n, err := parseChunk(t, "(if true 1 else 2", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.IfExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 17},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_IF_EXPR_IF_CLAUSE_SHOULD_BE_FOLLOWED_BY_CLOSING_PAREN_OR_ELSE_CLAUSE},
							true,
						}, Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
							Value:    true,
						},
						Consequent: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "1",
							Value:    1,
						},
						Alternate: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
							Raw:      "2",
							Value:    2,
						},
					},
				},
			}, n)
		})

		t.Run("(if <test> <consequent> else (missing value)", func(t *testing.T) {
			code := "(if true 1 else"
			n, err := parseChunk(t, code, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.IfExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 15},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_IF_EXPR_IF_CLAUSE_SHOULD_BE_FOLLOWED_BY_CLOSING_PAREN_OR_ELSE_CLAUSE},
							true,
						}, Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
							Value:    true,
						},
						Consequent: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "1",
							Value:    1,
						},
						Alternate: &ast.MissingExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{14, 15},
								&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune(code), 15, true)},
								false,
							},
						},
					},
				},
			}, n)
		})

		t.Run("in list literal: (if <test> <consequent> else (missing value)", func(t *testing.T) {
			code := "[(if true 1 else]"
			n, err := parseChunk(t, code, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.ListLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 17}},
						Elements: []ast.Node{
							&ast.IfExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 16},
									&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_IF_EXPR_IF_CLAUSE_SHOULD_BE_FOLLOWED_BY_CLOSING_PAREN_OR_ELSE_CLAUSE},
									true,
								}, Test: &ast.BooleanLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 9}, nil, false},
									Value:    true,
								},
								Consequent: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Raw:      "1",
									Value:    1,
								},
								Alternate: &ast.MissingExpression{
									NodeBase: ast.NodeBase{
										NodeSpan{16, 17},
										&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune(code), 16, true)},
										false,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("(if <test> <consequent> <incomplete else> (missing parenthesis)", func(t *testing.T) {
			n, err := parseChunk(t, "(if true 1 el", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.IfExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_IF_EXPR_IF_CLAUSE_SHOULD_BE_FOLLOWED_BY_CLOSING_PAREN_OR_ELSE_CLAUSE},
							true,
						}, Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
							Value:    true,
						},
						Consequent: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "1",
							Value:    1,
						},
						Alternate: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{11, 13}, nil, false},
							Name:     "el",
						},
					},
				},
			}, n)
		})

		t.Run("in list literal: (if <test> <consequent> <incomplete else> (missing parenthesis)", func(t *testing.T) {
			code := "[(if true 1 el]"
			n, err := parseChunk(t, code, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.ListLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 15}},
						Elements: []ast.Node{
							&ast.IfExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 14},
									&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_IF_EXPR_IF_CLAUSE_SHOULD_BE_FOLLOWED_BY_CLOSING_PAREN_OR_ELSE_CLAUSE},
									true,
								}, Test: &ast.BooleanLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 9}, nil, false},
									Value:    true,
								},
								Consequent: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Raw:      "1",
									Value:    1,
								},
								Alternate: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 14}, nil, false},
									Name:     "el",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("(if <test> <consequent> <incomplete else>", func(t *testing.T) {
			n, err := parseChunk(t, "(if true 1 el)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.IfExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 14},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_IF_EXPR_IF_CLAUSE_SHOULD_BE_FOLLOWED_BY_CLOSING_PAREN_OR_ELSE_CLAUSE},
							true,
						}, Test: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
							Value:    true,
						},
						Consequent: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "1",
							Value:    1,
						},
						Alternate: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{11, 13}, nil, false},
							Name:     "el",
						},
					},
				},
			}, n)
		})

	})

	t.Run("for statement", func(t *testing.T) {
		t.Run("empty for <index>, <elem> ... in statement", func(t *testing.T) {
			n := mustparseChunk(t, "for i, u in $users { }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.ForStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 22}},
						KeyIndexIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
							Name:     "i",
						},
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{12, 18}, nil, false},
							Name:     "users",
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{19, 22}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("empty for <index pattern> <index>, <elem> ... in statement", func(t *testing.T) {
			n := mustparseChunk(t, "for %even i, u in $users { }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.ForStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 28}},
						KeyPattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 9}, nil, false},
							Name:     "even",
						},
						KeyIndexIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
							Name:     "i",
						},
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{18, 24}, nil, false},
							Name:     "users",
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{25, 28}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("empty for <index pattern> <index>, <elem pattern> <elem> ... in statement", func(t *testing.T) {
			n := mustparseChunk(t, "for %even i, %p u in $users { }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
				Statements: []ast.Node{
					&ast.ForStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 31}},
						KeyPattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 9}, nil, false},
							Name:     "even",
						},
						KeyIndexIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
							Name:     "i",
						},
						ValuePattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{13, 15}, nil, false},
							Name:     "p",
						},
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{21, 27}, nil, false},
							Name:     "users",
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{28, 31}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("empty for <index>, <elem pattern> <elem> ... in statement", func(t *testing.T) {
			n := mustparseChunk(t, "for i, %p u in $users { }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.ForStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 25}},
						KeyIndexIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
							Name:     "i",
						},
						ValuePattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
							Name:     "p",
						},
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{15, 21}, nil, false},
							Name:     "users",
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{22, 25}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("empty for <elem> ... in statement", func(t *testing.T) {
			n := mustparseChunk(t, "for u in $users { }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.ForStatement{
						NodeBase: ast.NodeBase{
							Span: NodeSpan{0, 19},
						},
						KeyIndexIdent: nil,
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{9, 15}, nil, false},
							Name:     "users",
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{16, 19}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("empty for <elem> ... in chunked statement", func(t *testing.T) {
			n := mustparseChunk(t, "for chunked u in $users { }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
				Statements: []ast.Node{
					&ast.ForStatement{
						NodeBase:      ast.NodeBase{Span: NodeSpan{0, 27}},
						KeyIndexIdent: nil,
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
							Name:     "u",
						},
						Chunked: true,
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{17, 23}, nil, false},
							Name:     "users",
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{24, 27}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("for .. in with break statement", func(t *testing.T) {
			n := mustparseChunk(t, "for i, u in $users { break }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.ForStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 28}},
						KeyIndexIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
							Name:     "i",
						},
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{12, 18}, nil, false},
							Name:     "users",
						},
						Body: &ast.Block{
							NodeBase: ast.NodeBase{Span: NodeSpan{19, 28}},
							Statements: []ast.Node{
								&ast.BreakStatement{
									NodeBase: ast.NodeBase{
										NodeSpan{21, 26},
										nil,
										false,
									},
									Label: nil,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("for .. in with continue statement", func(t *testing.T) {
			n := mustparseChunk(t, "for i, u in $users { continue }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
				Statements: []ast.Node{
					&ast.ForStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 31}},
						KeyIndexIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
							Name:     "i",
						},
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{12, 18}, nil, false},
							Name:     "users",
						},
						Body: &ast.Block{
							NodeBase: ast.NodeBase{Span: NodeSpan{19, 31}},
							Statements: []ast.Node{
								&ast.ContinueStatement{
									NodeBase: ast.NodeBase{
										NodeSpan{21, 29},
										nil,
										false,
									},
									Label: nil,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("for <expr>", func(t *testing.T) {
			n := mustparseChunk(t, "for $array { }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.ForStatement{
						NodeBase:       ast.NodeBase{Span: NodeSpan{0, 14}},
						KeyIndexIdent:  nil,
						ValueElemIdent: nil,
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{4, 10}, nil, false},
							Name:     "array",
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{11, 14}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("for <pattern>", func(t *testing.T) {
			n := mustparseChunk(t, "for %p { }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.ForStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 10},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.FOR_KEYWORD, Span: NodeSpan{0, 3}},
							},*/
						},
						KeyIndexIdent:  nil,
						ValueElemIdent: nil,
						IteratedValue: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
							Name:     "p",
						},
						Body: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{7, 10},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{7, 8}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{9, 10}},
								},*/
							},
							Statements: nil,
						},
					},
				},
			}, n)
		})

	})

	t.Run("for expression", func(t *testing.T) {
		t.Run("for <index>, <elem> ... in", func(t *testing.T) {
			n := mustparseChunk(t, "(for i, u in $users => i)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.ForExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 25}, IsParenthesized: true},
						KeyIndexIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Name:     "i",
						},
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{13, 19}, nil, false},
							Name:     "users",
						},
						Body: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{23, 24}, nil, false},
							Name:     "i",
						},
					},
				},
			}, n)
		})

		t.Run("for <index pattern> <index>, <elem> ... in", func(t *testing.T) {
			n := mustparseChunk(t, "(for %even i, u in $users => i)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
				Statements: []ast.Node{
					&ast.ForExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 31}, IsParenthesized: true},
						KeyPattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 10}, nil, false},
							Name:     "even",
						},
						KeyIndexIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
							Name:     "i",
						},
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{19, 25}, nil, false},
							Name:     "users",
						},
						Body: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{29, 30}, nil, false},
							Name:     "i",
						},
					},
				},
			}, n)
		})

		t.Run("for <index pattern> <index>, <elem pattern> <elem> ... in", func(t *testing.T) {
			n := mustparseChunk(t, "(for %even i, %p u in $users => i)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 34}, nil, false},
				Statements: []ast.Node{
					&ast.ForExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 34}, IsParenthesized: true},
						KeyPattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 10}, nil, false},
							Name:     "even",
						},
						KeyIndexIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
							Name:     "i",
						},
						ValuePattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{14, 16}, nil, false},
							Name:     "p",
						},
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{22, 28}, nil, false},
							Name:     "users",
						},
						Body: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{32, 33}, nil, false},
							Name:     "i",
						},
					},
				},
			}, n)
		})

		t.Run("for <index>, <elem pattern> <elem> ... in", func(t *testing.T) {
			n := mustparseChunk(t, "(for i, %p u in $users => i)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.ForExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 28}, IsParenthesized: true},
						KeyIndexIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Name:     "i",
						},
						ValuePattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{8, 10}, nil, false},
							Name:     "p",
						},
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{16, 22}, nil, false},
							Name:     "users",
						},
						Body: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{26, 27}, nil, false},
							Name:     "i",
						},
					},
				},
			}, n)
		})

		t.Run("for <elem> ... in", func(t *testing.T) {
			n := mustparseChunk(t, "(for u in $users => i)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.ForExpression{
						NodeBase:      ast.NodeBase{Span: NodeSpan{0, 22}, IsParenthesized: true},
						KeyIndexIdent: nil,
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{10, 16}, nil, false},
							Name:     "users",
						},
						Body: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
							Name:     "i",
						},
					},
				},
			}, n)
		})

		t.Run("for <elem> ... in chunked", func(t *testing.T) {
			n := mustparseChunk(t, "(for chunked u in $users => u)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 30}, nil, false},
				Statements: []ast.Node{
					&ast.ForExpression{
						NodeBase:      ast.NodeBase{Span: NodeSpan{0, 30}, IsParenthesized: true},
						KeyIndexIdent: nil,
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
							Name:     "u",
						},
						Chunked: true,
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{18, 24}, nil, false},
							Name:     "users",
						},
						Body: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{28, 29}, nil, false},
							Name:     "u",
						},
					},
				},
			}, n)
		})

		t.Run("for <elem> ... in: unparenthesized binary expression", func(t *testing.T) {
			n := mustparseChunk(t, "(for u in $users => i + 1)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
				Statements: []ast.Node{
					&ast.ForExpression{
						NodeBase:      ast.NodeBase{Span: NodeSpan{0, 26}, IsParenthesized: true},
						KeyIndexIdent: nil,
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{10, 16}, nil, false},
							Name:     "users",
						},
						Body: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{NodeSpan{20, 25}, nil, false},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
								Name:     "i",
							},
							Right: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{24, 25}, nil, false},
								Raw:      "1",
								Value:    1,
							},
						},
					},
				},
			}, n)
		})

		t.Run("for <elem> ... in => unterminated unparenthesized binary expression", func(t *testing.T) {
			n, err := parseChunk(t, "(for u in $users => i + )", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.ForExpression{
						NodeBase:      ast.NodeBase{Span: NodeSpan{0, 25}, IsParenthesized: true},
						KeyIndexIdent: nil,
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{10, 16}, nil, false},
							Name:     "users",
						},
						Body: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{20, 24},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_BIN_EXPR_MISSING_RIGHT_OPERAND},
								false,
							},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
								Name:     "i",
							},
							Right: &ast.MissingExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{24, 25},
									&sourcecode.ParsingError{MissingExpr, "an expression was expected: ... i + <<here>>)..."},
									false,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized", func(t *testing.T) {
			n := mustparseChunk(t, "a = for i, u in $users => i")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "a",
						},
						Right: &ast.ForExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 27}},
							KeyIndexIdent: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Name:     "i",
							},
							ValueElemIdent: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
								Name:     "u",
							},
							IteratedValue: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{16, 22}, nil, false},
								Name:     "users",
							},
							Body: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{26, 27}, nil, false},
								Name:     "i",
							},
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized: as LHS of assignment + followed by newline", func(t *testing.T) {
			n := mustparseChunk(t, "a = for i, u in $users => i\n")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "a",
						},
						Right: &ast.ForExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 27}},
							KeyIndexIdent: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Name:     "i",
							},
							ValueElemIdent: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
								Name:     "u",
							},
							IteratedValue: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{16, 22}, nil, false},
								Name:     "users",
							},
							Body: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{26, 27}, nil, false},
								Name:     "i",
							},
						},
					},
				},
			}, n)
		})

		t.Run("missing value after arrow", func(t *testing.T) {
			n, err := parseChunk(t, "(for i, u in $users =>)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.ForExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 23}, IsParenthesized: true},
						KeyIndexIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Name:     "i",
						},
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{13, 19}, nil, false},
							Name:     "users",
						},
						Body: &ast.MissingExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{22, 23},
								&sourcecode.ParsingError{MissingExpr, "an expression was expected: ...rs =><<here>>)..."},
								false,
							},
						},
					},
				},
			}, n)
		})

		t.Run("missing closing parenthesis after item value", func(t *testing.T) {
			n, err := parseChunk(t, "(for i, u in $users => i", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.ForExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 24},
							&sourcecode.ParsingError{UnterminatedForExpr, UNTERMINATED_FOR_EXPR_MISSING_CLOSIN_PAREN},
							true,
						},
						KeyIndexIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Name:     "i",
						},
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{13, 19}, nil, false},
							Name:     "users",
						},
						Body: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{23, 24}, nil, false},
							Name:     "i",
						},
					},
				},
			}, n)
		})

		t.Run("empty block body", func(t *testing.T) {
			n := mustparseChunk(t, "(for i, u in $users {})")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.ForExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 23}, IsParenthesized: true},
						KeyIndexIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Name:     "i",
						},
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{13, 19}, nil, false},
							Name:     "users",
						},
						Body: &ast.Block{
							NodeBase: ast.NodeBase{NodeSpan{20, 22}, nil, false},
						},
					},
				},
			}, n)
		})

		t.Run("missing parenthesis after block body", func(t *testing.T) {
			n, err := parseChunk(t, "(for i, u in $users {}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.ForExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 22},
							&sourcecode.ParsingError{UnterminatedForExpr, UNTERMINATED_FOR_EXPR_MISSING_CLOSIN_PAREN},
							true,
						},
						KeyIndexIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Name:     "i",
						},
						ValueElemIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:     "u",
						},
						IteratedValue: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{13, 19}, nil, false},
							Name:     "users",
						},
						Body: &ast.Block{
							NodeBase: ast.NodeBase{NodeSpan{20, 22}, nil, false},
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized for expression are not supported in unparenthesized binary expressions", func(t *testing.T) {
			_, err := parseChunk(t, "a = 1 match for u in users {}", "")
			assert.Error(t, err)
		})
	})

	t.Run("walk statement", func(t *testing.T) {

		t.Run("empty", func(t *testing.T) {
			n := mustparseChunk(t, "walk ./ entry { }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.WalkStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 17},
							nil,
							false,
						},
						Walked: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 7}, nil, false},
							Raw:      "./",
							Value:    "./",
						},
						EntryIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{8, 13}, nil, false},
							Name:     "entry",
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{14, 17}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("meta & entry variable identifiers", func(t *testing.T) {
			n := mustparseChunk(t, "walk ./ meta, entry { }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.WalkStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 23}},
						Walked: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 7}, nil, false},
							Raw:      "./",
							Value:    "./",
						},
						MetaIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{8, 12}, nil, false},
							Name:     "meta",
						},
						EntryIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{14, 19}, nil, false},
							Name:     "entry",
						},
						Body: &ast.Block{
							NodeBase: ast.NodeBase{Span: NodeSpan{20, 23}},

							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("no walked value: EOF", func(t *testing.T) {
			n, err := parseChunk(t, "walk", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.WalkStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							&sourcecode.ParsingError{UnterminatedWalkStmt, UNTERMINATED_WALK_STMT_MISSING_WALKED_VALUE},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("no walked value: space", func(t *testing.T) {
			n, err := parseChunk(t, "walk ", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.WalkStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 5}},
						Walked: &ast.MissingExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{4, 5},
								&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("walk "), 5, true)},
								false,
							},
						},
					},
				},
			}, n)
		})

		t.Run("missing entry variable", func(t *testing.T) {
			n, err := parseChunk(t, "walk ./", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.WalkStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							&sourcecode.ParsingError{UnterminatedWalkStmt, UNTERMINATED_WALK_STMT_MISSING_ENTRY_VARIABLE_NAME},
							false,
						},
						Walked: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 7}, nil, false},
							Raw:      "./",
							Value:    "./",
						},
					},
				},
			}, n)
		})

		t.Run("missing body", func(t *testing.T) {
			n, err := parseChunk(t, "walk ./ entry", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.WalkStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							&sourcecode.ParsingError{UnterminatedWalkStmt, UNTERMINATED_WALK_STMT_MISSING_BODY},
							false,
						},
						Walked: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 7}, nil, false},
							Raw:      "./",
							Value:    "./",
						},
						EntryIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{8, 13}, nil, false},
							Name:     "entry",
						},
					},
				},
			}, n)
		})
	})

	t.Run("walk expression", func(t *testing.T) {

		t.Run("empty", func(t *testing.T) {
			n := mustparseChunk(t, "(walk ./ entry { })")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.WalkExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 19},
							IsParenthesized: true,
						},
						Walked: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
							Raw:      "./",
							Value:    "./",
						},
						EntryIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 14}, nil, false},
							Name:     "entry",
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{15, 18}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("meta & entry variable identifiers", func(t *testing.T) {
			n := mustparseChunk(t, "(walk ./ meta, entry { })")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.WalkExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 25}, IsParenthesized: true},
						Walked: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
							Raw:      "./",
							Value:    "./",
						},
						MetaIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 13}, nil, false},
							Name:     "meta",
						},
						EntryIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{15, 20}, nil, false},
							Name:     "entry",
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{21, 24}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized", func(t *testing.T) {
			n := mustparseChunk(t, "a = walk / entry {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "a",
						},
						Right: &ast.WalkExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 19}},
							Walked: &ast.AbsolutePathLiteral{
								NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
								Raw:      "/",
								Value:    "/",
							},
							EntryIdent: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{11, 16}, nil, false},
								Name:     "entry",
							},
							Body: &ast.Block{
								NodeBase:   ast.NodeBase{Span: NodeSpan{17, 19}},
								Statements: nil,
							},
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized: as LHS of assignment + followed by newline", func(t *testing.T) {
			n := mustparseChunk(t, "a = walk / entry {}\n")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "a",
						},
						Right: &ast.WalkExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 19}},
							Walked: &ast.AbsolutePathLiteral{
								NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
								Raw:      "/",
								Value:    "/",
							},
							EntryIdent: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{11, 16}, nil, false},
								Name:     "entry",
							},
							Body: &ast.Block{
								NodeBase:   ast.NodeBase{Span: NodeSpan{17, 19}},
								Statements: nil,
							},
						},
					},
				},
			}, n)
		})

		t.Run("no walked value: EOF", func(t *testing.T) {
			n, err := parseChunk(t, "(walk", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.WalkExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 5},
							&sourcecode.ParsingError{UnterminatedWalkExpr, UNTERMINATED_WALK_EXPR_MISSING_WALKED_VALUE},
							true,
						},
					},
				},
			}, n)
		})

		t.Run("no walked value: space", func(t *testing.T) {
			n, err := parseChunk(t, "(walk )", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.WalkExpression{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 7},
							Err:             &sourcecode.ParsingError{UnterminatedWalkExpr, UNTERMINATED_WALK_EXPR_MISSING_WALKED_VALUE},
							IsParenthesized: true,
						},
					},
				},
			}, n)
		})

		t.Run("missing entry variable", func(t *testing.T) {
			n, err := parseChunk(t, "(walk ./)", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.WalkExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							&sourcecode.ParsingError{UnterminatedWalkExpr, UNTERMINATED_WALK_EXPR_MISSING_ENTRY_VARIABLE_NAME},
							true,
						},
						Walked: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
							Raw:      "./",
							Value:    "./",
						},
					},
				},
			}, n)
		})

		t.Run("missing body", func(t *testing.T) {
			n, err := parseChunk(t, "(walk ./ entry)", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.WalkExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 15},
							&sourcecode.ParsingError{UnterminatedWalkExpr, UNTERMINATED_WALK_EXPR_MISSING_BODY},
							true,
						},
						Walked: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
							Raw:      "./",
							Value:    "./",
						},
						EntryIdent: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 14}, nil, false},
							Name:     "entry",
						},
					},
				},
			}, n)
		})
	})

	t.Run("unary expression", func(t *testing.T) {

		t.Run("unary expression : boolean negate", func(t *testing.T) {
			n := mustparseChunk(t, "!true")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.UnaryExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 5}},
						Operator: ast.BoolNegate,
						Operand: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{1, 5}, nil, false},
							Value:    true,
						},
					},
				},
			}, n)
		})

		t.Run("unary expression: number negation", func(t *testing.T) {
			n := mustparseChunk(t, "- 2")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.UnaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							nil,
							false,
						},
						Operator: ast.NumberNegate,
						Operand: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
							Raw:      "2",
							Value:    2,
						},
					},
				},
			}, n)
		})

		t.Run("unary expression: variable negation", func(t *testing.T) {
			n := mustparseChunk(t, "- a")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.UnaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							nil,
							false,
						},
						Operator: ast.NumberNegate,
						Operand: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
							Name:     "a",
						},
					},
				},
			}, n)
		})

		t.Run("unary expression: parenthesized number negation", func(t *testing.T) {
			n := mustparseChunk(t, "(- 2)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.UnaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 5},
							nil,
							true,
							/*[]ast.Token{
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{0, 1}},
								{Type: ast.MINUS, Span: NodeSpan{1, 2}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{4, 5}},
							},*/
						},
						Operator: ast.NumberNegate,
						Operand: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
							Raw:      "2",
							Value:    2,
						},
					},
				},
			}, n)
		})

	})

	t.Run("binary expressions", func(t *testing.T) {

		t.Run("OR(bin ex 1, bin ex 2)", func(t *testing.T) {
			n := mustparseChunk(t, "(a > b or c > d)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 16},
							nil,
							true,
						},
						Operator: ast.Or,
						Left: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
							Operator: ast.GreaterThan,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
								Name:     "a",
							},
							Right: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
								Name:     "b",
							},
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{10, 15},
								nil,
								false,
							},
							Operator: ast.GreaterThan,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
								Name:     "c",
							},
							Right: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
								Name:     "d",
							},
						},
					},
				},
			}, n)
		})

		t.Run("OR(bin ex 1, variable)", func(t *testing.T) {
			n := mustparseChunk(t, "(a > b or c)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							nil,
							true,
						},
						Operator: ast.Or,
						Left: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 6},
								nil,
								false,
							},
							Operator: ast.GreaterThan,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
								Name:     "a",
							},
							Right: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
								Name:     "b",
							},
						},
						Right: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
							Name:     "c",
						},
					},
				},
			}, n)
		})

		t.Run("OR(variable, bin ex)", func(t *testing.T) {
			n := mustparseChunk(t, "(a or b > c)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							nil,
							true,
						},
						Operator: ast.Or,
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{6, 11},
								nil,
								false,
							},
							Operator: ast.GreaterThan,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
								Name:     "b",
							},
							Right: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
								Name:     "c",
							},
						},
					},
				},
			}, n)
		})

		t.Run("OR(bin ex 1, bin ex 2, bin ex 3)", func(t *testing.T) {
			n := mustparseChunk(t, "(a > b or c > d or e > f)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 25},
							nil,
							true,
						},
						Operator: ast.Or,
						Left: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 6},
								nil,
								false,
							},
							Operator: ast.GreaterThan,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
								Name:     "a",
							},
							Right: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
								Name:     "b",
							},
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{10, 24}},
							Operator: ast.Or,
							Left: &ast.BinaryExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 16},
									nil,
									false,
								},
								Operator: ast.GreaterThan,
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "c",
								},
								Right: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Name:     "d",
								},
							},
							Right: &ast.BinaryExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{19, 24},
									nil,
									false,
								},
								Operator: ast.GreaterThan,
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
									Name:     "e",
								},
								Right: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{23, 24}, nil, false},
									Name:     "f",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("OR(var, bin ex 1, bin ex 2)", func(t *testing.T) {
			n := mustparseChunk(t, "(a or b > c or d > e)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 21},
							nil,
							true,
						},
						Operator: ast.Or,
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{6, 20},
								nil,
								false,
							},
							Operator: ast.Or,
							Left: &ast.BinaryExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{6, 12},
									nil,
									false,
								},
								Operator: ast.GreaterThan,
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Name:     "b",
								},
								Right: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "c",
								},
							},
							Right: &ast.BinaryExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{15, 20},
									nil,
									false,
								},
								Operator: ast.GreaterThan,
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
									Name:     "d",
								},
								Right: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
									Name:     "e",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("OR(var 1, var 2, bin ex 1)", func(t *testing.T) {
			mustparseChunk(t, "(a or b or c > d)")
			//TODO: after the parsing of the chain modify the resulting output
			//in order for the AST to have the following shape (possible errors in spans):

			// assert.EqualValues(t, &ast.Chunk{
			// 	NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
			// 	Statements: []ast.Node{
			// 		&ast.BinaryExpression{
			// 			NodeBase: ast.NodeBase{
			// 				NodeSpan{0, 17},
			// 				nil,
			// 				[]ast.Token{
			// 					{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{0, 1}},
			// 					{Type: ast.OR_KEYWORD, Span: NodeSpan{3, 5}},
			// 					{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{16, 17}},
			// 				},
			// 			},
			// 			Operator: ast.Or,
			// 			Left: &ast.IdentifierLiteral{
			// 				NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
			// 				Name:     "a",
			// 			},
			// 			Right: &ast.BinaryExpression{
			// 				NodeBase: ast.NodeBase{
			// 					NodeSpan{6, 20},
			// 					nil,
			// 					false,
			// 				},
			// 				Operator: ast.Or,
			// 				Left: &ast.IdentifierLiteral{
			// 					NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
			// 					Name:     "b",
			// 				},
			// 				Right: &ast.BinaryExpression{
			// 					NodeBase: ast.NodeBase{
			// 						NodeSpan{15, 20},
			// 						nil,
			// 						false,
			// 					},
			// 					Operator: ast.GreaterThan,
			// 					Left: &ast.IdentifierLiteral{
			// 						NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
			// 						Name:     "c",
			// 					},
			// 					Right: &ast.IdentifierLiteral{
			// 						NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
			// 						Name:     "d",
			// 					},
			// 				},
			// 			},
			// 		},
			// 	},
			// }, n)
		})

		t.Run("OR(bin ex 1, AND(bin ex 2, bin ex 3))", func(t *testing.T) {
			n, err := parseChunk(t, "(a > b or c > d and e > f)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 26},
							&sourcecode.ParsingError{UnspecifiedParsingError, BIN_EXPR_CHAIN_OPERATORS_SHOULD_BE_THE_SAME},
							true,
						},
						Operator: ast.Or,
						Left: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 6},
								nil,
								false,
							},
							Operator: ast.GreaterThan,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
								Name:     "a",
							},
							Right: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
								Name:     "b",
							},
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{10, 25}},
							Operator: ast.And,
							Left: &ast.BinaryExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 16},
									nil,
									false,
								},
								Operator: ast.GreaterThan,
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "c",
								},
								Right: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Name:     "d",
								},
							},
							Right: &ast.BinaryExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{20, 25},
									nil,
									false,
								},
								Operator: ast.GreaterThan,
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
									Name:     "e",
								},
								Right: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{24, 25}, nil, false},
									Name:     "f",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("OR(bin ex 1, AND(bin ex 2, bin ex 3), bin ex 4)", func(t *testing.T) {
			n, err := parseChunk(t, "(a > b or c > d and e > f or g > h)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 35}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 35},
							&sourcecode.ParsingError{UnspecifiedParsingError, BIN_EXPR_CHAIN_OPERATORS_SHOULD_BE_THE_SAME},
							true,
						},
						Operator: ast.Or,
						Left: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 6},
								nil,
								false,
							},
							Operator: ast.GreaterThan,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
								Name:     "a",
							},
							Right: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
								Name:     "b",
							},
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{10, 34},
								nil,
								false,
							},
							Operator: ast.And,
							Left: &ast.BinaryExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 16},
									nil,
									false,
								},
								Operator: ast.GreaterThan,
								Left: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "c",
								},
								Right: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Name:     "d",
								},
							},
							Right: &ast.BinaryExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{20, 34},
									nil,
									false,
								},
								Operator: ast.Or,
								Left: &ast.BinaryExpression{
									NodeBase: ast.NodeBase{
										NodeSpan{20, 26},
										nil,
										false,
									},
									Operator: ast.GreaterThan,
									Left: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
										Name:     "e",
									},
									Right: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{24, 25}, nil, false},
										Name:     "f",
									},
								},
								Right: &ast.BinaryExpression{
									NodeBase: ast.NodeBase{
										NodeSpan{29, 34},
										nil,
										false,
									},
									Operator: ast.GreaterThan,
									Left: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{29, 30}, nil, false},
										Name:     "g",
									},
									Right: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{33, 34}, nil, false},
										Name:     "h",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("OR(bin ex 1, ...missing operand ", func(t *testing.T) {
			n, err := parseChunk(t, "(a > b or", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							nil,
							true,
						},
						Operator: ast.Or,
						Left: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 6},
								nil,
								false,
							},
							Operator: ast.GreaterThan,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
								Name:     "a",
							},
							Right: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
								Name:     "b",
							},
						},
						Right: &ast.MissingExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{8, 9},
								&sourcecode.ParsingError{MissingExpr, "an expression was expected: ... b or<<here>>..."},
								false,
							},
						},
					},
				},
			}, n)
		})

		t.Run("OR(bin ex 1, bin ex 2 <missing parenthesis>", func(t *testing.T) {
			n, err := parseChunk(t, "(a > b or c > d", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 15},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_BIN_EXPR_MISSING_PAREN},
							true,
						},
						Operator: ast.Or,
						Left: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 6},
								nil,
								false,
							},
							Operator: ast.GreaterThan,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
								Name:     "a",
							},
							Right: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
								Name:     "b",
							},
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{10, 15},
								nil,
								false,
							},
							Operator: ast.GreaterThan,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
								Name:     "c",
							},
							Right: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
								Name:     "d",
							},
						},
					},
				},
			}, n)
		})

		t.Run("addition", func(t *testing.T) {
			n := mustparseChunk(t, "($a + $b)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							nil,
							true,
						},
						Operator: ast.Add,
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("addition with first operand being an unparenthesized number negation", func(t *testing.T) {
			n := mustparseChunk(t, "(-$a + $b)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 10},
							nil,
							true,
						},
						Operator: ast.Add,
						Left: &ast.UnaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{1, 4},
								nil,
								false,
							},
							Operator: ast.NumberNegate,
							Operand: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{2, 4}, nil, false},
								Name:     "a",
							},
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("addition with second operand being an unparenthesized number negation", func(t *testing.T) {
			n := mustparseChunk(t, "($a + -$b)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 10},
							nil,
							true,
						},
						Operator: ast.Add,
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Right: &ast.UnaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{6, 9},
								nil,
								false,
							},
							Operator: ast.NumberNegate,
							Operand: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("match with unprefixed pattern", func(t *testing.T) {
			n := mustparseChunk(t, "(o match {})")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							nil,
							true,
						},
						Operator: ast.Match,
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
							Name:     "o",
						},
						Right: &ast.ObjectPatternLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{9, 11}},
						},
					},
				},
			}, n)
		})

		t.Run("'as' with unprefixed pattern", func(t *testing.T) {
			n := mustparseChunk(t, "(o as {})")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							nil,
							true,
						},
						Operator: ast.As,
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
							Name:     "o",
						},
						Right: &ast.ObjectPatternLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{6, 8}},
						},
					},
				},
			}, n)
		})

		t.Run("range", func(t *testing.T) {
			n := mustparseChunk(t, "($a .. $b)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 10},
							nil,
							true,
						},
						Operator: ast.Range,
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("exclusive end range", func(t *testing.T) {
			n := mustparseChunk(t, "($a ..< $b)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							nil,
							true,
						},
						Operator: ast.ExclEndRange,
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{8, 10}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("pair comma: space around operator", func(t *testing.T) {
			n := mustparseChunk(t, "($a , $b)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							nil,
							true},
						Operator: ast.PairComma,
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("pair comma: space only before operator", func(t *testing.T) {
			n := mustparseChunk(t, "($a ,$b)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 8},
							nil,
							true,
						},
						Operator: ast.PairComma,
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{5, 7}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("pair comma: space only after operator", func(t *testing.T) {
			n := mustparseChunk(t, "($a, $b)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 8},
							nil,
							true,
						},
						Operator: ast.PairComma,
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{5, 7}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("pair comma: no space around operator", func(t *testing.T) {
			n := mustparseChunk(t, "($a,$b)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							nil,
							true,
						},
						Operator: ast.PairComma,
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("missing right operand", func(t *testing.T) {
			n, err := parseChunk(t, "($a +)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_BIN_EXPR_MISSING_RIGHT_OPERAND},
							true,
						},
						Operator: ast.Add,
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Right: &ast.MissingExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{5, 6},
								&sourcecode.ParsingError{MissingExpr, "an expression was expected: ...($a +<<here>>)..."},
								false,
							},
						},
					},
				},
			}, n)
		})
		t.Run("unexpected operator", func(t *testing.T) {
			n, err := parseChunk(t, "($a ? $b)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_BIN_EXPR_NON_EXISTING_OPERATOR},
							true,
						},
						Operator: -1,
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("unexpected operator starting like an existing one", func(t *testing.T) {
			n, err := parseChunk(t, "($a ! $b)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_BIN_EXPR_NON_EXISTING_OPERATOR},
							true,
						},
						Operator: -1,
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("unexpected operator starting like an existing one (no spaces)", func(t *testing.T) {
			n, err := parseChunk(t, "($a!$b)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_BIN_EXPR_NON_EXISTING_OPERATOR},
							true,
						},
						Operator: -1,
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("unexpected word operator : <and>e", func(t *testing.T) {
			n, err := parseChunk(t, "($a ande $b)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_BIN_EXPR_NON_EXISTING_OPERATOR},
							true,
						},
						Operator: -1,
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{9, 11}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("missing operator", func(t *testing.T) {
			n, err := parseChunk(t, "($a$b)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_BIN_EXPR_MISSING_OPERATOR},
							true,
						},
						Operator: -1,
						Left: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{1, 3}, nil, false},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{3, 5}, nil, false},
							Name:     "b",
						},
					},
				},
			}, n)
		})

		t.Run("+ chain", func(t *testing.T) {
			_, err := parseChunk(t, "(1 + 2 + 3)", "")
			assert.ErrorContains(t, err, COMPLEX_OPERANDS_OF_BINARY_EXPRS_MUST_BE_PARENTHESIZED)
		})

		t.Run("only opening parenthesis", func(t *testing.T) {
			n, err := parseChunk(t, "(", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
				Statements: []ast.Node{
					&ast.UnknownNode{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 1},
							&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("("), 1, true)},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("opening parenthesis followed by line feed", func(t *testing.T) {
			n, err := parseChunk(t, "(\n", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.UnknownNode{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 2},
							&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("(\n"), 2, true)},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("opening parenthesis followed by an unexpected character", func(t *testing.T) {
			n, err := parseChunk(t, "(;", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.UnknownNode{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 2},
							&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInParenthesizedExpression(';')},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("missing expression in between parenthesis", func(t *testing.T) {
			n, err := parseChunk(t, "()", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.UnknownNode{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 2},
							&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("()"), 1, true)},
							true,
						},
					},
				},
			}, n)
		})

	})

	t.Run("unparenthesized binary expressions", func(t *testing.T) {

		t.Run("addition", func(t *testing.T) {
			n := mustparseChunk(t, "a = $a + $b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 11}},
							Operator: ast.Add,
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
								Name:     "a",
							},
							Right: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{9, 11}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("+<letter> should not be confused with an unquoted string", func(t *testing.T) {
			n := mustparseChunk(t, "a = a +b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 8}},
							Operator: ast.Add,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
								Name:     "a",
							},
							Right: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("-<letter> should not be confused with an option  name", func(t *testing.T) {
			n := mustparseChunk(t, "a = a -b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 8}},
							Operator: ast.Sub,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
								Name:     "a",
							},
							Right: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("/<letter> should not be confused with a path", func(t *testing.T) {
			n := mustparseChunk(t, "a = a /b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 8}},
							Operator: ast.Div,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
								Name:     "a",
							},
							Right: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("addition with first operand being an unparenthesized number negation", func(t *testing.T) {
			n := mustparseChunk(t, "a = -$a + $b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 12}},
							Operator: ast.Add,
							Left: &ast.UnaryExpression{
								NodeBase: ast.NodeBase{Span: NodeSpan{4, 7}},
								Operator: ast.NumberNegate,
								Operand: &ast.Variable{
									NodeBase: ast.NodeBase{NodeSpan{5, 7}, nil, false},
									Name:     "a",
								},
							},
							Right: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{10, 12}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("addition with second operand being an unparenthesized number negation", func(t *testing.T) {
			n := mustparseChunk(t, "a = $a + -$b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 12}},
							Operator: ast.Add,
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
								Name:     "a",
							},
							Right: &ast.UnaryExpression{
								NodeBase: ast.NodeBase{Span: NodeSpan{9, 12}},
								Operator: ast.NumberNegate,
								Operand: &ast.Variable{
									NodeBase: ast.NodeBase{NodeSpan{10, 12}, nil, false},
									Name:     "b",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("match with unprefixed pattern", func(t *testing.T) {
			n := mustparseChunk(t, "a = o match {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 14}},
							Operator: ast.Match,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
								Name:     "o",
							},
							Right: &ast.ObjectPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 14}},
							},
						},
					},
				},
			}, n)
		})

		t.Run("'as' with unprefixed pattern", func(t *testing.T) {
			n := mustparseChunk(t, "a = o as {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 11}},
							Operator: ast.As,
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
								Name:     "o",
							},
							Right: &ast.ObjectPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{9, 11}},
							},
						},
					},
				},
			}, n)
		})

		t.Run("range", func(t *testing.T) {
			n := mustparseChunk(t, "a = $a .. $b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 12}},
							Operator: ast.Range,
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
								Name:     "a",
							},
							Right: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{10, 12}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("exclusive end range", func(t *testing.T) {
			n := mustparseChunk(t, "a = $a ..< $b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 13}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 13}},
							Operator: ast.ExclEndRange,
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
								Name:     "a",
							},
							Right: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{11, 13}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("missing right operand", func(t *testing.T) {
			n, err := parseChunk(t, "a = $a +", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{4, 8},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_BIN_EXPR_MISSING_RIGHT_OPERAND},
								false,
							},
							Operator: ast.Add,
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
								Name:     "a",
							},
							Right: &ast.MissingExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{7, 8},
									&sourcecode.ParsingError{MissingExpr, "an expression was expected: ... $a +<<here>>..."},
									false,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unexpected operator", func(t *testing.T) {
			n, err := parseChunk(t, "a = $a ? $b", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{4, 11},
								&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_BIN_EXPR_NON_EXISTING_OPERATOR},
								false,
							},
							Operator: -1,
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
								Name:     "a",
							},
							Right: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{9, 11}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("unexpected operator starting like an existing one", func(t *testing.T) {
			n, err := parseChunk(t, "a = $a ! $b", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{4, 11},
								&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_BIN_EXPR_NON_EXISTING_OPERATOR},
								false,
							},
							Operator: -1,
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
								Name:     "a",
							},
							Right: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{9, 11}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("unexpected operator starting like an existing one (no spaces)", func(t *testing.T) {
			n, err := parseChunk(t, "a = $a!$b", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.BinaryExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{4, 9},
								&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_BIN_EXPR_NON_EXISTING_OPERATOR},
								false,
							},
							Operator: -1,
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
								Name:     "a",
							},
							Right: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("unexpected keyword operator : <and>e", func(t *testing.T) {
			n, err := parseChunk(t, "a = $a ande $b", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							&sourcecode.ParsingError{InvalidNext, UNTERMINATED_ASSIGNMENT_MISSING_TERMINATOR},
							false,
						},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
							Name:     "a",
						},
					},
					&ast.CallExpression{
						NodeBase: ast.NodeBase{NodeSpan{7, 14}, nil, false},
						Callee: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 11}, nil, false},
							Name:     "ande",
						},
						Must:              true,
						CommandLikeSyntax: true,
						Arguments: []ast.Node{
							&ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{12, 14}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("missing operator", func(t *testing.T) {
			n, err := parseChunk(t, "a = $a$b", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.Assignment{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							&sourcecode.ParsingError{InvalidNext, UNTERMINATED_ASSIGNMENT_MISSING_TERMINATOR},
							false,
						},
						Left: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 1}},
							Name:     "a",
						},
						Right: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
							Name:     "a",
						},
					},
					&ast.Variable{
						NodeBase: ast.NodeBase{NodeSpan{6, 8}, nil, false},
						Name:     "b",
					},
				},
			}, n)
		})

		t.Run("+ chain", func(t *testing.T) {
			_, err := parseChunk(t, "a = 1 + 2 + 3", "")
			assert.ErrorContains(t, err, COMPLEX_OPERANDS_OF_BINARY_EXPRS_MUST_BE_PARENTHESIZED)
		})

		t.Run("bad and special cases", func(t *testing.T) {
			chunk, err := parseChunk(t, "a + b", "") //ok (call)
			assert.NoError(t, err)
			assert.NotNil(t, chunk)

			chunk, err = parseChunk(t, "a +", "") //ok (call)
			assert.NoError(t, err)
			assert.NotNil(t, chunk)

			chunk, err = parseChunk(t, "{a: 1 + 2 + 3}", "")
			assert.Error(t, err)
			assert.NotNil(t, chunk)

			chunk, err = parseChunk(t, "{a: 1 +}", "")
			assert.Error(t, err)
			assert.NotNil(t, chunk)

			chunk, err = parseChunk(t, "(switch 1 { 1 =})", "")
			assert.Error(t, err)
			assert.NotNil(t, chunk)

			chunk, err = parseChunk(t, "concat a b ?? c", "")
			assert.Error(t, err)
			assert.NotNil(t, chunk)

			chunk, err = parseChunk(t, "concat a ?? b c", "")
			assert.Error(t, err)
			assert.NotNil(t, chunk)
		})
	})

	t.Run("runtime typecheck expression", func(t *testing.T) {

		t.Run("variable", func(t *testing.T) {
			n := mustparseChunk(t, "~a")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.RuntimeTypeCheckExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 2}},
						Expr: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{1, 2}, nil, false},
							Name:     "a",
						},
					},
				},
			}, n)
		})

		t.Run("missing expression", func(t *testing.T) {
			n, err := parseChunk(t, "~", "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
				Statements: []ast.Node{
					&ast.RuntimeTypeCheckExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 1},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.TILDE, Span: NodeSpan{0, 1}},
							},*/
						},
						Expr: &ast.MissingExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 1},
								&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("~"), 1, true)},
								false,
							},
						},
					},
				},
			}, n)
		})

	})

	t.Run("upper bound range expression", func(t *testing.T) {
		t.Run("integer", func(t *testing.T) {
			n := mustparseChunk(t, "..10")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.UpperBoundRangeExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							nil,
							false,
						},
						UpperBound: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{2, 4}, nil, false},
							Raw:      "10",
							Value:    10,
						},
					},
				},
			}, n)
		})

		t.Run("upper-bound expression should not start with '.'", func(t *testing.T) {
			n, err := parseChunk(t, ".../", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.UpperBoundRangeExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_UPPER_BOUND_RANGE_EXPR},
							false,
						},
						UpperBound: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{NodeSpan{2, 4}, nil, false},
							Raw:      "./",
							Value:    "./",
						},
					},
				},
			}, n)
		})
	})

	t.Run("integer range literal", func(t *testing.T) {
		t.Run("ok", func(t *testing.T) {
			n := mustparseChunk(t, "1..2")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.IntegerRangeLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						LowerBound: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Raw:      "1",
							Value:    1,
						},
						UpperBound: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
							Raw:      "2",
							Value:    2,
						},
					},
				},
			}, n)
		})

		t.Run("no upper bound", func(t *testing.T) {
			n := mustparseChunk(t, "1..")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.IntegerRangeLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
						LowerBound: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Raw:      "1",
							Value:    1,
						},
					},
				},
			}, n)
		})

		t.Run("invalid upper bound", func(t *testing.T) {
			n, err := parseChunk(t, "1..$a", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.IntegerRangeLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 5},
							&sourcecode.ParsingError{UnspecifiedParsingError, UPPER_BOUND_OF_INT_RANGE_LIT_SHOULD_BE_INT_LIT},
							false,
						},
						LowerBound: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Raw:      "1",
							Value:    1,
						},
						UpperBound: &ast.Variable{
							NodeBase: ast.NodeBase{Span: NodeSpan{3, 5}},
							Name:     "a",
						},
					},
				},
			}, n)
		})
	})

	t.Run("float range literal", func(t *testing.T) {
		t.Run("ok", func(t *testing.T) {
			n := mustparseChunk(t, "1.0..2.0")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.FloatRangeLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
						LowerBound: &ast.FloatLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
							Raw:      "1.0",
							Value:    1.0,
						},
						UpperBound: &ast.FloatLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 8}, nil, false},
							Raw:      "2.0",
							Value:    2.0,
						},
					},
				},
			}, n)
		})

		t.Run("no upper bound", func(t *testing.T) {
			n := mustparseChunk(t, "1.0..")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.FloatRangeLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						LowerBound: &ast.FloatLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
							Raw:      "1.0",
							Value:    1.0,
						},
					},
				},
			}, n)
		})

		t.Run("invalid upper bound", func(t *testing.T) {
			n, err := parseChunk(t, "1.0..$a", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.FloatRangeLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							&sourcecode.ParsingError{UnspecifiedParsingError, UPPER_BOUND_OF_FLOAT_RANGE_LIT_SHOULD_BE_FLOAT_LIT},
							false,
						},
						LowerBound: &ast.FloatLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
							Raw:      "1.0",
							Value:    1.0,
						},
						UpperBound: &ast.Variable{
							NodeBase: ast.NodeBase{Span: NodeSpan{5, 7}},
							Name:     "a",
						},
					},
				},
			}, n)
		})
	})

	t.Run("quantity range literal", func(t *testing.T) {
		t.Run("ok", func(t *testing.T) {
			n := mustparseChunk(t, "1x..2x")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.QuantityRangeLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						LowerBound: &ast.QuantityLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Raw:      "1x",
							Values:   []float64{1},
							Units:    []string{"x"},
						},
						UpperBound: &ast.QuantityLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 6}, nil, false},
							Raw:      "2x",
							Values:   []float64{2},
							Units:    []string{"x"},
						},
					},
				},
			}, n)
		})

		t.Run("no upper bound", func(t *testing.T) {
			n := mustparseChunk(t, "1x..")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.QuantityRangeLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							nil,
							false,
						},
						LowerBound: &ast.QuantityLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Raw:      "1x",
							Values:   []float64{1},
							Units:    []string{"x"},
						},
					},
				},
			}, n)
		})

		t.Run("invalid upper bound", func(t *testing.T) {
			n, err := parseChunk(t, "1x..$a", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.QuantityRangeLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							&sourcecode.ParsingError{UnspecifiedParsingError, UPPER_BOUND_OF_QTY_RANGE_LIT_SHOULD_BE_QTY_LIT},
							false,
						},
						LowerBound: &ast.QuantityLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Raw:      "1x",
							Values:   []float64{1},
							Units:    []string{"x"},
						},
						UpperBound: &ast.Variable{
							NodeBase: ast.NodeBase{Span: NodeSpan{4, 6}},
							Name:     "a",
						},
					},
				},
			}, n)
		})

	})

	t.Run("rune range expression", func(t *testing.T) {
		t.Run("rune range expression", func(t *testing.T) {
			n := mustparseChunk(t, "'a'..'z'")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.RuneRangeExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
						Lower: &ast.RuneLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
							Value:    'a',
						},
						Upper: &ast.RuneLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 8}, nil, false},
							Value:    'z',
						},
					},
				},
			}, n)
		})

		//TODO: improve tests
		t.Run("invalid rune range expression : <rune> '.'", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, "'a'.")
			})
		})

		t.Run("invalid rune range expression : <rune> '.' '.' ", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, "'a'..")
			})
		})
	})

	t.Run("function expression", func(t *testing.T) {
		t.Run("no parameters, no manifest, empty body", func(t *testing.T) {
			n := mustparseChunk(t, "fn(){}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase:   ast.NodeBase{Span: NodeSpan{0, 6}},
						Parameters: nil,
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{4, 6}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("no parameters, no manifest, empty body, return type", func(t *testing.T) {
			n := mustparseChunk(t, "fn() %int {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase:   ast.NodeBase{Span: NodeSpan{0, 12}},
						Parameters: nil,
						ReturnType: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 9}, nil, false},
							Name:     "int",
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{10, 12}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("no parameters, no manifest, empty body, return type is an unprefixed pattern identifier", func(t *testing.T) {
			n := mustparseChunk(t, "fn() int {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase:   ast.NodeBase{Span: NodeSpan{0, 11}},
						Parameters: nil,
						ReturnType: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{5, 8}, nil, false},
							Unprefixed: true,
							Name:       "int",
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{9, 11}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("no parameters, no manifest, empty body, return type is an unprefixed regexp", func(t *testing.T) {
			n := mustparseChunk(t, "fn() `a+` {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase:   ast.NodeBase{Span: NodeSpan{0, 12}},
						Parameters: nil,
						ReturnType: &ast.RegularExpressionLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{5, 9}, nil, false},
							Raw:        "`a+`",
							Value:      "a+",
							Unprefixed: true,
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{10, 12}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("various accepted return types", func(t *testing.T) {
			_, err := parseChunk(t, "fn() [int] {}", "")
			assert.NoError(t, err)

			_, err = parseChunk(t, "fn() #[int] {}", "")
			assert.NoError(t, err)

			_, err = parseChunk(t, "fn() #{a: int} {}", "")
			assert.NoError(t, err)
		})

		t.Run("no parameters, empty capture list, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "fn[](){}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase:    ast.NodeBase{Span: NodeSpan{0, 8}},
						CaptureList: nil,
						Parameters:  nil,
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{6, 8}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("no parameters, capture list with single identifier, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "fn[a](){}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
						CaptureList: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Name:     "a",
							},
						},
						Parameters: nil,
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{7, 9}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("no parameters, capture list with two identifiers, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "fn[a,b](){}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
						CaptureList: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Name:     "a",
							},
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
								Name:     "b",
							},
						},
						Parameters: nil,
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{9, 11}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("no parameters, capture list with unexpected char, empty body ", func(t *testing.T) {
			n, err := parseChunk(t, "fn[?](){}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
						CaptureList: []ast.Node{
							&ast.UnknownNode{
								NodeBase: ast.NodeBase{
									NodeSpan{3, 4},
									&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInCaptureList('?')},
									false,
								},
							},
						},
						Parameters: nil,
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{7, 9}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("single parameter, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "fn(x){}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Name:     "x",
								},
							},
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{5, 7}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("single unquoted parameter, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "@(fn(<{a}>){})")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
						Expression: &ast.FunctionExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{2, 13}, IsParenthesized: true},
							Parameters: []*ast.FunctionParameter{
								{
									NodeBase: ast.NodeBase{NodeSpan{5, 10}, nil, false},
									Var: &ast.UnquotedRegion{
										NodeBase: ast.NodeBase{NodeSpan{5, 10}, nil, false},
										Expression: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
											Name:     "a",
										},
									},
								},
							},
							Body: &ast.Block{
								NodeBase:   ast.NodeBase{Span: NodeSpan{11, 13}},
								Statements: nil,
							},
						},
					},
				},
			}, n)
		})

		t.Run("single typed parameter, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "fn(x %int){}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{NodeSpan{3, 9}, nil, false},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Name:     "x",
								},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 9}, nil, false},
									Name:     "int",
								},
							},
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{10, 12}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("single typed parameter with unquoted name, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "@(fn(<{a}> %int){})")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 19}},
						Expression: &ast.FunctionExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{2, 18}, IsParenthesized: true},
							Parameters: []*ast.FunctionParameter{
								{
									NodeBase: ast.NodeBase{NodeSpan{5, 15}, nil, false},
									Var: &ast.UnquotedRegion{
										NodeBase: ast.NodeBase{NodeSpan{5, 10}, nil, false},
										Expression: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
											Name:     "a",
										},
									},
									Type: &ast.PatternIdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{11, 15}, nil, false},
										Name:     "int",
									},
								},
							},
							Body: &ast.Block{
								NodeBase:   ast.NodeBase{Span: NodeSpan{16, 18}},
								Statements: nil,
							},
						},
					},
				},
			}, n)
		})

		t.Run("single typed parameter with unquoted name and type, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "@(fn(<{a}> <{b}>){})")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
						Expression: &ast.FunctionExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{2, 19}, IsParenthesized: true},
							Parameters: []*ast.FunctionParameter{
								{
									NodeBase: ast.NodeBase{NodeSpan{5, 16}, nil, false},
									Var: &ast.UnquotedRegion{
										NodeBase: ast.NodeBase{NodeSpan{5, 10}, nil, false},
										Expression: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
											Name:     "a",
										},
									},
									Type: &ast.UnquotedRegion{
										NodeBase: ast.NodeBase{NodeSpan{11, 16}, nil, false},
										Expression: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
											Name:     "b",
										},
									},
								},
							},
							Body: &ast.Block{
								NodeBase:   ast.NodeBase{Span: NodeSpan{17, 19}},
								Statements: nil,
							},
						},
					},
				},
			}, n)
		})

		t.Run("two typed parameters with unquoted names and types, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "@(fn(<{a}> <{b}>, <{c}> <{d}>){})")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 33}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 33}},
						Expression: &ast.FunctionExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{2, 32}, IsParenthesized: true},
							Parameters: []*ast.FunctionParameter{
								{
									NodeBase: ast.NodeBase{NodeSpan{5, 16}, nil, false},
									Var: &ast.UnquotedRegion{
										NodeBase: ast.NodeBase{NodeSpan{5, 10}, nil, false},
										Expression: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
											Name:     "a",
										},
									},
									Type: &ast.UnquotedRegion{
										NodeBase: ast.NodeBase{NodeSpan{11, 16}, nil, false},
										Expression: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
											Name:     "b",
										},
									},
								},
								{
									NodeBase: ast.NodeBase{NodeSpan{18, 29}, nil, false},
									Var: &ast.UnquotedRegion{
										NodeBase: ast.NodeBase{NodeSpan{18, 23}, nil, false},
										Expression: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
											Name:     "c",
										},
									},
									Type: &ast.UnquotedRegion{
										NodeBase: ast.NodeBase{NodeSpan{24, 29}, nil, false},
										Expression: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{26, 27}, nil, false},
											Name:     "d",
										},
									},
								},
							},
							Body: &ast.Block{
								NodeBase:   ast.NodeBase{Span: NodeSpan{30, 32}},
								Statements: nil,
							},
						},
					},
				},
			}, n)
		})

		t.Run("single readonly typed parameter, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "fn(x readonly %int){}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 21}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 18}},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Name:     "x",
								},
								Type: &ast.ReadonlyPatternExpression{
									NodeBase: ast.NodeBase{
										NodeSpan{5, 18},
										nil,
										false,
									},
									Pattern: &ast.PatternIdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{14, 18}, nil, false},
										Name:     "int",
									},
								},
							},
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{19, 21}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("single unprefix typed parameter, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "fn(x int){}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 11}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{NodeSpan{3, 8}, nil, false},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Name:     "x",
								},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{5, 8}, nil, false},
									Unprefixed: true,
									Name:       "int",
								},
							},
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{9, 11}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("two parameters, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "fn(x,n){}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Name:     "x",
								},
							},
							{
								NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
									Name:     "n",
								},
							},
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{7, 9}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("single parameter, body is an expression", func(t *testing.T) {
			n := mustparseChunk(t, "fn(x) => x")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Name:     "x",
								},
							},
						},
						IsBodyExpression: true,
						Body: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Name:     "x",
						},
					},
				},
			}, n)
		})

		t.Run("return type, body is an expression", func(t *testing.T) {
			n := mustparseChunk(t, "fn(x) int => x")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Name:     "x",
								},
							},
						},
						ReturnType: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{6, 9}, nil, false},
							Name:       "int",
							Unprefixed: true,
						},
						IsBodyExpression: true,
						Body: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
							Name:     "x",
						},
					},
				},
			}, n)
		})

		t.Run("unquoted return type, body is an expression", func(t *testing.T) {
			n := mustparseChunk(t, "@(fn(x) <{a}> => x)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 19}},
						Expression: &ast.FunctionExpression{
							NodeBase: ast.NodeBase{Span: NodeSpan{2, 18}, IsParenthesized: true},
							Parameters: []*ast.FunctionParameter{
								{
									NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
									Var: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
										Name:     "x",
									},
								},
							},
							ReturnType: &ast.UnquotedRegion{
								NodeBase: ast.NodeBase{NodeSpan{8, 13}, nil, false},
								Expression: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "a",
								},
							},
							IsBodyExpression: true,
							Body: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
								Name:     "x",
							},
						},
					},
				},
			}, n)
		})

		t.Run("only fn keyword", func(t *testing.T) {
			n, err := parseChunk(t, "fn", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 2},
							&sourcecode.ParsingError{InvalidNext, FN_KEYWORD_OR_FUNC_NAME_SHOULD_BE_FOLLOWED_BY_PARAMS},
							false,
						},
						Parameters: nil,
						Body:       nil,
					},
				},
			}, n)
		})

		t.Run("missing block's closing brace", func(t *testing.T) {
			n, err := parseChunk(t, "fn(){", "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase:   ast.NodeBase{Span: NodeSpan{0, 5}},
						Parameters: nil,
						Body: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{4, 5},
								&sourcecode.ParsingError{UnterminatedBlock, UNTERMINATED_BLOCK_MISSING_BRACE},
								false,
							},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("missing block's closing brace, trailing space", func(t *testing.T) {
			n, err := parseChunk(t, "fn(){ ", "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase:   ast.NodeBase{Span: NodeSpan{0, 6}},
						Parameters: nil,
						Body: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{4, 6},
								&sourcecode.ParsingError{UnterminatedBlock, UNTERMINATED_BLOCK_MISSING_BRACE},
								false,
							},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("missing block's closing brace before closing parenthesis", func(t *testing.T) {
			n, err := parseChunk(t, "(fn(){)", "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase:   ast.NodeBase{Span: NodeSpan{1, 6}, IsParenthesized: true},
						Parameters: nil,
						Body: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{5, 6},
								&sourcecode.ParsingError{UnterminatedBlock, UNTERMINATED_BLOCK_MISSING_BRACE},
								false,
							},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("unexpected char in empty parameter list", func(t *testing.T) {
			n, err := parseChunk(t, "fn(:){}", "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{3, 4},
									&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInParameters(':')},
									false,
								},
							},
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{5, 7}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("unexpected char in non-empty parameter list", func(t *testing.T) {
			n, err := parseChunk(t, "fn(a:b){}", "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Name:     "a",
								},
							},
							{
								NodeBase: ast.NodeBase{
									NodeSpan{4, 5},
									&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInParameters(':')},
									false,
								},
							},
							{
								NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
									Name:     "b",
								},
							},
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{7, 9}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("parameter list not followed by a block", func(t *testing.T) {
			n, err := parseChunk(t, "fn()1", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							&sourcecode.ParsingError{InvalidNext, PARAM_LIST_OF_FUNC_SHOULD_BE_FOLLOWED_BY_BLOCK_OR_ARROW_OR_TYPE},
							false,
						},
						Parameters: nil,
						Body:       nil,
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
						Raw:      "1",
						Value:    1,
					},
				},
			}, n)
		})

		t.Run("unterminated parameter list: end of module", func(t *testing.T) {
			n, err := parseChunk(t, "fn(", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_PARAM_LIST_MISSING_CLOSING_PAREN},
							false,
						},
						Parameters: nil,
						Body:       nil,
					},
				},
			}, n)
		})

		t.Run("unterminated parameter list: followed by line feed", func(t *testing.T) {
			n, err := parseChunk(t, "fn(\n", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_PARAM_LIST_MISSING_CLOSING_PAREN},
							false,
						},
						Parameters: nil,
						Body:       nil,
					},
				},
			}, n)
		})

		t.Run("parameter name should not be a keyword ", func(t *testing.T) {
			n, err := parseChunk(t, "fn(manifest){}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{3, 11},
									&sourcecode.ParsingError{UnspecifiedParsingError, KEYWORDS_SHOULD_NOT_BE_USED_AS_PARAM_NAMES},
									false,
								},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 11}, nil, false},
									Name:     "manifest",
								},
							},
						},
						Body: &ast.Block{
							NodeBase:   ast.NodeBase{Span: NodeSpan{12, 14}},
							Statements: nil,
						},
					},
				},
			}, n)
		})

		t.Run("unterminated arrow", func(t *testing.T) {
			//The error should be recoverable.
			n, err := parseChunk(t, "fn(x) =", "")
			assert.Error(t, err)
			assert.NotNil(t, n)
		})
	})

	t.Run("function declaration", func(t *testing.T) {
		t.Run("keyword name", func(t *testing.T) {
			res, err := parseChunk(t, "fn manifest(){}", "")
			assert.Error(t, err)
			assert.NotNil(t, res)
			assert.ErrorContains(t, err, KEYWORDS_SHOULD_NOT_BE_USED_AS_FN_NAMES)
		})
	})

	t.Run("function pattern expression", func(t *testing.T) {
		t.Run("no parameters", func(t *testing.T) {
			n := mustparseChunk(t, "%fn()")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionPatternExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 5},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_FN, Span: NodeSpan{0, 3}},
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{3, 4}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{4, 5}},
							},*/
						},
						Parameters: nil,
					},
				},
			}, n)
		})

		t.Run("no parameters, return type", func(t *testing.T) {
			n := mustparseChunk(t, "%fn() %int")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionPatternExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 10},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_FN, Span: NodeSpan{0, 3}},
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{3, 4}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{4, 5}},
							},*/
						},
						Parameters: nil,
						ReturnType: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{6, 10}, nil, false},
							Name:     "int",
						},
					},
				},
			}, n)
		})

		t.Run("no parameters, empty body, unprefixed return type", func(t *testing.T) {
			n := mustparseChunk(t, "%fn() int")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionPatternExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_FN, Span: NodeSpan{0, 3}},
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{3, 4}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{4, 5}},
							},*/
						},
						Parameters: nil,
						ReturnType: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{6, 9}, nil, false},
							Name:       "int",
							Unprefixed: true,
						},
					},
				},
			}, n)
		})

		t.Run("various accepted return types", func(t *testing.T) {
			_, err := parseChunk(t, "%fn() [int] {}", "")
			assert.NoError(t, err)

			_, err = parseChunk(t, "%fn() #[int] {}", "")
			assert.NoError(t, err)

			_, err = parseChunk(t, "%fn() #{a: int} {}", "")
			assert.NoError(t, err)
		})

		t.Run("single parameter, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "%fn(x)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionPatternExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_FN, Span: NodeSpan{0, 3}},
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{3, 4}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{5, 6}},
							},*/
						},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:       "x",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single typed parameter, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "%fn(x %int)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionPatternExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_FN, Span: NodeSpan{0, 3}},
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{3, 4}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{10, 11}},
							},*/
						},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{NodeSpan{4, 10}, nil, false},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:     "x",
								},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{6, 10}, nil, false},
									Name:     "int",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single readonly typed parameter, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "%fn(x readonly %int)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionPatternExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{4, 19}},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:     "x",
								},
								Type: &ast.ReadonlyPatternExpression{
									NodeBase: ast.NodeBase{
										NodeSpan{6, 19},
										nil,
										false,
									},
									Pattern: &ast.PatternIdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{15, 19}, nil, false},
										Name:     "int",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single typed parameter with unprefixed type, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "%fn(x int)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionPatternExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{NodeSpan{4, 9}, nil, false},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:     "x",
								},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{6, 9}, nil, false},
									Name:       "int",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single parameter with no name, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "%fn(%int)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionPatternExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_FN, Span: NodeSpan{0, 3}},
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{3, 4}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{8, 9}},
							},*/
						},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
									Name:     "int",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("two parameters, empty body ", func(t *testing.T) {
			n := mustparseChunk(t, "%fn(x,n)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionPatternExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:       "x",
									Unprefixed: true,
								},
							},
							{
								NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Name:       "n",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unexpected char in empty parameter list", func(t *testing.T) {
			n, err := parseChunk(t, "%fn(:)", "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionPatternExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{4, 5},
									&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInParameters(':')},
									false,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unexpected char in non-empty parameter list", func(t *testing.T) {
			n, err := parseChunk(t, "%fn(a:b)", "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionPatternExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Name:       "a",
									Unprefixed: true,
								},
							},
							{
								NodeBase: ast.NodeBase{
									NodeSpan{5, 6},
									&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInParameters(':')},
									false,
								},
							},
							{
								NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Name:       "b",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("parameter name should not be a keyword ", func(t *testing.T) {
			n, err := parseChunk(t, "%fn(manifest int)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.FunctionPatternExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 17},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_FN, Span: NodeSpan{0, 3}},
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{3, 4}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{12, 13}},
							},*/
						},
						Parameters: []*ast.FunctionParameter{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{4, 16},
									&sourcecode.ParsingError{UnspecifiedParsingError, KEYWORDS_SHOULD_NOT_BE_USED_AS_PARAM_NAMES},
									false,
								},
								Var: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 12}, nil, false},
									Name:     "manifest",
								},
								Type: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{13, 16}, nil, false},
									Name:       "int",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated arrow", func(t *testing.T) {
			//The error should be recoverable
			n, err := parseChunk(t, "%fn(x) =", "")
			assert.Error(t, err)
			assert.NotNil(t, n)
		})
	})

	t.Run("pattern conversion expression", func(t *testing.T) {
		t.Run("base case", func(t *testing.T) {
			n := mustparseChunk(t, "%(1)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.PatternConversionExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 3}},
						Value: &ast.IntLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{2, 3}, IsParenthesized: true},
							Raw:      "1",
							Value:    1,
						},
					},
				},
			}, n)
		})

		t.Run("special and bad cases", func(t *testing.T) {
			n, err := parseChunk(t, "(%(1)>1)", "")
			assert.NoError(t, err)
			assert.NotNil(t, n)

			n, err = parseChunk(t, "a = %(1)>1", "")
			assert.NoError(t, err)
			assert.NotNil(t, n)

			n, err = parseChunk(t, "<div a=%(1)>1</div>", "")
			assert.NoError(t, err)
			assert.NotNil(t, n)

			n, err = parseChunk(t, "%(1)>1", "")
			assert.Error(t, err)
			assert.NotNil(t, n)
		})
	})

	t.Run("quoted expression", func(t *testing.T) {

		t.Run("integer value", func(t *testing.T) {
			n := mustparseChunk(t, "@(1)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
						Expression: &ast.IntLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{2, 3},
								nil,
								true,
							},
							Raw:   "1",
							Value: 1,
						},
					},
				},
			}, n)
		})

		t.Run("missing closing parenthesis ", func(t *testing.T) {
			n, err := parseChunk(t, "@(1", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							nil,
							false,
						},
						Expression: &ast.IntLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{2, 3},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_PARENTHESIZED_EXPR_MISSING_CLOSING_PAREN},
								true,
							},
							Raw:   "1",
							Value: 1,
						},
					},
				},
			}, n)
		})

		t.Run("followed by another expression", func(t *testing.T) {
			n := mustparseChunk(t, "@(1) 2")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
						Expression: &ast.IntLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{2, 3},
								nil,
								true,
							},
							Raw:   "1",
							Value: 1,
						},
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
						Raw:      "2",
						Value:    2,
					},
				},
			}, n)
		})

		t.Run("nesting is not allowed", func(t *testing.T) {
			n, err := parseChunk(t, "@(@(1))", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}, IsParenthesized: false},
						Expression: &ast.QuotedExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{2, 6},
								&sourcecode.ParsingError{UnspecifiedParsingError, NESTED_QUOTED_REGIONS_NOT_ALLOWED},
								true,
							},
							Expression: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, true},
								Raw:      "1",
								Value:    1,
							},
						},
					},
				},
			}, n)
		})

		t.Run("in a pattern", func(t *testing.T) {
			n := mustparseChunk(t, "%{a: @(int)}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 11}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{2, 3}},
									Name:     "a",
								},
								Value: &ast.QuotedExpression{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 11}},
									Expression: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 10}, IsParenthesized: true},
										Name:     "int",
									},
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("quoted statements", func(t *testing.T) {

		t.Run("empty", func(t *testing.T) {
			n := mustparseChunk(t, "@{}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 3}},
					},
				},
			}, n)
		})

		t.Run("empty: linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "@{\n}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 4}},
					},
				},
			}, n)
		})

		t.Run("single statement on the same line", func(t *testing.T) {
			n := mustparseChunk(t, "@{ a; }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}},
						Statements: []ast.Node{
							&ast.CallExpression{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 5}},
								Callee: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 4}},
									Name:     "a",
								},
								Must:              true,
								CommandLikeSyntax: true,
							},
						},
					},
				},
			}, n)
		})

		t.Run("two statements on the same line", func(t *testing.T) {
			n := mustparseChunk(t, "@{ a; b; }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
						Statements: []ast.Node{
							&ast.CallExpression{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 5}},
								Callee: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 4}},
									Name:     "a",
								},
								Must:              true,
								CommandLikeSyntax: true,
							},
							&ast.CallExpression{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 8}},
								Callee: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{6, 7}},
									Name:     "b",
								},
								Must:              true,
								CommandLikeSyntax: true,
							},
						},
					},
				},
			}, n)
		})

		t.Run("two statements on different lines", func(t *testing.T) {
			n := mustparseChunk(t, "@{\na;\nb; }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
						Statements: []ast.Node{
							&ast.CallExpression{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 5}},
								Callee: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 4}},
									Name:     "a",
								},
								Must:              true,
								CommandLikeSyntax: true,
							},
							&ast.CallExpression{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 8}},
								Callee: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{6, 7}},
									Name:     "b",
								},
								Must:              true,
								CommandLikeSyntax: true,
							},
						},
					},
				},
			}, n)
		})

		t.Run("assignment with an unquoted LHS", func(t *testing.T) {
			n := mustparseChunk(t, "@{ <{name}> = 1 }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 17}},
						Statements: []ast.Node{
							&ast.Assignment{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 15}},
								Left: &ast.UnquotedRegion{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 11}},
									Expression: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{5, 9}},
										Name:     "name",
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{14, 15}},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("multi-assignment with an unquoted LHS", func(t *testing.T) {
			n := mustparseChunk(t, "@{ assign <{name}> = 1 }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 24}},
						Statements: []ast.Node{
							&ast.MultiAssignment{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 22}},
								Variables: []ast.Node{
									&ast.UnquotedRegion{
										NodeBase: ast.NodeBase{Span: NodeSpan{10, 18}},
										Expression: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{12, 16}},
											Name:     "name",
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{21, 22}},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("multi-assignment with two unquoted LHS", func(t *testing.T) {
			n := mustparseChunk(t, "@{ assign <{name}> <{name}> = 1 }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 33}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 33}},
						Statements: []ast.Node{
							&ast.MultiAssignment{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 31}},
								Variables: []ast.Node{
									&ast.UnquotedRegion{
										NodeBase: ast.NodeBase{Span: NodeSpan{10, 18}},
										Expression: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{12, 16}},
											Name:     "name",
										},
									},
									&ast.UnquotedRegion{
										NodeBase: ast.NodeBase{Span: NodeSpan{19, 27}},
										Expression: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{21, 25}},
											Name:     "name",
										},
									},
								},
								Right: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{30, 31}},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("function declaration with an unquoted name", func(t *testing.T) {
			n := mustparseChunk(t, "@{ fn <{name}>(){} }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
						Statements: []ast.Node{
							&ast.FunctionDeclaration{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 18}},
								Name: &ast.UnquotedRegion{
									NodeBase: ast.NodeBase{Span: NodeSpan{6, 14}},
									Expression: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{8, 12}},
										Name:     "name",
									},
								},
								Function: &ast.FunctionExpression{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 18}},
									Body: &ast.Block{
										NodeBase: ast.NodeBase{Span: NodeSpan{16, 18}},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("missing closing brace", func(t *testing.T) {
			n, err := parseChunk(t, "@{", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 2},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_QUOTED_STATEMENTS_REGION_MISSING_CLOSING_DELIM},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("nesting is not allowed", func(t *testing.T) {
			n, err := parseChunk(t, "@{@{}}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
						Statements: []ast.Node{
							&ast.QuotedStatements{
								NodeBase: ast.NodeBase{
									NodeSpan{2, 5},
									&sourcecode.ParsingError{UnspecifiedParsingError, NESTED_QUOTED_REGIONS_NOT_ALLOWED},
									false,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("in a pattern", func(t *testing.T) {
			n := mustparseChunk(t, "%{a: @{int}}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 11}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{2, 3}},
									Name:     "a",
								},
								Value: &ast.QuotedStatements{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 11}},
									Statements: []ast.Node{
										&ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{7, 10}},
											Name:     "int",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("unquoted region", func(t *testing.T) {

		t.Run("base case: in quoted statements", func(t *testing.T) {
			n := mustparseChunk(t, "@{<{1}>}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
						Statements: []ast.Node{
							&ast.UnquotedRegion{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 7}},
								Expression: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{4, 5}},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("base case: in quoted expression", func(t *testing.T) {
			n := mustparseChunk(t, "@(<{1}>)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
						Expression: &ast.UnquotedRegion{
							NodeBase: ast.NodeBase{Span: NodeSpan{2, 7}, IsParenthesized: true},
							Expression: &ast.IntLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{4, 5}},
								Raw:      "1",
								Value:    1,
							},
						},
					},
				},
			}, n)
		})

		t.Run("multi-line", func(t *testing.T) {
			n := mustparseChunk(t, "@{<{\n1\n}>}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
						Statements: []ast.Node{
							&ast.UnquotedRegion{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 9}},
								Expression: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 6}},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("followed by another expression in a quoted region", func(t *testing.T) {
			n := mustparseChunk(t, "@{<{1}> 2}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
						Statements: []ast.Node{
							&ast.UnquotedRegion{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 7}},
								Expression: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{4, 5}},
									Raw:      "1",
									Value:    1,
								},
							},
							&ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Raw:      "2",
								Value:    2,
							},
						},
					},
				},
			}, n)
		})

		t.Run("empty", func(t *testing.T) {
			n, err := parseChunk(t, "@{<{}>}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}},
						Statements: []ast.Node{
							&ast.UnquotedRegion{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 6}},
								Expression: &ast.MissingExpression{
									NodeBase: ast.NodeBase{
										NodeSpan{4, 5},
										&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("@{<{}>}"), 4, true)},
										false,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unexpected extra expression", func(t *testing.T) {
			n, err := parseChunk(t, "@{<{1 2}>}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
						Statements: []ast.Node{
							&ast.UnquotedRegion{
								NodeBase: ast.NodeBase{
									NodeSpan{2, 9},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNQUOTED_REGION_SHOULD_CONTAIN_A_SINGLE_EXPR},
									false,
								},
								Expression: &ast.IntLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{4, 5}},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("nesting is not allowed", func(t *testing.T) {
			n, err := parseChunk(t, "@{<{<{1}>}>}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedStatements{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
						Statements: []ast.Node{
							&ast.UnquotedRegion{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 11}},
								Expression: &ast.UnquotedRegion{
									NodeBase: ast.NodeBase{
										NodeSpan{4, 9},
										&sourcecode.ParsingError{UnspecifiedParsingError, NESTED_UNQUOTED_REGIONS_NOT_ALLOWED},
										false,
									},
									Expression: &ast.IntLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 7}},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			}, n)
		})

	})

	t.Run("switch statement", func(t *testing.T) {

		testCases := []struct {
			input    string
			hasError bool
			result   ast.Node
		}{
			{
				input:    "switch 1 { }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
					Statements: []ast.Node{
						&ast.SwitchStatement{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
							Discriminant: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Raw:      "1",
								Value:    1,
							},
							Cases: nil,
						},
					},
				},
			},
			{
				input:    "switch 1 { 1 { } }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
					Statements: []ast.Node{
						&ast.SwitchStatement{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 18}},
							Discriminant: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Raw:      "1",
								Value:    1,
							},
							Cases: []*ast.SwitchStatementCase{
								{
									NodeBase: ast.NodeBase{NodeSpan{11, 16}, nil, false},
									Values: []ast.Node{
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
									Block: &ast.Block{
										NodeBase:   ast.NodeBase{Span: NodeSpan{13, 16}},
										Statements: nil,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "switch 1 { defaultcase { } }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
					Statements: []ast.Node{
						&ast.SwitchStatement{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 28}},
							Discriminant: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Raw:      "1",
								Value:    1,
							},
							Cases: []*ast.SwitchStatementCase{},
							DefaultCases: []*ast.DefaultCaseWithBlock{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{11, 26}},
									Block: &ast.Block{
										NodeBase: ast.NodeBase{Span: NodeSpan{23, 26}},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "switch 1 { 1 { } 2 { } }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
					Statements: []ast.Node{
						&ast.SwitchStatement{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 24}},
							Discriminant: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Raw:      "1",
								Value:    1,
							},
							Cases: []*ast.SwitchStatementCase{
								{
									NodeBase: ast.NodeBase{NodeSpan{11, 16}, nil, false},
									Values: []ast.Node{
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
									Block: &ast.Block{
										NodeBase:   ast.NodeBase{Span: NodeSpan{13, 16}},
										Statements: nil,
									},
								},
								{
									NodeBase: ast.NodeBase{NodeSpan{17, 22}, nil, false},
									Values: []ast.Node{

										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
											Raw:      "2",
											Value:    2,
										},
									},
									Block: &ast.Block{
										NodeBase:   ast.NodeBase{Span: NodeSpan{19, 22}},
										Statements: nil,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "switch 1 { 1, 2 { } }",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
					Statements: []ast.Node{
						&ast.SwitchStatement{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 21}},
							Discriminant: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Raw:      "1",
								Value:    1,
							},
							Cases: []*ast.SwitchStatementCase{
								{
									NodeBase: ast.NodeBase{NodeSpan{11, 19}, nil, false},
									Values: []ast.Node{
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Raw:      "1",
											Value:    1,
										},
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
											Raw:      "2",
											Value:    2,
										},
									},
									Block: &ast.Block{
										NodeBase:   ast.NodeBase{Span: NodeSpan{16, 19}},
										Statements: nil,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "switch 1 { 1 { }",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
					Statements: []ast.Node{
						&ast.SwitchStatement{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 16},
								&sourcecode.ParsingError{UnterminatedSwitchStmt, UNTERMINATED_SWITCH_STMT_MISSING_CLOSING_BRACE},
								false,
							},
							Discriminant: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Raw:      "1",
								Value:    1,
							},
							Cases: []*ast.SwitchStatementCase{
								{
									NodeBase: ast.NodeBase{NodeSpan{11, 16}, nil, false},
									Values: []ast.Node{
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
									Block: &ast.Block{
										NodeBase:   ast.NodeBase{Span: NodeSpan{13, 16}},
										Statements: nil,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "switch 1 { defaultcase { }",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
					Statements: []ast.Node{
						&ast.SwitchStatement{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 26},
								&sourcecode.ParsingError{UnterminatedSwitchStmt, UNTERMINATED_SWITCH_STMT_MISSING_CLOSING_BRACE},
								false,
							},
							Discriminant: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Raw:      "1",
								Value:    1,
							},
							Cases: []*ast.SwitchStatementCase{},
							DefaultCases: []*ast.DefaultCaseWithBlock{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{11, 26}},
									Block: &ast.Block{
										NodeBase: ast.NodeBase{Span: NodeSpan{23, 26}},
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "switch 1 { 1 {",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
					Statements: []ast.Node{
						&ast.SwitchStatement{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 14},
								&sourcecode.ParsingError{UnterminatedSwitchStmt, UNTERMINATED_SWITCH_STMT_MISSING_CLOSING_BRACE},
								false,
								/*[]ast.Token{
									{Type: ast.SWITCH_KEYWORD, Span: NodeSpan{0, 6}},
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{9, 10}},
								},*/
							},
							Discriminant: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Raw:      "1",
								Value:    1,
							},
							Cases: []*ast.SwitchStatementCase{
								{
									NodeBase: ast.NodeBase{NodeSpan{11, 14}, nil, false},
									Values: []ast.Node{
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
									Block: &ast.Block{
										NodeBase: ast.NodeBase{
											NodeSpan{13, 14},
											&sourcecode.ParsingError{UnterminatedBlock, UNTERMINATED_BLOCK_MISSING_BRACE},
											false,
											/*[]ast.Token{
												{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{13, 14}},
											},*/
										},
										Statements: nil,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "switch 1 { 1 { ",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
					Statements: []ast.Node{
						&ast.SwitchStatement{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 15},
								&sourcecode.ParsingError{UnterminatedSwitchStmt, UNTERMINATED_SWITCH_STMT_MISSING_CLOSING_BRACE},
								false,
								/*[]ast.Token{
									{Type: ast.SWITCH_KEYWORD, Span: NodeSpan{0, 6}},
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{9, 10}},
								},*/
							},
							Discriminant: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
								Raw:      "1",
								Value:    1,
							},
							Cases: []*ast.SwitchStatementCase{
								{
									NodeBase: ast.NodeBase{NodeSpan{11, 15}, nil, false},
									Values: []ast.Node{
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
									Block: &ast.Block{
										NodeBase: ast.NodeBase{
											NodeSpan{13, 15},
											&sourcecode.ParsingError{UnterminatedBlock, UNTERMINATED_BLOCK_MISSING_BRACE},
											false,
											/*[]ast.Token{
												{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{13, 14}},
											},*/
										},
										Statements: nil,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "switch",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
					Statements: []ast.Node{
						&ast.SwitchStatement{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 6},
								&sourcecode.ParsingError{UnterminatedSwitchStmt, UNTERMINATED_SWITCH_STMT_MISSING_VALUE},
								false,
							},
						},
					},
				},
			},
			{
				input:    "switch 1 { ) }",
				hasError: true,
			},
			{
				input:    "switch 1 { % }",
				hasError: true,
			},
			{
				input:    "switch 1 { 1 ) }",
				hasError: true,
			},
			{
				input:    "switch 1 { 1 ) {} }",
				hasError: true,
			},
			{
				input:    "switch 1 { 1 {} ) }",
				hasError: true,
			},
			{
				input:    "switch 1 { $a { } }",
				hasError: true,
			},
			{
				input:    "switch 1 { defaultcase ) }",
				hasError: true,
			},
			{
				input:    "switch 1 { defaultcase ) {} }",
				hasError: true,
			},
			{
				input:    "switch 1 { defaultcase {} ) }",
				hasError: true,
			},
			{
				input:    "switch 1 { defaultcase {}\n defaultcase {} }",
				hasError: true,
			},
		}

		for _, testCase := range testCases {
			t.Run(testCase.input, func(t *testing.T) {
				n, err := parseChunk(t, testCase.input, "")
				if testCase.hasError {
					assert.Error(t, err)
				} else {
					assert.NoError(t, err)
				}

				if testCase.result != nil {
					assert.Equal(t, testCase.result, n)
				}
			})
		}
	})

	t.Run("match statement", func(t *testing.T) {
		t.Run("case is not a simple literal and is not statically known", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, "match 1 { $a { } }")
			})
		})

		t.Run("case is not a simple literal but is statically known", func(t *testing.T) {

			n := mustparseChunk(t, "match 1 { ({}) { } }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.MatchStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 20}},
						Discriminant: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
							Raw:      "1",
							Value:    1,
						},
						Cases: []*ast.MatchStatementCase{
							{
								NodeBase: ast.NodeBase{NodeSpan{10, 18}, nil, false},
								Values: []ast.Node{
									&ast.ObjectLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{11, 13}, IsParenthesized: true},
									},
								},
								Block: &ast.Block{
									NodeBase:   ast.NodeBase{Span: NodeSpan{15, 18}},
									Statements: nil,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("case with group match variable", func(t *testing.T) {
			n := mustparseChunk(t, "match 1 { %/home/{:username} m { } }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 36}, nil, false},
				Statements: []ast.Node{
					&ast.MatchStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 36}},
						Discriminant: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
							Raw:      "1",
							Value:    1,
						},
						Cases: []*ast.MatchStatementCase{
							{
								NodeBase: ast.NodeBase{NodeSpan{10, 34}, nil, false},
								Values: []ast.Node{
									&ast.NamedSegmentPathPatternLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{10, 28}},
										Slices: []ast.Node{
											&ast.PathPatternSlice{
												NodeBase: ast.NodeBase{NodeSpan{11, 17}, nil, false},
												Value:    "/home/",
											},
											&ast.NamedPathSegment{
												NodeBase: ast.NodeBase{NodeSpan{18, 27}, nil, false},
												Name:     "username",
											},
										},
										Raw:         "%/home/{:username}",
										StringValue: "%/home/{:username}",
									},
								},
								GroupMatchingVariable: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{29, 30}, nil, false},
									Name:     "m",
								},
								Block: &ast.Block{
									NodeBase:   ast.NodeBase{Span: NodeSpan{31, 34}},
									Statements: nil,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("group match variable should not be a keyword", func(t *testing.T) {
			n, err := parseChunk(t, "match 1 { %/home/{:username} manifest { } }", "")
			assert.NotNil(t, n)
			assert.ErrorContains(t, err, KEYWORDS_SHOULD_NOT_BE_USED_IN_ASSIGNMENT_LHS)
		})

		t.Run("missing value before block of case", func(t *testing.T) {
			s := "match 1 { {} }"

			n, err := parseChunk(t, s, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.MatchStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
						Discriminant: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
							Raw:      "1",
							Value:    1,
						},
						Cases: []*ast.MatchStatementCase{
							{
								NodeBase: ast.NodeBase{NodeSpan{10, 12}, nil, false},
								Values: []ast.Node{
									&ast.MissingExpression{
										NodeBase: ast.NodeBase{
											NodeSpan{10, 11},
											&sourcecode.ParsingError{MissingExpr, fmtCaseValueExpectedHere([]rune(s), 10, true)},
											false,
										},
									},
								},
								Block: &ast.Block{
									NodeBase:   ast.NodeBase{Span: NodeSpan{10, 12}},
									Statements: nil,
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("switch expression", func(t *testing.T) {

		testCases := []struct {
			input    string
			hasError bool
			result   ast.Node
		}{
			{
				input:    "(switch 1 { })",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
					Statements: []ast.Node{
						&ast.SwitchExpression{
							NodeBase: ast.NodeBase{NodeSpan{1, 13}, nil, true},
							Discriminant: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Raw:      "1",
								Value:    1,
							},
							Cases: nil,
						},
					},
				},
			},
			{
				input:    "(switch 1 { 1 => 1 })",
				hasError: false,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
					Statements: []ast.Node{
						&ast.SwitchExpression{
							NodeBase: ast.NodeBase{NodeSpan{1, 20}, nil, true},
							Discriminant: &ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Raw:      "1",
								Value:    1,
							},
							Cases: []*ast.SwitchExpressionCase{
								{
									NodeBase: ast.NodeBase{NodeSpan{12, 18}, nil, false},
									Values: []ast.Node{
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
									Result: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			},
			{
				input:    "(switch",
				hasError: true,
				result: &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
					Statements: []ast.Node{
						&ast.SwitchExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{1, 7},
								&sourcecode.ParsingError{UnterminatedSwitchExpr, UNTERMINATED_SWITCH_EXPR_MISSING_VALUE},
								true,
							},
						},
					},
				},
			},
			{
				hasError: false,
				input:    "a = switch 1 {\n}",
			},
			{
				hasError: false,
				input:    "a = switch 1 { \n}",
			},
			{
				hasError: false,
				input:    "a = switch 1 {\n\n}",
			},
			{
				input:    "(switch 1 { defaultcase => 0 })",
				hasError: false,
			},
			{
				input:    "(switch 1 { defaultcase=>0 })",
				hasError: false,
			},
			{
				hasError: false,
				input:    "(switch 1 { 1 => 1 2 => 2 })",
			},
			{
				hasError: false,
				input:    "(switch 1 { 1, 2 => 2 })",
			},
			{
				input:    "(switch 1 { ) })",
				hasError: true,
			},
			{
				input:    "(switch 1 { % })",
				hasError: true,
			},
			{
				input:    "(switch 1 { 1 ) })",
				hasError: true,
			},
			{
				input:    "(switch 1 { 1 ) => 1 })",
				hasError: true,
			},
			{
				input:    "(switch 1 { 1 => 1 ) })",
				hasError: true,
			},
			{
				input:    "(switch 1 { $a { } })",
				hasError: true,
			},
			{
				input:    "(switch 1 { defaultcase ) })",
				hasError: true,
			},
			{
				input:    "(switch 1 { defaultcase ) => 1 })",
				hasError: true,
			},
			{
				input:    "(switch 1 { defaultcase => 1 ) })",
				hasError: true,
			},
			{
				input:    "(switch 1 { defaultcase {}\n defaultcase => 1 })",
				hasError: true,
			},
		}

		for _, testCase := range testCases {
			t.Run(testCase.input, func(t *testing.T) {
				n, err := parseChunk(t, testCase.input, "")
				if testCase.hasError {
					assert.Error(t, err)
				} else {
					assert.NoError(t, err)
				}

				if testCase.result != nil {
					assert.Equal(t, testCase.result, n)
				}
			})
		}
	})

	t.Run("match expression", func(t *testing.T) {

		t.Run("case is not a simple literal and is not statically known", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, "(match 1 { $a { } })")
			})
		})

		t.Run("case is not a simple literal but is statically known", func(t *testing.T) {

			n := mustparseChunk(t, "(match 1 { ({}) =>1 })")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.MatchExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{1, 21}, IsParenthesized: true},
						Discriminant: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Raw:      "1",
							Value:    1,
						},
						Cases: []*ast.MatchExpressionCase{
							{
								NodeBase: ast.NodeBase{NodeSpan{11, 19}, nil, false},
								Values: []ast.Node{
									&ast.ObjectLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{12, 14}, IsParenthesized: true},
									},
								},

								Result: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{18, 19}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("case with group match variable", func(t *testing.T) {
			n := mustparseChunk(t, "(match 1 { %/home/{:username} m => 1 })")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 39}, nil, false},
				Statements: []ast.Node{
					&ast.MatchExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{1, 38}, IsParenthesized: true},
						Discriminant: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Raw:      "1",
							Value:    1,
						},
						Cases: []*ast.MatchExpressionCase{
							{
								NodeBase: ast.NodeBase{NodeSpan{11, 36}, nil, false},
								Values: []ast.Node{
									&ast.NamedSegmentPathPatternLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{11, 29}},
										Slices: []ast.Node{
											&ast.PathPatternSlice{
												NodeBase: ast.NodeBase{NodeSpan{12, 18}, nil, false},
												Value:    "/home/",
											},
											&ast.NamedPathSegment{
												NodeBase: ast.NodeBase{NodeSpan{19, 28}, nil, false},
												Name:     "username",
											},
										},
										Raw:         "%/home/{:username}",
										StringValue: "%/home/{:username}",
									},
								},
								GroupMatchingVariable: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{30, 31}, nil, false},
									Name:     "m",
								},
								Result: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{35, 36}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("group match variable should not be a keyword", func(t *testing.T) {
			n, err := parseChunk(t, "(match 1 { %/home/{:username} manifest => 1 })", "")
			assert.NotNil(t, n)
			assert.ErrorContains(t, err, KEYWORDS_SHOULD_NOT_BE_USED_IN_ASSIGNMENT_LHS)
		})
	})

	t.Run("empty single line comment", func(t *testing.T) {
		n := mustparseChunk(t, "# ")
		assert.EqualValues(t, &ast.Chunk{
			NodeBase: ast.NodeBase{
				NodeSpan{0, 2},
				nil,
				false,
			},
			Statements: nil,
		}, n)
	})

	t.Run("not empty single line comment", func(t *testing.T) {
		n := mustparseChunk(t, "# some text")
		assert.EqualValues(t, &ast.Chunk{
			NodeBase: ast.NodeBase{
				NodeSpan{0, 11},
				nil,
				false,
			},
			Statements: nil,
		}, n)
	})

	t.Run("import statement", func(t *testing.T) {
		t.Run("ok", func(t *testing.T) {
			n := mustparseChunk(t, `import a https://example.com/a.ix {}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 36}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 36},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IMPORT_KEYWORD, Span: NodeSpan{0, 6}},
							},*/
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.URLLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 33}, nil, false},
							Value:    "https://example.com/a.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{34, 36},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{34, 35}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{35, 36}},
								},*/
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid URL as source", func(t *testing.T) {
			n, err := parseChunk(t, `import res https://.ix {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 25},
							&sourcecode.ParsingError{UnspecifiedParsingError, IMPORT_STMT_SRC_SHOULD_BE_AN_URL_OR_PATH_LIT},
							false,
							/*[]ast.Token{
								{Type: ast.IMPORT_KEYWORD, Span: NodeSpan{0, 6}},
							},*/
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 10}, nil, false},
							Name:     "res",
						},
						Source: &ast.InvalidURL{
							NodeBase: ast.NodeBase{
								NodeSpan{11, 22},
								&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_URL_OR_HOST},
								false,
							},
							Value: "https://.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{23, 25},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{23, 24}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{24, 25}},
								},*/
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid absolute path as source: presence of a '//' segment at the start", func(t *testing.T) {
			n, err := parseChunk(t, `import a //x.ix {}`, "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 18},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IMPORT_KEYWORD, Span: NodeSpan{0, 6}},
							},*/
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.AbsolutePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 15},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_SLASHSLASH},
								false,
							},
							Raw:   "//x.ix",
							Value: "//x.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{16, 18},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{34, 35}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{35, 36}},
								},*/
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid absolute path as source: presence of a '//' segment", func(t *testing.T) {
			n, err := parseChunk(t, `import a /x//y.ix {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 20},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IMPORT_KEYWORD, Span: NodeSpan{0, 6}},
							},*/
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.AbsolutePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 17},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_SLASHSLASH},
								false,
							},
							Raw:   "/x//y.ix",
							Value: "/x//y.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{18, 20},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{34, 35}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{35, 36}},
								},*/
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid relative path as source: presence of a '//' segment at the start", func(t *testing.T) {
			n, err := parseChunk(t, `import a .//x.ix {}`, "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 19},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IMPORT_KEYWORD, Span: NodeSpan{0, 6}},
							},*/
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 16},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_SLASHSLASH},
								false,
							},
							Raw:   ".//x.ix",
							Value: ".//x.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{17, 19},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{34, 35}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{35, 36}},
								},*/
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid relative path as source: presence of a '//' segment", func(t *testing.T) {
			n, err := parseChunk(t, `import a ./x//y.ix {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 21},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IMPORT_KEYWORD, Span: NodeSpan{0, 6}},
							},*/
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 18},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_SLASHSLASH},
								false,
							},
							Raw:   "./x//y.ix",
							Value: "./x//y.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{19, 21},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{34, 35}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{35, 36}},
								},*/
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		//

		t.Run("invalid absolute path as source: presence of a '/../' segment at the start", func(t *testing.T) {
			n, err := parseChunk(t, `import a /../x.ix {}`, "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 20},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IMPORT_KEYWORD, Span: NodeSpan{0, 6}},
							},*/
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.AbsolutePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 17},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_DOT_SLASHSLASH},
								false,
							},
							Raw:   "/../x.ix",
							Value: "/../x.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{18, 20},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{34, 35}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{35, 36}},
								},*/
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid absolute path as source: presence of a '/../' segment", func(t *testing.T) {
			n, err := parseChunk(t, `import a /x/../y.ix {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 22},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IMPORT_KEYWORD, Span: NodeSpan{0, 6}},
							},*/
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.AbsolutePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 19},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_DOT_SLASHSLASH},
								false,
							},
							Raw:   "/x/../y.ix",
							Value: "/x/../y.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{20, 22},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{34, 35}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{35, 36}},
								},*/
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid relative path as source: presence of a '/../' segment at the start", func(t *testing.T) {
			n, err := parseChunk(t, `import a ./../y.ix {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 21},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IMPORT_KEYWORD, Span: NodeSpan{0, 6}},
							},*/
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 18},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_DOT_SLASHSLASH},
								false,
							},
							Raw:   "./../y.ix",
							Value: "./../y.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{19, 21},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{34, 35}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{35, 36}},
								},*/
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid relative path as source: path starting with ../", func(t *testing.T) {
			n, err := parseChunk(t, `import a ../y.ix {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 19},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 16},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_DOT_SLASHSLASH},
								false,
							},
							Raw:   "../y.ix",
							Value: "../y.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{17, 19},
								nil,
								false,
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid relative path as source: presence of a '/../' segment after a dirname", func(t *testing.T) {
			n, err := parseChunk(t, `import a ./x/../y.ix {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 23},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 20},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_DOT_SLASHSLASH},
								false,
							},
							Raw:   "./x/../y.ix",
							Value: "./x/../y.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{21, 23},
								nil,
								false,
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		//

		t.Run("invalid absolute path as source: presence of a '/./' segment at the start", func(t *testing.T) {
			n, err := parseChunk(t, `import a /./x.ix {}`, "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 19},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.AbsolutePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 16},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_DOT_SEGMENTS},
								false,
							},
							Raw:   "/./x.ix",
							Value: "/./x.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{17, 19},
								nil,
								false,
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid absolute path as source: presence of a '/./' segment", func(t *testing.T) {
			n, err := parseChunk(t, `import a /x/./y.ix {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 21},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.AbsolutePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 18},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_DOT_SEGMENTS},
								false,
							},
							Raw:   "/x/./y.ix",
							Value: "/x/./y.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{19, 21},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{34, 35}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{35, 36}},
								},*/
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid relative path as source: presence of a '/./' segment at the start", func(t *testing.T) {
			n, err := parseChunk(t, `import a ././y.ix {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 20},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 17},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_DOT_SEGMENTS},
								false,
							},
							Raw:   "././y.ix",
							Value: "././y.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{18, 20},
								nil,
								false,
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid relative path as source: presence of a '/./' segment after a dirname", func(t *testing.T) {
			n, err := parseChunk(t, `import a ./x/./y.ix {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 22},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 19},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_DOT_SEGMENTS},
								false,
							},
							Raw:   "./x/./y.ix",
							Value: "./x/./y.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{20, 22},
								nil,
								false,
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid absolute path as source: invalid file extension", func(t *testing.T) {
			n, err := parseChunk(t, `import a /y {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 14},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.AbsolutePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 11},
								&sourcecode.ParsingError{UnspecifiedParsingError, URL_LITS_AND_PATH_LITS_USED_AS_IMPORT_SRCS_SHOULD_END_WITH_IX},
								false,
							},
							Raw:   "/y",
							Value: "/y",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 14},
								nil,
								false,
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid relative path as source: invalid file extension", func(t *testing.T) {
			n, err := parseChunk(t, `import a ./y {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 15},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "a",
						},
						Source: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 12},
								&sourcecode.ParsingError{UnspecifiedParsingError, URL_LITS_AND_PATH_LITS_USED_AS_IMPORT_SRCS_SHOULD_END_WITH_IX},
								false,
							},
							Raw:   "./y",
							Value: "./y",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{13, 15},
								nil,
								false,
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		//

		t.Run("invalid URL path as source: presence of a '//' segment at the start", func(t *testing.T) {
			n, err := parseChunk(t, `import x https://example.com//x.ix {}`, "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 37}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 37},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "x",
						},
						Source: &ast.URLLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 34},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_OF_URL_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_SLASHSLASH},
								false,
							},
							Value: "https://example.com//x.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{35, 37},
								nil,
								false,
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid URL source: presence of a '//' segment in the path", func(t *testing.T) {
			n, err := parseChunk(t, `import x https://example.com/x//y.ix {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 39}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 39},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "x",
						},
						Source: &ast.URLLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 36},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_OF_URL_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_SLASHSLASH},
								false,
							},
							Value: "https://example.com/x//y.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{37, 39},
								nil,
								false,
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid URL as source: presence of a '/../' segment at the start of the path", func(t *testing.T) {
			n, err := parseChunk(t, `import x https://example.com/../x.ix {}`, "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 39}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 39},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "x",
						},
						Source: &ast.URLLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 36},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_OF_URL_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_DOT_SLASHSLASH},
								false,
							},
							Value: "https://example.com/../x.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{37, 39},
								nil,
								false,
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid URL path as source: presence of a '/../' segment in the path", func(t *testing.T) {
			n, err := parseChunk(t, `import x https://example.com/x/../y.ix {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 41}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 41},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "x",
						},
						Source: &ast.URLLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 38},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_OF_URL_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_DOT_SLASHSLASH},
								false,
							},
							Value: "https://example.com/x/../y.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{39, 41},
								nil,
								false,
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid URL as source: presence of a '/./' segment at the start of the path", func(t *testing.T) {
			n, err := parseChunk(t, `import x https://example.com/./x.ix {}`, "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 38}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 38},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "x",
						},
						Source: &ast.URLLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 35},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_OF_URL_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_DOT_SEGMENTS},
								false,
							},
							Value: "https://example.com/./x.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{36, 38},
								nil,
								false,
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid URL as source: presence of a '/./' segment", func(t *testing.T) {
			n, err := parseChunk(t, `import x https://example.com/x/./y.ix {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 40}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 40},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "x",
						},
						Source: &ast.URLLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 37},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_OF_URL_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_DOT_SEGMENTS},
								false,
							},
							Value: "https://example.com/x/./y.ix",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{38, 40},
								nil,
								false,
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})

		t.Run("invalid URL as source: invalid file extension", func(t *testing.T) {
			n, err := parseChunk(t, `import x https://example.com/x {}`, "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 33}, nil, false},
				Statements: []ast.Node{
					&ast.ImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 33},
							nil,
							false,
						},
						Identifier: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Name:     "x",
						},
						Source: &ast.URLLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 30},
								&sourcecode.ParsingError{UnspecifiedParsingError, URL_LITS_AND_PATH_LITS_USED_AS_IMPORT_SRCS_SHOULD_END_WITH_IX},
								false,
							},
							Value: "https://example.com/x",
						},
						Configuration: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{31, 33},
								nil,
								false,
							},
							Properties: nil,
						},
					},
				},
			}, n)
		})
	})

	t.Run("inclusion import statement", func(t *testing.T) {
		t.Run("relative path literal", func(t *testing.T) {
			n := mustparseChunk(t, `import ./file.ix`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.InclusionImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 16},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IMPORT_KEYWORD, Span: NodeSpan{0, 6}},
							},*/
						},
						Source: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 16}, nil, false},
							Value:    "./file.ix",
							Raw:      "./file.ix",
						},
					},
				},
			}, n)
		})

		t.Run("invalid relative path literal", func(t *testing.T) {
			//we only check a single bad case because the same logic is used for module imports.

			n, err := parseChunk(t, `import .//file.ix`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.InclusionImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 17},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IMPORT_KEYWORD, Span: NodeSpan{0, 6}},
							},*/
						},
						Source: &ast.RelativePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{7, 17},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_SLASHSLASH},
								false,
							},
							Value: ".//file.ix",
							Raw:   ".//file.ix",
						},
					},
				},
			}, n)
		})

		t.Run("absolute path literal", func(t *testing.T) {
			n := mustparseChunk(t, `import /file.ix`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.InclusionImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 15},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IMPORT_KEYWORD, Span: NodeSpan{0, 6}},
							},*/
						},
						Source: &ast.AbsolutePathLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 15}, nil, false},
							Value:    "/file.ix",
							Raw:      "/file.ix",
						},
					},
				},
			}, n)
		})

		t.Run("invalid absolute path literal", func(t *testing.T) {
			//we only check a single bad case because the same logic is used for module imports.

			n, err := parseChunk(t, `import //file.ix`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.InclusionImportStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 16},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.IMPORT_KEYWORD, Span: NodeSpan{0, 6}},
							},*/
						},
						Source: &ast.AbsolutePathLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{7, 16},
								&sourcecode.ParsingError{UnspecifiedParsingError, PATH_LITERALS_USED_AS_IMPORT_SRCS_SHOULD_NOT_CONTAIN_SLASHSLASH},
								false,
							},
							Value: "//file.ix",
							Raw:   "//file.ix",
						},
					},
				},
			}, n)
		})
	})

	t.Run("spawn expression", func(t *testing.T) {
		t.Run("call expression: callee is an identifier literal", func(t *testing.T) {
			n := mustparseChunk(t, `go nil do f()`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.SpawnExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 13}},
						Meta: &ast.NilLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
						},
						Module: &ast.EmbeddedModule{
							NodeBase:       ast.NodeBase{NodeSpan{10, 13}, nil, false},
							SingleCallExpr: true,
							Statements: []ast.Node{
								&ast.CallExpression{
									NodeBase: ast.NodeBase{Span: NodeSpan{10, 13}},
									Callee: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
										Name:     "f",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("call expression: calee is an identifier member expression", func(t *testing.T) {
			n := mustparseChunk(t, `go nil do http.read()`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.SpawnExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 21}},
						Meta: &ast.NilLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
						},
						Module: &ast.EmbeddedModule{
							NodeBase:       ast.NodeBase{NodeSpan{10, 21}, nil, false},
							SingleCallExpr: true,
							Statements: []ast.Node{
								&ast.CallExpression{
									NodeBase: ast.NodeBase{Span: NodeSpan{10, 21}},
									Callee: &ast.IdentifierMemberExpression{
										NodeBase: ast.NodeBase{NodeSpan{10, 19}, nil, false},
										Left: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{10, 14}, nil, false},
											Name:     "http",
										},
										PropertyNames: []*ast.IdentifierLiteral{
											{
												NodeBase: ast.NodeBase{NodeSpan{15, 19}, nil, false},
												Name:     "read",
											},
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("embedded module", func(t *testing.T) {
			n := mustparseChunk(t, `go nil do { manifest {} }`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.SpawnExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 25},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.GO_KEYWORD, Span: NodeSpan{0, 2}},
								{Type: ast.DO_KEYWORD, Span: NodeSpan{7, 9}},
							},*/
						},
						Meta: &ast.NilLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
						},
						Module: &ast.EmbeddedModule{
							NodeBase: ast.NodeBase{
								NodeSpan{10, 25},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{10, 11}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{24, 25}},
								},*/
							},
							Manifest: &ast.Manifest{
								NodeBase: ast.NodeBase{
									Span:            NodeSpan{12, 23},
									IsParenthesized: false,
									/*[]ast.Token{
										{Type: inoxconsts.MANIFEST_KEYWORD, Span: NodeSpan{12, 20}},
									},*/
								},
								Object: &ast.ObjectLiteral{
									NodeBase: ast.NodeBase{
										NodeSpan{21, 23},
										nil,
										false,
										/*[]ast.Token{
											{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{21, 22}},
											{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{22, 23}},
										},*/
									},
									Properties: nil,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("statements next to each other in embedded module", func(t *testing.T) {
			n, err := parseChunk(t, `go nil do { 1$v }`, "")

			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.SpawnExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 17},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.GO_KEYWORD, Span: NodeSpan{0, 2}},
								{Type: ast.DO_KEYWORD, Span: NodeSpan{7, 9}},
							},*/
						},
						Meta: &ast.NilLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
						},
						Module: &ast.EmbeddedModule{
							NodeBase: ast.NodeBase{
								NodeSpan{10, 17},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{10, 11}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{16, 17}},
								},*/
							},
							Statements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
									Raw:      "1",
									Value:    1,
								},
								&ast.Variable{
									NodeBase: ast.NodeBase{
										NodeSpan{13, 15},
										&sourcecode.ParsingError{UnspecifiedParsingError, STMTS_SHOULD_BE_SEPARATED_BY},
										false,
									},
									Name: "v",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("missing expression/module after 'do' keyword", func(t *testing.T) {
			n, err := parseChunk(t, `go nil do`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.SpawnExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_SPAWN_EXPRESSION_MISSING_EMBEDDED_MODULE_AFTER_DO_KEYWORD},
							false,
							/*[]ast.Token{
								{Type: ast.GO_KEYWORD, Span: NodeSpan{0, 2}},
								{Type: ast.DO_KEYWORD, Span: NodeSpan{7, 9}},
							},*/
						},
						Meta: &ast.NilLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
						},
					},
				},
			}, n)
		})

	})

	t.Run("mapping expression", func(t *testing.T) {
		t.Run("empty", func(t *testing.T) {
			n := mustparseChunk(t, `Mapping {}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.MappingExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 10},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.MAPPING_KEYWORD, Span: NodeSpan{0, 7}},
								{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{8, 9}},
								{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{9, 10}},
							},*/
						},
					},
				},
			}, n)
		})

		t.Run("empty, missing closing brace", func(t *testing.T) {
			n, err := parseChunk(t, `Mapping {`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.MappingExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_MAPPING_EXPRESSION_MISSING_CLOSING_BRACE},
							false,
							/*[]ast.Token{
								{Type: ast.MAPPING_KEYWORD, Span: NodeSpan{0, 7}},
								{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{8, 9}},
							},*/
						},
					},
				},
			}, n)
		})

		t.Run("empty, missing closing brace before closing parenthesis", func(t *testing.T) {
			n, err := parseChunk(t, `(Mapping {)`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.MappingExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 10},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_MAPPING_EXPRESSION_MISSING_CLOSING_BRACE},
							true,
						},
					},
				},
			}, n)
		})

		t.Run("empty, missing closing brace before closing bracket", func(t *testing.T) {
			_, err := parseChunk(t, `[Mapping {]`, "")
			assert.ErrorContains(t, err, UNTERMINATED_MAPPING_EXPRESSION_MISSING_CLOSING_BRACE)
		})

		t.Run("static entry", func(t *testing.T) {
			n := mustparseChunk(t, "Mapping { 0 => 1 }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.MappingExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 18}},
						Entries: []ast.Node{
							&ast.StaticMappingEntry{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 16},
									nil,
									false,
								},
								Key: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Raw:      "0",
									Value:    0,
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("static entry: missing closing brace before closing parenthesis", func(t *testing.T) {
			n, err := parseChunk(t, `(Mapping { 0 => 1)`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.MappingExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 17},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_MAPPING_EXPRESSION_MISSING_CLOSING_BRACE},
							true,
						},
						Entries: []ast.Node{
							&ast.StaticMappingEntry{
								NodeBase: ast.NodeBase{
									NodeSpan{11, 17},
									nil,
									false,
								},
								Key: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
									Raw:      "0",
									Value:    0,
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("static entry: missing closing brace before closing bracket", func(t *testing.T) {
			_, err := parseChunk(t, `[Mapping { 0 => 1]`, "")
			assert.ErrorContains(t, err, UNTERMINATED_MAPPING_EXPRESSION_MISSING_CLOSING_BRACE)
		})

		t.Run("static entry: missing closing brace", func(t *testing.T) {
			n, err := parseChunk(t, "Mapping { 0 => 1", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MappingExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 16},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_MAPPING_EXPRESSION_MISSING_CLOSING_BRACE},
							false,
							/*[]ast.Token{
								{Type: ast.MAPPING_KEYWORD, Span: NodeSpan{0, 7}},
								{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{8, 9}},
							},*/
						},
						Entries: []ast.Node{
							&ast.StaticMappingEntry{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 16},
									nil,
									false,
								},
								Key: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Raw:      "0",
									Value:    0,
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("static entry: missing value", func(t *testing.T) {
			n, err := parseChunk(t, "Mapping { 0 => }", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MappingExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 16},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.MAPPING_KEYWORD, Span: NodeSpan{0, 7}},
								{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{8, 9}},
								{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{15, 16}},
							},*/
						},
						Entries: []ast.Node{
							&ast.StaticMappingEntry{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 16},
									nil,
									false,
								},
								Key: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Raw:      "0",
									Value:    0,
								},
								Value: &ast.MissingExpression{
									NodeBase: ast.NodeBase{
										NodeSpan{15, 16},
										&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("Mapping { 0 => }"), 15, true)},
										false,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("two static entries", func(t *testing.T) {
			n := mustparseChunk(t, "Mapping { 0 => 1    2 => 3 }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.MappingExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 28},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.MAPPING_KEYWORD, Span: NodeSpan{0, 7}},
								{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{8, 9}},
								{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{27, 28}},
							},*/
						},
						Entries: []ast.Node{
							&ast.StaticMappingEntry{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 16},
									nil,
									false,
								},
								Key: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Raw:      "0",
									Value:    0,
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
							&ast.StaticMappingEntry{
								NodeBase: ast.NodeBase{
									NodeSpan{20, 26},
									nil,
									false,
								},
								Key: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
									Raw:      "2",
									Value:    2,
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{25, 26}, nil, false},
									Raw:      "3",
									Value:    3,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("dynamic entry", func(t *testing.T) {
			n := mustparseChunk(t, "Mapping { n 0 => n }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.MappingExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 20},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.MAPPING_KEYWORD, Span: NodeSpan{0, 7}},
								{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{8, 9}},
								{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{19, 20}},
							},*/
						},
						Entries: []ast.Node{
							&ast.DynamicMappingEntry{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 18},
									nil,
									false,
								},
								Key: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
									Raw:      "0",
									Value:    0,
								},
								KeyVar: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "n",
								},
								ValueComputation: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
									Name:     "n",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("dynamic entry var should not be a keyword", func(t *testing.T) {
			n, err := parseChunk(t, "Mapping { manifest 0 => n }", "")
			assert.NotNil(t, n)
			assert.ErrorContains(t, err, KEYWORDS_SHOULD_NOT_BE_USED_IN_ASSIGNMENT_LHS)
		})

		t.Run("dynamic entry with group matching variable", func(t *testing.T) {
			n := mustparseChunk(t, "Mapping { p %/ m => m }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.MappingExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 23},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.MAPPING_KEYWORD, Span: NodeSpan{0, 7}},
								{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{8, 9}},
								{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{22, 23}},
							},*/
						},
						Entries: []ast.Node{
							&ast.DynamicMappingEntry{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 21},
									nil,
									false,
								},
								Key: &ast.AbsolutePathPatternLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 14}, nil, false},
									Raw:      "%/",
									Value:    "/",
								},
								KeyVar: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Name:     "p",
								},
								GroupMatchingVariable: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
									Name:     "m",
								},
								ValueComputation: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
									Name:     "m",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("group matching variable should not be a keyword", func(t *testing.T) {
			n, err := parseChunk(t, "Mapping { p %/ manifest => m  }", "")
			assert.NotNil(t, n)
			assert.ErrorContains(t, err, KEYWORDS_SHOULD_NOT_BE_USED_IN_ASSIGNMENT_LHS)
		})

		t.Run("dynamic entry: missing closing brace before closing parenthesis", func(t *testing.T) {
			n, err := parseChunk(t, `(Mapping { n 0 => n)`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.MappingExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 19},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_MAPPING_EXPRESSION_MISSING_CLOSING_BRACE},
							true,
						},
						Entries: []ast.Node{
							&ast.DynamicMappingEntry{
								NodeBase: ast.NodeBase{
									NodeSpan{11, 19},
									nil,
									false,
								},
								Key: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
									Raw:      "0",
									Value:    0,
								},
								KeyVar: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
									Name:     "n",
								},
								ValueComputation: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{18, 19}, nil, false},
									Name:     "n",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("dynamic entry: missing closing brace before closing bracket", func(t *testing.T) {
			_, err := parseChunk(t, `[Mapping { n 0 => n]`, "")
			assert.ErrorContains(t, err, UNTERMINATED_MAPPING_EXPRESSION_MISSING_CLOSING_BRACE)
		})

	})

	t.Run("treedata expression", func(t *testing.T) {
		t.Run("empty", func(t *testing.T) {
			n := mustparseChunk(t, `treedata 0 {}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.TreedataLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							nil,
							false,
						},
						Root: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "0",
							Value:    0,
						},
					},
				},
			}, n)
		})

		t.Run("empty, missing closing brace", func(t *testing.T) {
			n, err := parseChunk(t, `treedata 0 {`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.TreedataLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_TREEDATA_LIT_MISSING_CLOSING_BRACE},
							false,
						},
						Root: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "0",
							Value:    0,
						},
					},
				},
			}, n)
		})

		t.Run("empty, missing closing brace before closing parenthesis", func(t *testing.T) {
			n, err := parseChunk(t, `(treedata 0 {)`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.TreedataLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 13},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_TREEDATA_LIT_MISSING_CLOSING_BRACE},
							true,
						},
						Root: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
							Raw:      "0",
							Value:    0,
						},
					},
				},
			}, n)
		})

		t.Run("single entry with children", func(t *testing.T) {
			n := mustparseChunk(t, "treedata 0 { 0 {} }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.TreedataLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 19},
							nil,
							false,
						},
						Root: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "0",
							Value:    0,
						},
						Children: []*ast.TreedataEntry{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{13, 17},
									nil,
									false,
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
									Raw:      "0",
									Value:    0,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single entry without children", func(t *testing.T) {
			n := mustparseChunk(t, "treedata 0 { 0 }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.TreedataLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 16},
							nil,
							false,
						},
						Root: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "0",
							Value:    0,
						},
						Children: []*ast.TreedataEntry{
							{
								NodeBase: ast.NodeBase{NodeSpan{13, 15}, nil, false},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
									Raw:      "0",
									Value:    0,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("missing closing brace after entry and before closing parenthesis", func(t *testing.T) {
			n, err := parseChunk(t, "(treedata 0 { 0 )", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.TreedataLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 16},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_TREEDATA_LIT_MISSING_CLOSING_BRACE},
							true,
						},
						Root: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
							Raw:      "0",
							Value:    0,
						},
						Children: []*ast.TreedataEntry{
							{
								NodeBase: ast.NodeBase{NodeSpan{14, 16}, nil, false},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Raw:      "0",
									Value:    0,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single pair entry: space around colon", func(t *testing.T) {
			n := mustparseChunk(t, "treedata 0 { 0 : 1 }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.TreedataLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 20},
							nil,
							false,
						},
						Root: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "0",
							Value:    0,
						},
						Children: []*ast.TreedataEntry{
							{
								NodeBase: ast.NodeBase{NodeSpan{13, 18}, nil, false},
								Value: &ast.TreedataPair{
									NodeBase: ast.NodeBase{NodeSpan{13, 18}, nil, false},
									Key: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
										Raw:      "0",
										Value:    0,
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single pair entry: no space around colon", func(t *testing.T) {
			n := mustparseChunk(t, "treedata 0 { 0:1 }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.TreedataLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 18},
							nil,
							false,
						},
						Root: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "0",
							Value:    0,
						},
						Children: []*ast.TreedataEntry{
							{
								NodeBase: ast.NodeBase{NodeSpan{13, 16}, nil, false},
								Value: &ast.TreedataPair{
									NodeBase: ast.NodeBase{NodeSpan{13, 16}, nil, false},
									Key: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
										Raw:      "0",
										Value:    0,
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single pair entry: space before colon", func(t *testing.T) {
			n := mustparseChunk(t, "treedata 0 { 0 :1 }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.TreedataLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 19},
							nil,
							false,
						},
						Root: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "0",
							Value:    0,
						},
						Children: []*ast.TreedataEntry{
							{
								NodeBase: ast.NodeBase{NodeSpan{13, 17}, nil, false},
								Value: &ast.TreedataPair{
									NodeBase: ast.NodeBase{NodeSpan{13, 17}, nil, false},
									Key: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
										Raw:      "0",
										Value:    0,
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("two entries", func(t *testing.T) {
			n := mustparseChunk(t, "treedata 0 { 0 {} 1 {} }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.TreedataLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 24},
							nil,
							false,
						},
						Root: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "0",
							Value:    0,
						},
						Children: []*ast.TreedataEntry{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{13, 17},
									nil,
									false,
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
									Raw:      "0",
									Value:    0,
								},
							},
							{
								NodeBase: ast.NodeBase{
									NodeSpan{18, 22},
									nil,
									false,
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{18, 19}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("two entries separated by a comma", func(t *testing.T) {
			n := mustparseChunk(t, "treedata 0 { 0 {}, 1 {} }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.TreedataLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 25},
							nil,
							false,
						},
						Root: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "0",
							Value:    0,
						},
						Children: []*ast.TreedataEntry{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{13, 17},
									nil,
									false,
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
									Raw:      "0",
									Value:    0,
								},
							},
							{
								NodeBase: ast.NodeBase{
									NodeSpan{19, 23},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{18, 19}},
										{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{19, 20}},
									},*/
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{19, 20}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("two entries without braces", func(t *testing.T) {
			n := mustparseChunk(t, "treedata 0 { 0 1 }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.TreedataLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 18},
							nil,
							false,
						},
						Root: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
							Raw:      "0",
							Value:    0,
						},
						Children: []*ast.TreedataEntry{
							{
								NodeBase: ast.NodeBase{NodeSpan{13, 15}, nil, false},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
									Raw:      "0",
									Value:    0,
								},
							},
							{
								NodeBase: ast.NodeBase{NodeSpan{15, 17}, nil, false},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

	})

	t.Run("testsuite expression", func(t *testing.T) {
		t.Run("no meta", func(t *testing.T) {
			n := mustparseChunk(t, `testsuite {}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.TestSuiteExpression{
						IsStatement: true,
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							nil,
							false,
						},
						Module: &ast.EmbeddedModule{
							NodeBase: ast.NodeBase{
								NodeSpan{10, 12},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{10, 11}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{11, 12}},
								},*/
							},
						},
					},
				},
			}, n)
		})

		t.Run("with meta", func(t *testing.T) {
			n := mustparseChunk(t, `testsuite "name" {}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.TestSuiteExpression{
						IsStatement: true,
						NodeBase: ast.NodeBase{
							NodeSpan{0, 19},
							nil,
							false,
						},
						Meta: &ast.DoubleQuotedStringLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{10, 16},
							},
							Raw:   `"name"`,
							Value: "name",
						},
						Module: &ast.EmbeddedModule{
							NodeBase: ast.NodeBase{
								NodeSpan{17, 19},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{17, 18}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{18, 19}},
								},*/
							},
						},
					},
				},
			}, n)
		})

		t.Run("embedded module with manifest", func(t *testing.T) {
			n := mustparseChunk(t, `testsuite { manifest {} }`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.TestSuiteExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 25},
							nil,
							false,
						},
						IsStatement: true,
						Module: &ast.EmbeddedModule{
							NodeBase: ast.NodeBase{
								NodeSpan{10, 25},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{10, 11}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{24, 25}},
								},*/
							},
							Manifest: &ast.Manifest{
								NodeBase: ast.NodeBase{
									Span:            NodeSpan{12, 23},
									IsParenthesized: false,
									/*[]ast.Token{
										{Type: inoxconsts.MANIFEST_KEYWORD, Span: NodeSpan{12, 20}},
									},*/
								},
								Object: &ast.ObjectLiteral{
									NodeBase: ast.NodeBase{
										NodeSpan{21, 23},
										nil,
										false,
										/*[]ast.Token{
											{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{21, 22}},
											{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{22, 23}},
										},*/
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("missing embedded module and no meta", func(t *testing.T) {
			n, err := parseChunk(t, `testsuite`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.TestSuiteExpression{
						IsStatement: true,
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							&sourcecode.ParsingError{MissingBlock, UNTERMINATED_TESTSUITE_EXPRESSION_MISSING_BLOCK},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("with meta but missing embedded module", func(t *testing.T) {
			n, err := parseChunk(t, `testsuite "name"`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.TestSuiteExpression{
						IsStatement: true,
						NodeBase: ast.NodeBase{
							NodeSpan{0, 16},
							&sourcecode.ParsingError{MissingBlock, UNTERMINATED_TESTSUITE_EXPRESSION_MISSING_BLOCK},
							false,
						},
						Meta: &ast.DoubleQuotedStringLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{10, 16},
							},
							Raw:   `"name"`,
							Value: "name",
						},
					},
				},
			}, n)
		})

	})

	t.Run("testcase expression", func(t *testing.T) {
		t.Run("no meta", func(t *testing.T) {
			n := mustparseChunk(t, `testcase {}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.TestCaseExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							nil,
							false,
						},
						IsStatement: true,
						Module: &ast.EmbeddedModule{
							NodeBase: ast.NodeBase{
								NodeSpan{9, 11},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{9, 10}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{10, 11}},
								},*/
							},
						},
					},
				},
			}, n)
		})

		t.Run("with meta", func(t *testing.T) {
			n := mustparseChunk(t, `testcase "name" {}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.TestCaseExpression{
						IsStatement: true,
						NodeBase: ast.NodeBase{
							NodeSpan{0, 18},
							nil,
							false,
						},
						Meta: &ast.DoubleQuotedStringLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{9, 15},
							},
							Raw:   `"name"`,
							Value: "name",
						},
						Module: &ast.EmbeddedModule{
							NodeBase: ast.NodeBase{
								NodeSpan{16, 18},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{16, 17}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{17, 18}},
								},*/
							},
						},
					},
				},
			}, n)
		})

		t.Run("missing embedded module and no meta", func(t *testing.T) {
			n, err := parseChunk(t, `testcase`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.TestCaseExpression{
						IsStatement: true,
						NodeBase: ast.NodeBase{
							NodeSpan{0, 8},
							&sourcecode.ParsingError{MissingBlock, UNTERMINATED_TESTCASE_EXPRESSION_MISSING_BLOCK},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("with meta but missing embedded module", func(t *testing.T) {
			n, err := parseChunk(t, `testcase "name"`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.TestCaseExpression{
						IsStatement: true,
						NodeBase: ast.NodeBase{
							NodeSpan{0, 15},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_TESTCASE_EXPRESSION_MISSING_BLOCK},
							false,
						},
						Meta: &ast.DoubleQuotedStringLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{9, 15},
							},
							Raw:   `"name"`,
							Value: "name",
						},
					},
				},
			}, n)
		})

	})

	t.Run("compute expression", func(t *testing.T) {
		t.Run("missing expr", func(t *testing.T) {
			n, err := parseChunk(t, `comp`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.ComputeExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							nil,
							false,
						},
						Arg: &ast.MissingExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{3, 4},
								&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("comp"), 4, true)},
								false,
							},
						},
					},
				},
			}, n)
		})

		t.Run("ok", func(t *testing.T) {
			n := mustparseChunk(t, `comp 1`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.ComputeExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							nil,
							false,
						},
						Arg: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
							Raw:      "1",
							Value:    1,
						},
					},
				},
			}, n)
		})
	})

	t.Run("permission dropping statement", func(t *testing.T) {
		t.Run("empty object literal", func(t *testing.T) {
			n := mustparseChunk(t, "drop-perms {}")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.PermissionDroppingStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							nil,
							false,
						},
						Object: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{11, 13},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{11, 12}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{12, 13}},
								},*/
							},
						},
					},
				},
			}, n)
		})

		t.Run("value is not an object literal", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, "drop-perms 1")
			})
		})

		t.Run("value is not an object literal", func(t *testing.T) {
			assert.Panics(t, func() {
				mustparseChunk(t, "drop-perms")
			})
		})

	})

	t.Run("return statement", func(t *testing.T) {
		t.Run("value", func(t *testing.T) {
			n := mustparseChunk(t, "return 1")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.ReturnStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 8},
							nil,
							false,
						},
						Expr: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
							Raw:      "1",
							Value:    1,
						},
					},
				},
			}, n)
		})

		t.Run("no value", func(t *testing.T) {
			n := mustparseChunk(t, "return")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.ReturnStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							nil,
							false,
						},
					},
				},
			}, n)
		})

		t.Run("no value, followed by line feed", func(t *testing.T) {
			n := mustparseChunk(t, "return\n")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 7},
					nil,
					false,
					/*[]ast.Token{
						{Type: ast.NEWLINE, Span: NodeSpan{6, 7}},
					},*/
				},
				Statements: []ast.Node{
					&ast.ReturnStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							nil,
							false,
						},
					},
				},
			}, n)
		})

	})

	t.Run("coyield statement", func(t *testing.T) {
		t.Run("value", func(t *testing.T) {
			n := mustparseChunk(t, "coyield 1")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.CoyieldStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							nil,
							false,
						},
						Expr: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Raw:      "1",
							Value:    1,
						},
					},
				},
			}, n)
		})

		t.Run("no value", func(t *testing.T) {
			n := mustparseChunk(t, "coyield")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.CoyieldStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							nil,
							false,
						},
					},
				},
			}, n)
		})

		t.Run("no value, followed by line feed", func(t *testing.T) {
			n := mustparseChunk(t, "coyield\n")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
				Statements: []ast.Node{
					&ast.CoyieldStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}},
					},
				},
			}, n)
		})

	})

	t.Run("yield statement", func(t *testing.T) {

		t.Run("value", func(t *testing.T) {
			n := mustparseChunk(t, "yield 1")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.YieldStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}},
						Expr: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
							Raw:      "1",
							Value:    1,
						},
					},
				},
			}, n)
		})

		t.Run("no value", func(t *testing.T) {
			n := mustparseChunk(t, "yield")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.YieldStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 5}},
					},
				},
			}, n)
		})

		t.Run("no value, followed by line feed", func(t *testing.T) {
			n := mustparseChunk(t, "yield\n")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
				Statements: []ast.Node{
					&ast.YieldStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 5}},
					},
				},
			}, n)
		})
	})

	t.Run("boolean conversion expression", func(t *testing.T) {
		t.Run("variable", func(t *testing.T) {
			n := mustparseChunk(t, "$err?")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.BooleanConversionExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Expr: &ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "err",
						},
					},
				},
			}, n)
		})

		t.Run("identifier", func(t *testing.T) {
			n := mustparseChunk(t, "err?")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.BooleanConversionExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Expr: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
							Name:     "err",
						},
					},
				},
			}, n)
		})

		t.Run("identifier member expression", func(t *testing.T) {
			n := mustparseChunk(t, "a.b?")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.BooleanConversionExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Expr: &ast.IdentifierMemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
							PropertyNames: []*ast.IdentifierLiteral{
								{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Name:     "b",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("member expression", func(t *testing.T) {
			n := mustparseChunk(t, "$a.b?")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.BooleanConversionExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Expr: &ast.MemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
								Name:     "a",
							},
							PropertyName: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("optional member expression", func(t *testing.T) {
			n := mustparseChunk(t, "$a.?b?")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.BooleanConversionExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Expr: &ast.MemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
								Name:     "a",
							},
							PropertyName: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
								Name:     "b",
							},
							Optional: true,
						},
					},
				},
			}, n)
		})

		t.Run("optional member expression", func(t *testing.T) {
			n := mustparseChunk(t, "a.?b?")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.BooleanConversionExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Expr: &ast.MemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Left: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
								Name:     "a",
							},
							PropertyName: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Name:     "b",
							},
							Optional: true,
						},
					},
				},
			}, n)
		})
	})

	t.Run("concatenation expression", func(t *testing.T) {
		t.Run("missing elements: end of chunk", func(t *testing.T) {
			n, err := parseChunk(t, `concat`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.ConcatenationExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_CONCAT_EXPR_ELEMS_EXPECTED},
							false,
						},
						Elements: nil,
					},
				},
			}, n)
		})

		t.Run("missing elements: line feed", func(t *testing.T) {
			n, err := parseChunk(t, "concat\n", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 7},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.ConcatenationExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_CONCAT_EXPR_ELEMS_EXPECTED},
							false,
						},
						Elements: nil,
					},
				},
			}, n)
		})

		t.Run("single element", func(t *testing.T) {
			n := mustparseChunk(t, `concat "a"`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.ConcatenationExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 10},
							nil,
							false,
						},
						Elements: []ast.Node{
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{7, 10}},
								Raw:      `"a"`,
								Value:    "a",
							},
						},
					},
				},
			}, n)
		})

		t.Run("two elements", func(t *testing.T) {
			n := mustparseChunk(t, `concat "a" "b"`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.ConcatenationExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 14},
							nil,
							false,
						},
						Elements: []ast.Node{
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{7, 10}},
								Raw:      `"a"`,
								Value:    "a",
							},
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{11, 14}},
								Raw:      `"b"`,
								Value:    "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("expression is followed by a comma in a list", func(t *testing.T) {
			n := mustparseChunk(t, `[concat "a" "b", "c"]`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.ListLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 21},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.OPENING_BRACKET, Span: NodeSpan{0, 1}},
								{Type: ast.COMMA, Span: NodeSpan{15, 16}},
								{Type: ast.CLOSING_BRACKET, Span: NodeSpan{20, 21}},
							},*/
						},
						Elements: []ast.Node{
							&ast.ConcatenationExpression{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 15},
									nil,
									false,
								},
								Elements: []ast.Node{
									&ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{8, 11}},
										Raw:      `"a"`,
										Value:    "a",
									},
									&ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{12, 15}},
										Raw:      `"b"`,
										Value:    "b",
									},
								},
							},
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{17, 20}},
								Raw:      `"c"`,
								Value:    "c",
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized with a linefeed after the keyword", func(t *testing.T) {
			n := mustparseChunk(t, "(concat\na)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.ConcatenationExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 9},
							nil,
							true,
						},
						Elements: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{8, 9}},
								Name:     "a",
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized with a comment and linefeed after the keyword", func(t *testing.T) {
			n := mustparseChunk(t, "(concat # comment\na)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.ConcatenationExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 19},
							nil,
							true,
						},
						Elements: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{18, 19}},
								Name:     "a",
							},
						},
					},
				},
			}, n)
		})

		t.Run("spread element", func(t *testing.T) {
			n := mustparseChunk(t, `concat ...a`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.ConcatenationExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							nil,
							false,
						},
						Elements: []ast.Node{
							&ast.ElementSpreadElement{
								NodeBase: ast.NodeBase{
									Span:            NodeSpan{7, 11},
									IsParenthesized: false,
								},
								Expr: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{10, 11}},
									Name:     "a",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("spread element after another element", func(t *testing.T) {
			n := mustparseChunk(t, `concat a ...b`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.ConcatenationExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 13}},
						Elements: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{7, 8}},
								Name:     "a",
							},
							&ast.ElementSpreadElement{
								NodeBase: ast.NodeBase{
									Span:            NodeSpan{9, 13},
									IsParenthesized: false,
								},
								Expr: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{12, 13}},
									Name:     "b",
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("pattern identifier literal", func(t *testing.T) {
		t.Run("pattern identifier literal", func(t *testing.T) {
			n := mustparseChunk(t, "%int")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.PatternIdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Name:     "int",
					},
				},
			}, n)
		})

		t.Run("percent only", func(t *testing.T) {
			n, err := parseChunk(t, "%", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
				Statements: []ast.Node{
					&ast.UnknownNode{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 1},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_PATT},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("percent followed by line feed", func(t *testing.T) {
			n, err := parseChunk(t, "%\n", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 2},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.UnknownNode{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 1},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_PATT},
							false,
						},
					},
				},
			}, n)
		})
	})

	t.Run("pattern namespace identifier literal", func(t *testing.T) {
		n := mustparseChunk(t, "%mynamespace.")
		assert.EqualValues(t, &ast.Chunk{
			NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
			Statements: []ast.Node{
				&ast.PatternNamespaceIdentifierLiteral{
					NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
					Name:     "mynamespace",
				},
			},
		}, n)
	})

	t.Run("object pattern", func(t *testing.T) {

		t.Run("property", func(t *testing.T) {
			n := mustparseChunk(t, "%{ prop: int }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 12}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{Start: 3, End: 7}},
									Name:     "prop",
								},
								Value: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{9, 12}},
									Name:       "int",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("property: key is an unquoted region", func(t *testing.T) {
			n := mustparseChunk(t, "@(%{ <{a}>: int })")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 18}},
						Expression: &ast.ObjectPatternLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{2, 17}, IsParenthesized: true},
							Properties: []*ast.ObjectPatternProperty{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 15}},
									Key: &ast.UnquotedRegion{
										NodeBase: ast.NodeBase{Span: NodeSpan{5, 10}},
										Expression: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{Start: 7, End: 8}},
											Name:     "a",
										},
									},
									Value: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{Span: NodeSpan{12, 15}},
										Name:       "int",
										Unprefixed: true,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("property: annotation", func(t *testing.T) {
			n := mustparseChunk(t, "%{ prop: int @public }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 22}},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 21}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{Start: 3, End: 7}},
									Name:     "prop",
								},
								Value: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{9, 12}},
									Name:       "int",
									Unprefixed: true,
								},
								Annotations: &ast.MetadataAnnotations{
									NodeBase: ast.NodeBase{Span: NodeSpan{13, 21}},
									Expressions: []ast.Node{
										&ast.MetaIdentifier{
											NodeBase: ast.NodeBase{Span: NodeSpan{13, 20}},
											Name:     "public",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("property: annotation", func(t *testing.T) {
			n := mustparseChunk(t, "%{ prop: int @public }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 22}},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 21}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{Start: 3, End: 7}},
									Name:     "prop",
								},
								Value: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{9, 12}},
									Name:       "int",
									Unprefixed: true,
								},
								Annotations: &ast.MetadataAnnotations{
									NodeBase: ast.NodeBase{Span: NodeSpan{13, 21}},
									Expressions: []ast.Node{
										&ast.MetaIdentifier{
											NodeBase: ast.NodeBase{Span: NodeSpan{13, 20}},
											Name:     "public",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("property: two annotations separated by a space", func(t *testing.T) {
			n := mustparseChunk(t, "%{ prop: int @public @readonly}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 31}},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 30}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{Start: 3, End: 7}},
									Name:     "prop",
								},
								Value: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{9, 12}},
									Name:       "int",
									Unprefixed: true,
								},
								Annotations: &ast.MetadataAnnotations{
									NodeBase: ast.NodeBase{Span: NodeSpan{13, 30}},
									Expressions: []ast.Node{
										&ast.MetaIdentifier{
											NodeBase: ast.NodeBase{Span: NodeSpan{13, 20}},
											Name:     "public",
										},
										&ast.MetaIdentifier{
											NodeBase: ast.NodeBase{Span: NodeSpan{21, 30}},
											Name:     "readonly",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("property: two annotations separated by a linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "%{ prop: int @public\n@readonly}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 31}},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 30}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{Start: 3, End: 7}},
									Name:     "prop",
								},
								Value: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{9, 12}},
									Name:       "int",
									Unprefixed: true,
								},
								Annotations: &ast.MetadataAnnotations{
									NodeBase: ast.NodeBase{Span: NodeSpan{13, 30}},
									Expressions: []ast.Node{
										&ast.MetaIdentifier{
											NodeBase: ast.NodeBase{Span: NodeSpan{13, 20}},
											Name:     "public",
										},
										&ast.MetaIdentifier{
											NodeBase: ast.NodeBase{Span: NodeSpan{21, 30}},
											Name:     "readonly",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("property: two annotations separated by a comment+linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "%{ prop: int @public# x\n@readonly}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 34}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 34}},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 33}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{Start: 3, End: 7}},
									Name:     "prop",
								},
								Value: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{9, 12}},
									Name:       "int",
									Unprefixed: true,
								},
								Annotations: &ast.MetadataAnnotations{
									NodeBase: ast.NodeBase{Span: NodeSpan{13, 33}},
									Expressions: []ast.Node{
										&ast.MetaIdentifier{
											NodeBase: ast.NodeBase{Span: NodeSpan{13, 20}},
											Name:     "public",
										},
										&ast.MetaIdentifier{
											NodeBase: ast.NodeBase{Span: NodeSpan{24, 33}},
											Name:     "readonly",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("two properties: first one has an annotation followed by a comma", func(t *testing.T) {
			n := mustparseChunk(t, "%{ prop: int @public, other_prop: int }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 39}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 39}},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 20}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{Start: 3, End: 7}},
									Name:     "prop",
								},
								Value: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{9, 12}},
									Name:       "int",
									Unprefixed: true,
								},
								Annotations: &ast.MetadataAnnotations{
									NodeBase: ast.NodeBase{Span: NodeSpan{13, 20}},
									Expressions: []ast.Node{
										&ast.MetaIdentifier{
											NodeBase: ast.NodeBase{Span: NodeSpan{13, 20}},
											Name:     "public",
										},
									},
								},
							},
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{22, 37}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{Start: 22, End: 32}},
									Name:     "other_prop",
								},
								Value: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{34, 37}},
									Name:       "int",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		// t.Run("{ ... } ", func(t *testing.T) {
		// 	n := mustparseChunk(t,"%{ ... }")
		// 	assert.EqualValues(t, &ast.Chunk{
		// 		NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
		// 		Statements: []ast.Node{
		// 			&ast.ObjectPatternLiteral{
		// 				NodeBase: ast.NodeBase{
		// 					NodeSpan{0, 8},
		// 					nil,
		// 					[]ast.Token{
		// 						{Type: ast.OPENING_OBJECT_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
		// 						{Type: ast.THREE_DOTS, Span: NodeSpan{3, 6}},
		// 						{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{7, 8}},
		// 					},
		// 				},
		//
		// 			},
		// 		},
		// 	}, n)
		// })

		// t.Run("{ ... , name: %str } ", func(t *testing.T) {
		// 	n := mustparseChunk(t,"%{ ... , name: %str }")
		// 	assert.EqualValues(t, &ast.Chunk{
		// 		NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
		// 		Statements: []ast.Node{
		// 			&ast.ObjectPatternLiteral{
		// 				NodeBase: ast.NodeBase{
		// 					NodeSpan{0, 21},
		// 					nil,
		// 					[]ast.Token{
		// 						{Type: ast.OPENING_OBJECT_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
		// 						{Type: ast.THREE_DOTS, Span: NodeSpan{3, 6}},
		// 						{Type: ast.COMMA, Span: NodeSpan{7, 8}},
		// 						{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{20, 21}},
		// 					},
		// 				},
		//
		// 				Properties: []*ast.ObjectPatternProperty{
		// 					{
		// 						NodeBase: ast.NodeBase{
		// 							NodeSpan{9, 19},
		// 							nil,
		// 							false,
		// 						},
		// 						Key: &ast.IdentifierLiteral{
		// 							NodeBase: ast.NodeBase{NodeSpan{9, 13}, nil, false},
		// 							Name:     "name",
		// 						},
		// 						Value: &ast.PatternIdentifierLiteral{
		// 							NodeBase: ast.NodeBase{NodeSpan{15, 19}, nil, false},
		// 							Name:     "str",
		// 						},
		// 					},
		// 				},
		// 			},
		// 		},
		// 	}, n)
		// })

		// t.Run("{ ... \n } ", func(t *testing.T) {
		// 	n := mustparseChunk(t,"%{ ... \n }")
		// 	assert.EqualValues(t, &ast.Chunk{
		// 		NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
		// 		Statements: []ast.Node{
		// 			&ast.ObjectPatternLiteral{
		// 				NodeBase: ast.NodeBase{
		// 					NodeSpan{0, 10},
		// 					nil,
		// 					[]ast.Token{
		// 						{Type: ast.OPENING_OBJECT_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
		// 						{Type: ast.THREE_DOTS, Span: NodeSpan{3, 6}},
		// 						{Type: ast.NEWLINE, Span: NodeSpan{7, 8}},
		// 						{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{9, 10}},
		// 					},
		// 				},
		//
		// 			},
		// 		},
		// 	}, n)
		// })

		t.Run("{ ...named-pattern } ", func(t *testing.T) {
			n := mustparseChunk(t, "%{ ...%patt }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							Span: NodeSpan{0, 13},
						},

						SpreadElements: []*ast.PatternPropertySpreadElement{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{3, 11},
									nil,
									false,
								},
								Expr: &ast.PatternIdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{6, 11}, nil, false},
									Name:     "patt",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("{ ...unprefixed named-pattern } ", func(t *testing.T) {
			n := mustparseChunk(t, "%{ ...patt }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							Span: NodeSpan{0, 12},
						},

						SpreadElements: []*ast.PatternPropertySpreadElement{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{3, 10},
									nil,
									false,
								},
								Expr: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{6, 10}, nil, false},
									Unprefixed: true,
									Name:       "patt",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("{ prop, ...named-pattern } ", func(t *testing.T) {
			n, err := parseChunk(t, "%{ name: %str,  ...%patt }", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 26}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 26}},

						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{3, 13},
									nil,
									false,
								},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 7}, nil, false},
									Name:     "name",
								},
								Value: &ast.PatternIdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{9, 13}, nil, false},
									Name:     "str",
								},
							},
						},
						SpreadElements: []*ast.PatternPropertySpreadElement{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{16, 24},
									&sourcecode.ParsingError{UnspecifiedParsingError, SPREAD_SHOULD_BE_LOCATED_AT_THE_START},
									false,
								},
								Expr: &ast.PatternIdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{19, 24}, nil, false},
									Name:     "patt",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("{ prop with unprefixed named pattern, ...named-pattern } ", func(t *testing.T) {
			n, err := parseChunk(t, "%{ name: str,  ...%patt }", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							Span: NodeSpan{0, 25},
						},

						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{3, 12},
									nil,
									false,
								},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 7}, nil, false},
									Name:     "name",
								},
								Value: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{9, 12}, nil, false},
									Unprefixed: true,
									Name:       "str",
								},
							},
						},
						SpreadElements: []*ast.PatternPropertySpreadElement{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{15, 23},
									&sourcecode.ParsingError{UnspecifiedParsingError, SPREAD_SHOULD_BE_LOCATED_AT_THE_START},
									false,
								},
								Expr: &ast.PatternIdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{18, 23}, nil, false},
									Name:     "patt",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("{  ...named-pattern, prop with unprefixed named pattern } ", func(t *testing.T) {
			n := mustparseChunk(t, "%{ ...%patt, name: str }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 24}},

						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{13, 22},
									nil,
									false,
								},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 17}, nil, false},
									Name:     "name",
								},
								Value: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{19, 22}, nil, false},
									Unprefixed: true,
									Name:       "str",
								},
							},
						},
						SpreadElements: []*ast.PatternPropertySpreadElement{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{3, 11},
									nil,
									false,
								},
								Expr: &ast.PatternIdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{6, 11}, nil, false},
									Name:     "patt",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("{ prop with keylist value } ", func(t *testing.T) {
			n := mustparseChunk(t, "%{keys: .{a}}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.OPENING_OBJECT_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
								{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{12, 13}},
							},*/
						},

						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{2, 12},
									nil,
									false,
								},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 6}, nil, false},
									Name:     "keys",
								},
								Value: &ast.KeyListExpression{
									NodeBase: ast.NodeBase{Span: NodeSpan{Start: 8, End: 12}},
									Keys: []ast.Node{
										&ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{10, 11}},
											Name:     "a",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("{ optional prop } ", func(t *testing.T) {
			n := mustparseChunk(t, "%{ name?: %str }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 16}},

						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 14}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 7}, nil, false},
									Name:     "name",
								},
								Value: &ast.PatternIdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 14}, nil, false},
									Name:     "str",
								},
								Optional: true,
							},
						},
					},
				},
			}, n)
		})

		t.Run("property value is an unprefixed list pattern", func(t *testing.T) {
			n := mustparseChunk(t, "%{ list: [ 1 ] }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 16}},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 14}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{Start: 3, End: 7}},
									Name:     "list",
								},
								Value: &ast.ListPatternLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{9, 14}},
									Elements: []ast.Node{
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("property value is an unprefixed union pattern", func(t *testing.T) {
			n := mustparseChunk(t, "%{ prop: | a | b }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							Span: NodeSpan{0, 18},
						},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 17}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{Start: 3, End: 7}},
									Name:     "prop",
								},
								Value: &ast.PatternUnion{
									NodeBase: ast.NodeBase{Span: NodeSpan{9, 17}},
									Cases: []ast.Node{
										&ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Unprefixed: true,
											Name:       "a",
										},
										&ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{15, 16}, nil, false},
											Unprefixed: true,
											Name:       "b",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("property value is an exact value pattern for an object (pattern conversion)", func(t *testing.T) {
			n := mustparseChunk(t, "%{ prop: %({}) }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 16}},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 14}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{Start: 3, End: 7}},
									Name:     "prop",
								},
								Value: &ast.PatternConversionExpression{
									NodeBase: ast.NodeBase{Span: NodeSpan{9, 13}},
									Value: &ast.ObjectLiteral{
										NodeBase: ast.NodeBase{
											NodeSpan{11, 13},
											nil,
											true,
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("otherprops", func(t *testing.T) {
			n := mustparseChunk(t, "%{otherprops int}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 17}},
						OtherProperties: []*ast.OtherPropsExpr{
							{
								NodeBase: ast.NodeBase{
									Span:            NodeSpan{2, 16},
									IsParenthesized: false,
								},
								Pattern: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{13, 16}},
									Unprefixed: true,
									Name:       "int",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("otherprops no", func(t *testing.T) {
			n := mustparseChunk(t, "%{otherprops no}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							Span: NodeSpan{0, 16},
						},
						OtherProperties: []*ast.OtherPropsExpr{
							{
								NodeBase: ast.NodeBase{
									Span:            NodeSpan{2, 15},
									IsParenthesized: false,
								},
								No: true,
								Pattern: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{13, 15}},
									Unprefixed: true,
									Name:       "no",
								},
							},
						},
					},
				},
			}, n)
		})
		t.Run("otherprops no: parenthesized", func(t *testing.T) {
			n := mustparseChunk(t, "%{otherprops(no)}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 17},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.OPENING_OBJECT_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
								{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{16, 17}},
							},*/
						},
						OtherProperties: []*ast.OtherPropsExpr{
							{
								NodeBase: ast.NodeBase{
									Span:            NodeSpan{2, 15},
									IsParenthesized: false,
								},
								No: true,
								Pattern: &ast.PatternIdentifierLiteral{
									NodeBase: ast.NodeBase{
										Span:            NodeSpan{13, 15},
										IsParenthesized: true,
										/*[]ast.Token{
											{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{12, 13}},
											{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{15, 16}},
										},*/
									},
									Unprefixed: true,
									Name:       "no",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated otherprops followed by '}'", func(t *testing.T) {
			n, err := parseChunk(t, "%{otherprops}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.OPENING_OBJECT_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
								{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{12, 13}},
							},*/
						},
						OtherProperties: []*ast.OtherPropsExpr{
							{
								NodeBase: ast.NodeBase{
									Span:            NodeSpan{2, 13},
									IsParenthesized: false,
								},
								Pattern: &ast.MissingExpression{
									NodeBase: ast.NodeBase{
										NodeSpan{12, 13},
										&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("%{otherprops}"), 12, true)},
										false,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated otherprops at end of file", func(t *testing.T) {
			n, err := parseChunk(t, "%{otherprops", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_PATTERN_MISSING_CLOSING_BRACE},
							false,
							/*[]ast.Token{
								{Type: ast.OPENING_OBJECT_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
							},*/
						},
						OtherProperties: []*ast.OtherPropsExpr{
							{
								NodeBase: ast.NodeBase{
									Span:            NodeSpan{2, 12},
									IsParenthesized: false,
								},
								Pattern: &ast.MissingExpression{
									NodeBase: ast.NodeBase{
										NodeSpan{11, 12},
										&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("%{otherprops"), 12, true)},
										false,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("duplicate key", func(t *testing.T) {
			n, err := parseChunk(t, "%{ a: 1, a: 2}", "")
			assert.NoError(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 14},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.OPENING_OBJECT_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
								{Type: ast.COMMA, Span: NodeSpan{7, 8}},
								{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{13, 14}},
							},*/
						},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{3, 7},
									nil,
									false,
								},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Name:     "a",
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
							{
								NodeBase: ast.NodeBase{
									NodeSpan{9, 13},
									nil,
									false,
								},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
									Name:     "a",
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
									Raw:      "2",
									Value:    2,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("%{,", func(t *testing.T) {
			n, err := parseChunk(t, "%{,", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 3},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_PATTERN_MISSING_CLOSING_BRACE},
							false,
							/*[]ast.Token{
								{Type: ast.OPENING_OBJECT_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
								{Type: ast.COMMA, Span: NodeSpan{2, 3}},
							},*/
						},
					},
				},
			}, n)
		})
		t.Run("%{,}", func(t *testing.T) {
			n := mustparseChunk(t, "%{,}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 4},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.OPENING_OBJECT_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
								{Type: ast.COMMA, Span: NodeSpan{2, 3}},
								{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{3, 4}},
							},*/
						},
					},
				},
			}, n)
		})

		t.Run("line feed after colon", func(t *testing.T) {
			n, err := parseChunk(t, "%{ a:\n}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.OPENING_OBJECT_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
								{Type: ast.NEWLINE, Span: NodeSpan{5, 6}},
								{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{6, 7}},
							},*/
						},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{3, 5},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNEXPECTED_NEWLINE_AFTER_COLON},
									false,
									/*[]ast.Token{
										{Type: ast.COLON, Span: NodeSpan{4, 5}},
									},*/
								},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Name:     "a",
								},
							},
						},
					},
				},
			}, n)

		})

		t.Run("missing property pattern", func(t *testing.T) {
			n, err := parseChunk(t, "%{a:}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 5},
							nil,
							false,
						},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{2, 4},
									&sourcecode.ParsingError{MissingObjectPatternProperty, MISSING_PROPERTY_PATTERN},
									false,
								},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Name:     "a",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("empty pattern with missing closing brace before parenthesis of parent", func(t *testing.T) {
			n, err := parseChunk(t, "(%{)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 3},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_PATTERN_MISSING_CLOSING_BRACE},
							true,
						},
					},
				},
			}, n)
		})

		t.Run("non-empty pattern with missing closing brace before parenthesis of parent", func(t *testing.T) {
			n, err := parseChunk(t, "(%{a:1)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 6},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OBJ_PATTERN_MISSING_CLOSING_BRACE},
							true,
						},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 6}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Name:     "a",
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("non-closing unexpected char after property", func(t *testing.T) {
			n, err := parseChunk(t, "%{a:1?}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{2, 5},
									&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_OBJ_PATT_LIT_ENTRY_SEPARATION},
									false,
								},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
									Name:     "a",
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
							{
								NodeBase: ast.NodeBase{
									NodeSpan{5, 6},
									&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInObjectPattern('?')},
									false,
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("list pattern", func(t *testing.T) {
		t.Run("single element", func(t *testing.T) {
			n := mustparseChunk(t, "%[ 1 ]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.ListPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.OPENING_LIST_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
								{Type: ast.CLOSING_BRACKET, Span: NodeSpan{5, 6}},
							},*/
						},
						Elements: []ast.Node{
							&ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Raw:      "1",
								Value:    1,
							},
						},
					},
				},
			}, n)
		})

		t.Run("single element is an unprefixed named pattern", func(t *testing.T) {
			n := mustparseChunk(t, "%[ a ]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.ListPatternLiteral{
						NodeBase: ast.NodeBase{
							Span: NodeSpan{0, 6},
						},
						Elements: []ast.Node{
							&ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Unprefixed: true,
								Name:       "a",
							},
						},
					},
				},
			}, n)
		})

		t.Run("single element is an unprefixed object pattern", func(t *testing.T) {
			n := mustparseChunk(t, "%[{ name?: %str }]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.ListPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 18}},
						Elements: []ast.Node{
							&ast.ObjectPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 17}},
								Properties: []*ast.ObjectPatternProperty{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{4, 15}},
										Key: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
											Name:     "name",
										},
										Value: &ast.PatternIdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{11, 15}, nil, false},
											Name:     "str",
										},
										Optional: true,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("two elements", func(t *testing.T) {
			n := mustparseChunk(t, "%[ 1, 2 ]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.ListPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.OPENING_LIST_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
								{Type: ast.COMMA, Span: NodeSpan{4, 5}},
								{Type: ast.CLOSING_BRACKET, Span: NodeSpan{8, 9}},
							},*/
						},
						Elements: []ast.Node{
							&ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Raw:      "1",
								Value:    1,
							},
							&ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
								Raw:      "2",
								Value:    2,
							},
						},
					},
				},
			}, n)
		})

		t.Run("general element", func(t *testing.T) {
			n := mustparseChunk(t, "%[]%int")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.ListPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.OPENING_LIST_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
								{Type: ast.CLOSING_BRACKET, Span: NodeSpan{2, 3}},
							},*/
						},
						Elements: nil,
						GeneralElement: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 7}, nil, false},
							Name:     "int",
						},
					},
				},
			}, n)
		})

		t.Run("general element is an unprefixed named pattern", func(t *testing.T) {
			n := mustparseChunk(t, "%[]int")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.ListPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 6}},
						Elements: nil,
						GeneralElement: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{3, 6}, nil, false},
							Unprefixed: true,
							Name:       "int",
						},
					},
				},
			}, n)
		})

		t.Run("general element is an unprefixed object pattern", func(t *testing.T) {
			n := mustparseChunk(t, "%[]{ name?: %str }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.ListPatternLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 18}},
						Elements: nil,
						GeneralElement: &ast.ObjectPatternLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{3, 18},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{3, 4}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{17, 18}},
								},*/
							},

							Properties: []*ast.ObjectPatternProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{5, 16},
										nil,
										false,
										/*[]ast.Token{
											{Type: ast.QUESTION_MARK, Span: NodeSpan{9, 10}},
											{Type: ast.COLON, Span: NodeSpan{10, 11}},
										},*/
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{5, 9}, nil, false},
										Name:     "name",
									},
									Value: &ast.PatternIdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{12, 16}, nil, false},
										Name:     "str",
									},
									Optional: true,
								},
							},
						},
					},
				},
			}, n)
		})

		//TODO: add more tests

		t.Run("elements and general element", func(t *testing.T) {
			n, err := parseChunk(t, "%[1]%int", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.ListPatternLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 8},
							&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_LIST_TUPLE_PATT_GENERAL_ELEMENT_IF_ELEMENTS},
							false,
							/*[]ast.Token{
								{Type: ast.OPENING_LIST_PATTERN_BRACKET, Span: NodeSpan{0, 2}},
								{Type: ast.CLOSING_BRACKET, Span: NodeSpan{3, 4}},
							},*/
						},
						Elements: []ast.Node{
							&ast.IntLiteral{
								NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
								Raw:      "1",
								Value:    1,
							},
						},
						GeneralElement: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{4, 8}, nil, false},
							Name:     "int",
						},
					},
				},
			}, n)
		})
	})

	t.Run("tuple pattern", func(t *testing.T) {
		t.Run("single element", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = #[ 1 ]")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 18},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PATTERN_KEYWORD, Span: NodeSpan{0, 7}},
								{Type: ast.EQUAL, Span: NodeSpan{10, 11}},
							},*/
						},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.TuplePatternLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 18},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_TUPLE_BRACKET, Span: NodeSpan{12, 14}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{17, 18}},
								},*/
							},
							Elements: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("general element", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = #[]int")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 18},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PATTERN_KEYWORD, Span: NodeSpan{0, 7}},
								{Type: ast.EQUAL, Span: NodeSpan{10, 11}},
							},*/
						},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.TuplePatternLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 18},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_TUPLE_BRACKET, Span: NodeSpan{12, 14}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{14, 15}},
								},*/
							},
							Elements: nil,
							GeneralElement: &ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{15, 18}, nil, false},
								Name:       "int",
								Unprefixed: true,
							},
						},
					},
				},
			}, n)
		})

		t.Run("general element: empty tuple pattern", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = #[]#{}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 18},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PATTERN_KEYWORD, Span: NodeSpan{0, 7}},
								{Type: ast.EQUAL, Span: NodeSpan{10, 11}},
							},*/
						},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.TuplePatternLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 18},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_TUPLE_BRACKET, Span: NodeSpan{12, 14}},
									{Type: ast.CLOSING_BRACKET, Span: NodeSpan{14, 15}},
								},*/
							},
							Elements: nil,
							GeneralElement: &ast.RecordPatternLiteral{
								NodeBase: ast.NodeBase{
									NodeSpan{15, 18},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.OPENING_RECORD_BRACKET, Span: NodeSpan{15, 17}},
										{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{17, 18}},
									},*/
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("pattern definition", func(t *testing.T) {
		t.Run("RHS is a pattern identifier literal ", func(t *testing.T) {
			n := mustparseChunk(t, "pattern i = %int")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 16}},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "i",
							Unprefixed: true,
						},
						Right: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{12, 16}, nil, false},
							Name:     "int",
						},
					},
				},
			}, n)
		})

		t.Run("RHS is an unprefixed pattern identifier literal", func(t *testing.T) {
			n := mustparseChunk(t, "pattern i = int")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 15}},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "i",
							Unprefixed: true,
						},
						Right: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{12, 15}, nil, false},
							Name:       "int",
							Unprefixed: true,
						},
					},
				},
			}, n)
		})

		t.Run("RHS is an unprefixed pattern identifier literal with a keyword name", func(t *testing.T) {
			n := mustparseChunk(t, "pattern i = for")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 15}},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "i",
							Unprefixed: true,
						},
						Right: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{12, 15}, nil, false},
							Name:       "for",
							Unprefixed: true,
						},
					},
				},
			}, n)
		})

		t.Run("lazy", func(t *testing.T) {
			n := mustparseChunk(t, "pattern i = @ 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 15}},
						IsLazy:   true,
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "i",
							Unprefixed: true,
						},
						Right: &ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
							Raw:      "1",
							Value:    1,
						},
					},
				},
			}, n)
		})

		t.Run("RHS is an object pattern literal", func(t *testing.T) {
			n := mustparseChunk(t, "pattern i = %{ a: 1 }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 21}},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "i",
							Unprefixed: true,
						},
						Right: &ast.ObjectPatternLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{12, 21}},
							Properties: []*ast.ObjectPatternProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{15, 19},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{18, 19}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("RHS is an unprefixed object pattern literal", func(t *testing.T) {
			n := mustparseChunk(t, "pattern i = %{ a: 1 }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 21}},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "i",
							Unprefixed: true,
						},
						Right: &ast.ObjectPatternLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{12, 21}},
							Properties: []*ast.ObjectPatternProperty{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{15, 19},
										nil,
										false,
									},
									Key: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
										Name:     "a",
									},
									Value: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{18, 19}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("pattern definition : missing RHS", func(t *testing.T) {
			n, err := parseChunk(t, "pattern i =", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							&sourcecode.ParsingError{UnterminatedPatternDefinition, UNTERMINATED_PATT_DEF_MISSING_RHS},
							false,
						},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "i",
							Unprefixed: true,
						},
					},
				},
			}, n)
		})

	})

	t.Run("pattern namespace definition", func(t *testing.T) {
		n := mustparseChunk(t, "pnamespace mynamespace. = {}")
		assert.EqualValues(t, &ast.Chunk{
			NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
			Statements: []ast.Node{
				&ast.PatternNamespaceDefinition{
					NodeBase: ast.NodeBase{Span: NodeSpan{0, 28}},
					Left: &ast.PatternNamespaceIdentifierLiteral{
						NodeBase:   ast.NodeBase{NodeSpan{11, 23}, nil, false},
						Name:       "mynamespace",
						Unprefixed: true,
					},
					Right: &ast.ObjectLiteral{
						NodeBase: ast.NodeBase{Span: NodeSpan{26, 28}},
					},
				},
			},
		}, n)
	})

	t.Run("record pattern", func(t *testing.T) {

		t.Run("{ ...named-pattern } ", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = #{ ...%patt }")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 25}},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.RecordPatternLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{12, 25}},

							SpreadElements: []*ast.PatternPropertySpreadElement{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{15, 23},
										nil,
										false,
									},
									Expr: &ast.PatternIdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{18, 23}, nil, false},
										Name:     "patt",
									},
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("pattern namespace member expression", func(t *testing.T) {
		n := mustparseChunk(t, "%mynamespace.a")
		assert.EqualValues(t, &ast.Chunk{
			NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
			Statements: []ast.Node{
				&ast.PatternNamespaceMemberExpression{
					NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
					Namespace: &ast.PatternNamespaceIdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
						Name:     "mynamespace",
					},
					MemberName: &ast.IdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
						Name:     "a",
					},
				},
			},
		}, n)
	})

	t.Run("complex string pattern", func(t *testing.T) {
		t.Run("one element: string literal", func(t *testing.T) {
			n := mustparseChunk(t, `%str("a")`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase:   ast.NodeBase{NodeSpan{5, 8}, nil, false},
								Quantifier: ast.ExactlyOneOccurrence,
								Expr: &ast.DoubleQuotedStringLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 8}, nil, false},
									Raw:      "\"a\"",
									Value:    "a",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("one element: string literal followed by linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "%str(\"a\"\n)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 10}},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase:   ast.NodeBase{NodeSpan{5, 8}, nil, false},
								Quantifier: ast.ExactlyOneOccurrence,
								Expr: &ast.DoubleQuotedStringLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 8}, nil, false},
									Raw:      "\"a\"",
									Value:    "a",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("one element: int literal (should fail)", func(t *testing.T) {
			n, err := parseChunk(t, `%str(1)`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase:   ast.NodeBase{NodeSpan{5, 6}, nil, false},
								Quantifier: ast.ExactlyOneOccurrence,
								Expr: &ast.InvalidComplexStringPatternElement{
									NodeBase: ast.NodeBase{
										NodeSpan{5, 6},
										&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_COMPLEX_PATTERN_ELEMENT},
										false,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("one element: rune literal", func(t *testing.T) {
			n := mustparseChunk(t, "%str('a')")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 9}},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase:   ast.NodeBase{NodeSpan{5, 8}, nil, false},
								Quantifier: ast.ExactlyOneOccurrence,
								Expr: &ast.RuneLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 8}, nil, false},
									Value:    'a',
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("one element: element is a parenthesized string literal with '*' as ocurrence", func(t *testing.T) {
			n := mustparseChunk(t, `%str(("a")*)`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{5, 11},
									nil,
									false,
								},
								Quantifier: ast.ZeroOrMoreOccurrences,
								Expr: &ast.ComplexStringPatternPiece{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 10}},
									Elements: []*ast.PatternPieceElement{
										{
											NodeBase:   ast.NodeBase{NodeSpan{6, 9}, nil, false},
											Quantifier: ast.ExactlyOneOccurrence,
											Expr: &ast.DoubleQuotedStringLiteral{
												NodeBase: ast.NodeBase{NodeSpan{6, 9}, nil, false},
												Raw:      "\"a\"",
												Value:    "a",
											},
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("one element: element is a parenthesized string literal with '=2' as ocurrence", func(t *testing.T) {
			n := mustparseChunk(t, `%str(("a")=2)`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_STR, Span: NodeSpan{0, 4}},
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{4, 5}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{12, 13}},
							},*/
						},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{5, 12},
									nil,
									false,
								},
								Quantifier:          ast.ExactOccurrenceCount,
								ExactOcurrenceCount: 2,
								Expr: &ast.ComplexStringPatternPiece{
									NodeBase: ast.NodeBase{
										NodeSpan{5, 10},
										nil,
										false,
										/*[]ast.Token{
											{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{5, 6}},
											{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{9, 10}},
										},*/
									},
									Elements: []*ast.PatternPieceElement{
										{
											NodeBase:   ast.NodeBase{NodeSpan{6, 9}, nil, false},
											Quantifier: ast.ExactlyOneOccurrence,
											Expr: &ast.DoubleQuotedStringLiteral{
												NodeBase: ast.NodeBase{NodeSpan{6, 9}, nil, false},
												Raw:      "\"a\"",
												Value:    "a",
											},
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("one element: element is a pattern identifier literal with '=2' as ocurrence", func(t *testing.T) {
			n := mustparseChunk(t, `%str(s=2)`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 9},
							nil,
							false,
						},
						Elements: []*ast.PatternPieceElement{
							{
								Quantifier:          ast.ExactOccurrenceCount,
								ExactOcurrenceCount: 2,
								NodeBase: ast.NodeBase{
									NodeSpan{5, 8},
									nil,
									false,
								},
								Expr: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{5, 6}, nil, false},
									Name:       "s",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("one element: element is a regex literal with '=2' as ocurrence", func(t *testing.T) {
			n := mustparseChunk(t, "%str(%`e`=2)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							nil,
							false,
						},
						Elements: []*ast.PatternPieceElement{
							{
								Quantifier:          ast.ExactOccurrenceCount,
								ExactOcurrenceCount: 2,
								NodeBase: ast.NodeBase{
									NodeSpan{5, 11},
									nil,
									false,
								},
								Expr: &ast.RegularExpressionLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 9}, nil, false},
									Value:    "e",
									Raw:      "%`e`",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("one named element", func(t *testing.T) {
			n := mustparseChunk(t, `%str(l:"a")`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_STR, Span: NodeSpan{0, 4}},
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{4, 5}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{10, 11}},
							},*/
						},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{5, 10},
									nil,
									false,
								},
								Quantifier: ast.ExactlyOneOccurrence,
								Expr: &ast.DoubleQuotedStringLiteral{
									NodeBase: ast.NodeBase{NodeSpan{7, 10}, nil, false},
									Raw:      "\"a\"",
									Value:    "a",
								},
								GroupName: &ast.PatternGroupName{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 6}},
									Name:     "l",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("one named element: space after name", func(t *testing.T) {
			n := mustparseChunk(t, `%str(l: "a")`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase:   ast.NodeBase{Span: NodeSpan{5, 11}},
								Quantifier: ast.ExactlyOneOccurrence,
								Expr: &ast.DoubleQuotedStringLiteral{
									NodeBase: ast.NodeBase{NodeSpan{8, 11}, nil, false},
									Raw:      "\"a\"",
									Value:    "a",
								},
								GroupName: &ast.PatternGroupName{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 6}},
									Name:     "l",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("one named element: invalid name", func(t *testing.T) {
			n, err := parseChunk(t, `%str(name-0-: "a")`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 18}},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase:   ast.NodeBase{Span: NodeSpan{5, 17}},
								Quantifier: ast.ExactlyOneOccurrence,
								Expr: &ast.DoubleQuotedStringLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 17}, nil, false},
									Raw:      "\"a\"",
									Value:    "a",
								},
								GroupName: &ast.PatternGroupName{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{5, 12},
										Err:  &sourcecode.ParsingError{UnspecifiedParsingError, INVALID_GROUP_NAME_SHOULD_NOT_END_WITH_DASH},
									},
									Name: "name-0-",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("element name without element", func(t *testing.T) {
			n, err := parseChunk(t, `%str(l:)`, "")
			assert.Error(t, err)
			runes := []rune("%str(l:)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 8}},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase: ast.NodeBase{
									NodeSpan{5, 7},
									nil,
									false,
								},
								Quantifier: ast.ExactlyOneOccurrence,
								Expr: &ast.InvalidComplexStringPatternElement{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{7, 7},
										Err:  &sourcecode.ParsingError{UnspecifiedParsingError, fmtAPatternWasExpectedHere(runes, 7)},
									},
								},
								GroupName: &ast.PatternGroupName{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 6}},
									Name:     "l",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("two elements string literal elements", func(t *testing.T) {

			n := mustparseChunk(t, `%str("a" "b")`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_STR, Span: NodeSpan{0, 4}},
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{4, 5}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{12, 13}},
							},*/
						},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase: ast.NodeBase{NodeSpan{5, 8}, nil, false},
								Expr: &ast.DoubleQuotedStringLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 8}, nil, false},
									Raw:      "\"a\"",
									Value:    "a",
								},
							},
							{
								NodeBase: ast.NodeBase{NodeSpan{9, 12}, nil, false},
								Expr: &ast.DoubleQuotedStringLiteral{
									NodeBase: ast.NodeBase{NodeSpan{9, 12}, nil, false},
									Raw:      "\"b\"",
									Value:    "b",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("pattern union: 2 cases", func(t *testing.T) {
			n := mustparseChunk(t, `%str( (| "a" | "b" ) )`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 22},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_STR, Span: NodeSpan{0, 4}},
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{4, 5}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{21, 22}},
							},*/
						},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase: ast.NodeBase{NodeSpan{6, 20}, nil, false},
								Expr: &ast.PatternUnion{
									NodeBase: ast.NodeBase{
										NodeSpan{6, 20},
										nil,
										false,
										/*[]ast.Token{
											{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{6, 7}},
											{Type: ast.PATTERN_UNION_PIPE, Span: NodeSpan{7, 8}},
											{Type: ast.PATTERN_UNION_PIPE, Span: NodeSpan{13, 14}},
											{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{19, 20}},
										},*/
									},
									Cases: []ast.Node{
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{9, 12}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("pattern union: 2 cases with occurrence modifiers", func(t *testing.T) {
			n := mustparseChunk(t, `%str( (| "a"* | "b"+ ) )`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 24}},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase: ast.NodeBase{NodeSpan{6, 22}, nil, false},
								Expr: &ast.PatternUnion{
									NodeBase: ast.NodeBase{Span: NodeSpan{6, 22}},
									Cases: []ast.Node{
										&ast.ComplexStringPatternPiece{
											NodeBase: ast.NodeBase{Span: NodeSpan{9, 14}},
											Elements: []*ast.PatternPieceElement{
												{
													NodeBase: ast.NodeBase{Span: NodeSpan{9, 13}},
													Expr: &ast.DoubleQuotedStringLiteral{
														NodeBase: ast.NodeBase{NodeSpan{9, 12}, nil, false},
														Raw:      `"a"`,
														Value:    "a",
													},
													Quantifier: ast.ZeroOrMoreOccurrences,
												},
											},
										},
										&ast.ComplexStringPatternPiece{
											NodeBase: ast.NodeBase{Span: NodeSpan{16, 21}},
											Elements: []*ast.PatternPieceElement{
												{

													NodeBase: ast.NodeBase{Span: NodeSpan{16, 20}},
													Expr: &ast.DoubleQuotedStringLiteral{
														NodeBase: ast.NodeBase{NodeSpan{16, 19}, nil, false},
														Raw:      `"b"`,
														Value:    "b",
													},
													Quantifier: ast.AtLeastOneOccurrence,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("pattern union: 2 cases with several elements", func(t *testing.T) {
			n := mustparseChunk(t, `%str( (| "a" "b" | "c" "d" ) )`)

			assert.EqualValues(t, &ast.ComplexStringPatternPiece{
				NodeBase: ast.NodeBase{Span: NodeSpan{0, 30}},
				Elements: []*ast.PatternPieceElement{
					{
						NodeBase: ast.NodeBase{NodeSpan{6, 28}, nil, false},
						Expr: &ast.PatternUnion{
							NodeBase: ast.NodeBase{Span: NodeSpan{6, 28}},
							Cases: []ast.Node{
								&ast.ComplexStringPatternPiece{
									NodeBase: ast.NodeBase{Span: NodeSpan{9, 17}},
									Elements: []*ast.PatternPieceElement{
										{
											NodeBase: ast.NodeBase{Span: NodeSpan{9, 12}},
											Expr: &ast.DoubleQuotedStringLiteral{
												NodeBase: ast.NodeBase{NodeSpan{9, 12}, nil, false},
												Raw:      `"a"`,
												Value:    "a",
											},
											Quantifier: ast.ExactlyOneOccurrence,
										},
										{
											NodeBase: ast.NodeBase{Span: NodeSpan{13, 16}},
											Expr: &ast.DoubleQuotedStringLiteral{
												NodeBase: ast.NodeBase{NodeSpan{13, 16}, nil, false},
												Raw:      `"b"`,
												Value:    "b",
											},
											Quantifier: ast.ExactlyOneOccurrence,
										},
									},
								},
								&ast.ComplexStringPatternPiece{
									NodeBase: ast.NodeBase{Span: NodeSpan{19, 27}},
									Elements: []*ast.PatternPieceElement{
										{
											NodeBase: ast.NodeBase{Span: NodeSpan{19, 22}},
											Expr: &ast.DoubleQuotedStringLiteral{
												NodeBase: ast.NodeBase{NodeSpan{19, 22}, nil, false},
												Raw:      `"c"`,
												Value:    "c",
											},
											Quantifier: ast.ExactlyOneOccurrence,
										},
										{
											NodeBase: ast.NodeBase{Span: NodeSpan{23, 26}},
											Expr: &ast.DoubleQuotedStringLiteral{
												NodeBase: ast.NodeBase{NodeSpan{23, 26}, nil, false},
												Raw:      `"d"`,
												Value:    "d",
											},
											Quantifier: ast.ExactlyOneOccurrence,
										},
									},
								},
							},
						},
					},
				},
			}, n.Statements[0])
		})

		t.Run("pattern union: 3 cases", func(t *testing.T) {
			n := mustparseChunk(t, `%str( (| "a" | "b" | "c" ) )`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 28},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_STR, Span: NodeSpan{0, 4}},
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{4, 5}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{27, 28}},
							},*/
						},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase: ast.NodeBase{NodeSpan{6, 26}, nil, false},
								Expr: &ast.PatternUnion{
									NodeBase: ast.NodeBase{
										NodeSpan{6, 26},
										nil,
										false,
										/*[]ast.Token{
											{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{6, 7}},
											{Type: ast.PATTERN_UNION_PIPE, Span: NodeSpan{7, 8}},
											{Type: ast.PATTERN_UNION_PIPE, Span: NodeSpan{13, 14}},
											{Type: ast.PATTERN_UNION_PIPE, Span: NodeSpan{19, 20}},
											{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{25, 26}},
										},*/
									},
									Cases: []ast.Node{
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{9, 12}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{21, 24}, nil, false},
											Raw:      `"c"`,
											Value:    "c",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("pattern union: 3 cases but last case is missing", func(t *testing.T) {
			n, err := parseChunk(t, `%str( (| "a" | "b" | ) )`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 24},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.PERCENT_STR, Span: NodeSpan{0, 4}},
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{4, 5}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{23, 24}},
							},*/
						},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase: ast.NodeBase{NodeSpan{6, 22}, nil, false},
								Expr: &ast.PatternUnion{
									NodeBase: ast.NodeBase{
										NodeSpan{6, 22},
										nil,
										false,
										/*[]ast.Token{
											{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{6, 7}},
											{Type: ast.PATTERN_UNION_PIPE, Span: NodeSpan{7, 8}},
											{Type: ast.PATTERN_UNION_PIPE, Span: NodeSpan{13, 14}},
											{Type: ast.PATTERN_UNION_PIPE, Span: NodeSpan{19, 20}},
											{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{21, 22}},
										},*/
									},
									Cases: []ast.Node{
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{9, 12}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
										&ast.InvalidComplexStringPatternElement{
											NodeBase: ast.NodeBase{
												NodeSpan{21, 21},
												&sourcecode.ParsingError{
													UnspecifiedParsingError,
													fmtAPatternWasExpectedHere([]rune(`%str( (| "a" | "b" | ) )`), 21),
												},
												false,
											},
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("pattern union with newline after each pipe symbol", func(t *testing.T) {
			n := mustparseChunk(t, "%str( (|\n\"a\" |\n\"b\" ) )")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 22}},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase: ast.NodeBase{NodeSpan{6, 20}, nil, false},
								Expr: &ast.PatternUnion{
									NodeBase: ast.NodeBase{Span: NodeSpan{6, 20}},
									Cases: []ast.Node{
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{9, 12}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("shorthand pattern union", func(t *testing.T) {
			n := mustparseChunk(t, `%str(| "a" | "b")`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 17}},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase: ast.NodeBase{NodeSpan{5, 16}, nil, false},
								Expr: &ast.PatternUnion{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 16}},
									Cases: []ast.Node{
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{7, 10}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{13, 16}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("shorthand pattern union with newline before first pipe", func(t *testing.T) {
			n := mustparseChunk(t, "%str(\n| \"a\" | \"b\")")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 18}},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase: ast.NodeBase{NodeSpan{6, 17}, nil, false},
								Expr: &ast.PatternUnion{
									NodeBase: ast.NodeBase{Span: NodeSpan{6, 17}},
									Cases: []ast.Node{
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{8, 11}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{14, 17}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("shorthand pattern union with newline after each pipe symbol", func(t *testing.T) {
			n := mustparseChunk(t, "%str(|\n\"a\" | \"b\")")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.ComplexStringPatternPiece{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 17}},
						Elements: []*ast.PatternPieceElement{
							{
								NodeBase: ast.NodeBase{NodeSpan{5, 16}, nil, false},
								Expr: &ast.PatternUnion{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 16}},
									Cases: []ast.Node{
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{7, 10}, nil, false},
											Raw:      `"a"`,
											Value:    "a",
										},
										&ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{13, 16}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("in pattern definition", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = %str(\"a\")")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 21}},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.ComplexStringPatternPiece{
							NodeBase: ast.NodeBase{Span: NodeSpan{12, 21}},
							Elements: []*ast.PatternPieceElement{
								{
									NodeBase:   ast.NodeBase{NodeSpan{17, 20}, nil, false},
									Quantifier: ast.ExactlyOneOccurrence,
									Expr: &ast.DoubleQuotedStringLiteral{
										NodeBase: ast.NodeBase{NodeSpan{17, 20}, nil, false},
										Raw:      "\"a\"",
										Value:    "a",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("complex nesting", func(t *testing.T) {
			n, err := parseChunk(t, `
				%str(
					hour: (
						| '1' '0'..'2'
						| '0'? '1'..'9'
					)
					':'
					minute: ('0'..'5' '0'..'9')
					' '
					period: (| "AM" | "PM")
				)
			`, "")

			assert.NoError(t, err)
			assert.NotNil(t, n)
		})

		t.Run("complex nesting with missing case in pattern", func(t *testing.T) {
			n, err := parseChunk(t, `
				%str(
					hour: (
						| '1' '0'..'2'
						| '0'? '1'..'9'
						|
					)
					':'
					minute: ('0'..'5' '0'..'9')
					' '
					period: (| "AM" | "PM")
				)
			`, "")

			assert.Error(t, err)
			assert.NotNil(t, n)
		})
	})

	t.Run("pattern call", func(t *testing.T) {
		t.Run("pattern identifier callee, no arguments", func(t *testing.T) {
			n := mustparseChunk(t, `%text()`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.PatternCallExpression{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 7},
							IsParenthesized: false,
						},
						Callee: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 5},
							},
							Name: "text",
						},
					},
				},
			}, n)
		})

		t.Run("pattern namespace member callee, no arguments", func(t *testing.T) {
			n := mustparseChunk(t, `%std.text()`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.PatternCallExpression{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 11},
							IsParenthesized: false,
						},
						Callee: &ast.PatternNamespaceMemberExpression{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 9},
							},
							Namespace: &ast.PatternNamespaceIdentifierLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{0, 5}},
								Name:     "std",
							},
							MemberName: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{5, 9}},
								Name:     "text",
							},
						},
					},
				},
			}, n)
		})

		t.Run("single argument", func(t *testing.T) {
			n := mustparseChunk(t, `%text(1)`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.PatternCallExpression{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 8},
							IsParenthesized: false,
						},
						Callee: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 5},
							},
							Name: "text",
						},
						Arguments: []ast.Node{
							&ast.IntLiteral{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{6, 7},
								},
								Raw:   "1",
								Value: 1,
							},
						},
					},
				},
			}, n)
		})

		t.Run("two arguments", func(t *testing.T) {
			n := mustparseChunk(t, `%text(1,2)`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.PatternCallExpression{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 10},
							IsParenthesized: false,
						},
						Callee: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 5},
							},
							Name: "text",
						},
						Arguments: []ast.Node{
							&ast.IntLiteral{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{6, 7},
								},
								Raw:   "1",
								Value: 1,
							},
							&ast.IntLiteral{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{8, 9},
								},
								Raw:   "2",
								Value: 2,
							},
						},
					},
				},
			}, n)
		})

		t.Run("pattern identifier as argument", func(t *testing.T) {
			n := mustparseChunk(t, `%text(i)`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.PatternCallExpression{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 8},
							IsParenthesized: false,
						},
						Callee: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 5},
							},
							Name: "text",
						},
						Arguments: []ast.Node{
							&ast.PatternIdentifierLiteral{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{6, 7},
								},
								Unprefixed: true,
								Name:       "i",
							},
						},
					},
				},
			}, n)
		})

		t.Run("unexpected char in arguments", func(t *testing.T) {
			n, err := parseChunk(t, `%text(:)`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.PatternCallExpression{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 8},
							IsParenthesized: false,
						},
						Callee: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{0, 5},
							},
							Name: "text",
						},
						Arguments: []ast.Node{
							&ast.UnknownNode{
								NodeBase: ast.NodeBase{
									Span:            NodeSpan{6, 7},
									Err:             &sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInPatternCallArguments(':')},
									IsParenthesized: false,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("shorthand syntax for object pattern argument: empty", func(t *testing.T) {
			n := mustparseChunk(t, `%text{}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.PatternCallExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 7}},
						Callee: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 5}},
							Name:     "text",
						},
						Arguments: []ast.Node{
							&ast.ObjectPatternLiteral{
								NodeBase: ast.NodeBase{
									Span:            NodeSpan{5, 7},
									IsParenthesized: false,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("shorthand syntax for object pattern argument: one property", func(t *testing.T) {
			n := mustparseChunk(t, `%text{a: int}`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.PatternCallExpression{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 13}},
						Callee: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 5}},
							Name:     "text",
						},
						Arguments: []ast.Node{
							&ast.ObjectPatternLiteral{
								NodeBase: ast.NodeBase{
									Span:            NodeSpan{5, 13},
									IsParenthesized: false,
								},
								Properties: []*ast.ObjectPatternProperty{
									{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 12}},
										Key: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{6, 7}},
											Name:     "a",
										},
										Value: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{Span: NodeSpan{9, 12}},
											Unprefixed: true,
											Name:       "int",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("pattern union", func(t *testing.T) {

		t.Run("single case", func(t *testing.T) {
			n := mustparseChunk(t, `%| "a"`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.PatternUnion{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Cases: []ast.Node{
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
								Raw:      `"a"`,
								Value:    "a",
							},
						},
					},
				},
			}, n)
		})

		t.Run("single case followed by a linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "%| \"a\"\n")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.PatternUnion{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Cases: []ast.Node{
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
								Raw:      `"a"`,
								Value:    "a",
							},
						},
					},
				},
			}, n)
		})

		t.Run("single case is an unprefixed pattern", func(t *testing.T) {
			n := mustparseChunk(t, `%| a`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
				Statements: []ast.Node{
					&ast.PatternUnion{
						NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
						Cases: []ast.Node{
							&ast.PatternIdentifierLiteral{
								NodeBase:   ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Unprefixed: true,
								Name:       "a",
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized, single case", func(t *testing.T) {
			n := mustparseChunk(t, `(%| "a")`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.PatternUnion{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 7},
							nil,
							true,
							/*[]ast.Token{
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{0, 1}},
								{Type: ast.PATTERN_UNION_OPENING_PIPE, Span: NodeSpan{1, 3}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{7, 8}},
							},*/
						},
						Cases: []ast.Node{
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 7}, nil, false},
								Raw:      `"a"`,
								Value:    "a",
							},
						},
					},
				},
			}, n)
		})

		t.Run("two cases", func(t *testing.T) {
			n := mustparseChunk(t, `%| "a" | "b"`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.PatternUnion{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 12}},
						Cases: []ast.Node{
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{3, 6}, nil, false},
								Raw:      `"a"`,
								Value:    "a",
							},
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{9, 12}, nil, false},
								Raw:      `"b"`,
								Value:    "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized, two cases", func(t *testing.T) {
			n := mustparseChunk(t, `(%| "a" | "b")`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.PatternUnion{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 13},
							nil,
							true,
							/*[]ast.Token{
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{0, 1}},
								{Type: ast.PATTERN_UNION_OPENING_PIPE, Span: NodeSpan{1, 3}},
								{Type: ast.PATTERN_UNION_PIPE, Span: NodeSpan{8, 9}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{13, 14}},
							},*/
						},
						Cases: []ast.Node{
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 7}, nil, false},
								Raw:      `"a"`,
								Value:    "a",
							},
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{10, 13}, nil, false},
								Raw:      `"b"`,
								Value:    "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("two cases, first one being a list pattern with a general elemet", func(t *testing.T) {
			n := mustparseChunk(t, `%| []int | "b"`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.PatternUnion{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
						Cases: []ast.Node{
							&ast.ListPatternLiteral{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 8}},
								GeneralElement: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{5, 8}},
									Name:       "int",
									Unprefixed: true,
								},
							},
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{11, 14}, nil, false},
								Raw:      `"b"`,
								Value:    "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized, linefeed after first pipe", func(t *testing.T) {
			n := mustparseChunk(t, "(%|\n\"a\" | \"b\")")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.PatternUnion{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 13},
							nil,
							true,
						},
						Cases: []ast.Node{
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 7}, nil, false},
								Raw:      `"a"`,
								Value:    "a",
							},
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{10, 13}, nil, false},
								Raw:      `"b"`,
								Value:    "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized, linefeed before second pipe", func(t *testing.T) {
			n := mustparseChunk(t, "(%| \"a\"\n| \"b\")")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.PatternUnion{
						NodeBase: ast.NodeBase{
							NodeSpan{1, 13},
							nil,
							true,
						},
						Cases: []ast.Node{
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{4, 7}, nil, false},
								Raw:      `"a"`,
								Value:    "a",
							},
							&ast.DoubleQuotedStringLiteral{
								NodeBase: ast.NodeBase{NodeSpan{10, 13}, nil, false},
								Raw:      `"b"`,
								Value:    "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized, unprefixed and no leading pipe", func(t *testing.T) {
			n := mustparseChunk(t, `pattern p = ("a" | "b")`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.PatternUnion{
							NodeBase: ast.NodeBase{
								NodeSpan{13, 22},
								nil,
								true,
							},
							Cases: []ast.Node{
								&ast.DoubleQuotedStringLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 16}, nil, false},
									Raw:      `"a"`,
									Value:    "a",
								},
								&ast.DoubleQuotedStringLiteral{
									NodeBase: ast.NodeBase{NodeSpan{19, 22}, nil, false},
									Raw:      `"b"`,
									Value:    "b",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized and unprefixed, linefeed after first pipe", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = (|\n\"a\" | \"b\")")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 25},
							IsParenthesized: false,
						},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{8, 9}},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.PatternUnion{
							NodeBase: ast.NodeBase{
								NodeSpan{13, 24},
								nil,
								true,
							},
							Cases: []ast.Node{
								&ast.DoubleQuotedStringLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
									Raw:      `"a"`,
									Value:    "a",
								},
								&ast.DoubleQuotedStringLiteral{
									NodeBase: ast.NodeBase{NodeSpan{21, 24}, nil, false},
									Raw:      `"b"`,
									Value:    "b",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized and unprefixed, linefeed before second pipe", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = (| \"a\"\n| \"b\")")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 25},
							IsParenthesized: false,
						},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{8, 9}},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.PatternUnion{
							NodeBase: ast.NodeBase{
								NodeSpan{13, 24},
								nil,
								true,
							},
							Cases: []ast.Node{
								&ast.DoubleQuotedStringLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
									Raw:      `"a"`,
									Value:    "a",
								},
								&ast.DoubleQuotedStringLiteral{
									NodeBase: ast.NodeBase{NodeSpan{21, 24}, nil, false},
									Raw:      `"b"`,
									Value:    "b",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized and unprefixed", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = | 1 | 2")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 19},
							IsParenthesized: false,
						},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{8, 9}},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.PatternUnion{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 19},
								nil,
								false,
							},
							Cases: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Raw:      `1`,
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{18, 19}, nil, false},
									Raw:      `2`,
									Value:    2,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized and unprefixed: followed by a linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = | 1 | 2\n")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 19},
							IsParenthesized: false,
						},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{8, 9}},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.PatternUnion{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 19},
								nil,
								false,
							},
							Cases: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Raw:      `1`,
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{18, 19}, nil, false},
									Raw:      `2`,
									Value:    2,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized and unprefixed: followed by a linefeed and a statement", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = | 1 | 2\na")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 19},
							IsParenthesized: false,
						},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{8, 9}},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.PatternUnion{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 19},
								nil,
								false,
							},
							Cases: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Raw:      `1`,
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{18, 19}, nil, false},
									Raw:      `2`,
									Value:    2,
								},
							},
						},
					},
					&ast.IdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
						Name:     "a",
					},
				},
			}, n)
		})

		t.Run("unparenthesized and no leading pipe", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = 1 | 2")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 17},
							IsParenthesized: false,
						},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{8, 9}},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.PatternUnion{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 17},
								nil,
								false,
							},
							Cases: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
									Raw:      `1`,
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
									Raw:      `2`,
									Value:    2,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized and no leading pipe: 3 cases", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = 1 | 2 | 3")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 21},
							IsParenthesized: false,
						},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{8, 9}},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.PatternUnion{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 21},
								nil,
								false,
							},
							Cases: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
									Raw:      `1`,
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
									Raw:      `2`,
									Value:    2,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
									Raw:      `3`,
									Value:    3,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized and no leading pipe: followed by a linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = 1 | 2\n")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 17},
							IsParenthesized: false,
						},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{8, 9}},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.PatternUnion{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 17},
								nil,
								false,
							},
							Cases: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
									Raw:      `1`,
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
									Raw:      `2`,
									Value:    2,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized and no leading pipe: followed by a linefeed and a statement", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = 1 | 2\na")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 17},
							IsParenthesized: false,
						},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{Span: NodeSpan{8, 9}},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.PatternUnion{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 17},
								nil,
								false,
							},
							Cases: []ast.Node{
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
									Raw:      `1`,
									Value:    1,
								},
								&ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
									Raw:      `2`,
									Value:    2,
								},
							},
						},
					},
					&ast.IdentifierLiteral{
						NodeBase: ast.NodeBase{NodeSpan{18, 19}, nil, false},
						Name:     "a",
					},
				},
			}, n)
		})

		t.Run("unparenthesized, no leading pipe, at the end of an object pattern", func(t *testing.T) {
			n := mustparseChunk(t, "%{a: 1 | 2}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 11},
							IsParenthesized: false,
						},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 10}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{2, 3}},
									Name:     "a",
								},
								Value: &ast.PatternUnion{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 10}},
									Cases: []ast.Node{
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
											Raw:      `1`,
											Value:    1,
										},
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
											Raw:      `2`,
											Value:    2,
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized, no leading pipe, at the end of an object pattern, followed by a linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "%{a: 1 | 2\n}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 12},
							IsParenthesized: false,
						},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 10}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{2, 3}},
									Name:     "a",
								},
								Value: &ast.PatternUnion{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 10}},
									Cases: []ast.Node{
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
											Raw:      `1`,
											Value:    1,
										},
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
											Raw:      `2`,
											Value:    2,
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unparenthesized and no leading pipe: followed by a linefeed and a property", func(t *testing.T) {
			n := mustparseChunk(t, "%{a: 1 | 2\nb: 1}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.ObjectPatternLiteral{
						NodeBase: ast.NodeBase{
							Span:            NodeSpan{0, 16},
							IsParenthesized: false,
						},
						Properties: []*ast.ObjectPatternProperty{
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{2, 10}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{2, 3}},
									Name:     "a",
								},
								Value: &ast.PatternUnion{
									NodeBase: ast.NodeBase{Span: NodeSpan{5, 10}},
									Cases: []ast.Node{
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{5, 6}, nil, false},
											Raw:      `1`,
											Value:    1,
										},
										&ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
											Raw:      `2`,
											Value:    2,
										},
									},
								},
							},
							{
								NodeBase: ast.NodeBase{Span: NodeSpan{11, 15}},
								Key: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{Span: NodeSpan{11, 12}},
									Name:     "b",
								},
								Value: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Raw:      `1`,
									Value:    1,
								},
							},
						},
					},
				},
			}, n)
		})

	})

	t.Run("assert statement", func(t *testing.T) {
		t.Run("assert statement", func(t *testing.T) {
			n := mustparseChunk(t, "assert true")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.AssertionStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							nil,
							false,
						},
						Expr: &ast.BooleanLiteral{
							NodeBase: ast.NodeBase{NodeSpan{7, 11}, nil, false},
							Value:    true,
						},
					},
				},
			}, n)
		})

		t.Run("missing expr", func(t *testing.T) {
			code := "assert"
			n, err := parseChunk(t, code, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.AssertionStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							nil,
							false,
						},
						Expr: &ast.MissingExpression{
							NodeBase: ast.NodeBase{
								NodeSpan{5, 6},
								&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune(code), 6, true)},
								false,
							},
						},
					},
				},
			}, n)
		})

	})

	t.Run("synchronized block", func(t *testing.T) {
		t.Run("keyword only", func(t *testing.T) {
			n, err := parseChunk(t, "synchronized", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.SynchronizedBlockStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 12},
							&sourcecode.ParsingError{UnspecifiedParsingError, SYNCHRONIZED_KEYWORD_SHOULD_BE_FOLLOWED_BY_SYNC_VALUES},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("single value", func(t *testing.T) {
			code := "synchronized val {}"
			n := mustparseChunk(t, code)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.SynchronizedBlockStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 19},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.SYNCHRONIZED_KEYWORD, Span: NodeSpan{0, 12}},
							},*/
						},
						SynchronizedValues: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{13, 16}, nil, false},
								Name:     "val",
							},
						},
						Block: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{17, 19},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{17, 18}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{18, 19}},
								},*/
							},
						},
					},
				},
			}, n)
		})

		t.Run("single value in parenthesis", func(t *testing.T) {
			code := "synchronized(val){}"
			n := mustparseChunk(t, code)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.SynchronizedBlockStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 19},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.SYNCHRONIZED_KEYWORD, Span: NodeSpan{0, 12}},
							},*/
						},
						SynchronizedValues: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{
									NodeSpan{13, 16},
									nil,
									true,
									/*[]ast.Token{
										{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{12, 13}},
										{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{16, 17}},
									},*/
								},
								Name: "val",
							},
						},
						Block: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{17, 19},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{17, 18}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{18, 19}},
								},*/
							},
						},
					},
				},
			}, n)
		})

		t.Run("two values", func(t *testing.T) {
			code := "synchronized val1 val2 {}"
			n := mustparseChunk(t, code)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.SynchronizedBlockStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 25},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.SYNCHRONIZED_KEYWORD, Span: NodeSpan{0, 12}},
							},*/
						},
						SynchronizedValues: []ast.Node{
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{13, 17}, nil, false},
								Name:     "val1",
							},
							&ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{18, 22}, nil, false},
								Name:     "val2",
							},
						},
						Block: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{23, 25},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{23, 24}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{24, 25}},
								},*/
							},
						},
					},
				},
			}, n)
		})

		t.Run("unexpected char", func(t *testing.T) {
			code := "synchronized ? {}"
			n, err := parseChunk(t, code, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.SynchronizedBlockStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 17},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.SYNCHRONIZED_KEYWORD, Span: NodeSpan{0, 12}},
							},*/
						},
						SynchronizedValues: []ast.Node{
							&ast.UnknownNode{
								NodeBase: ast.NodeBase{
									NodeSpan{13, 14},
									&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInSynchronizedValueList('?')},
									false,
								},
							},
						},
						Block: &ast.Block{
							NodeBase: ast.NodeBase{
								NodeSpan{15, 17},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{15, 16}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{16, 17}},
								},*/
							},
						},
					},
				},
			}, n)
		})

	})

	t.Run("css selector", func(t *testing.T) {

		t.Run("single element : type selector", func(t *testing.T) {
			n := mustparseChunk(t, "s!div")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.CssSelectorExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Elements: []ast.Node{
							&ast.CssTypeSelector{
								NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
								Name:     "div",
							},
						},
					},
				},
			}, n)
		})

		t.Run("selector followed by line feed", func(t *testing.T) {

			n := mustparseChunk(t, "s!div\n")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 6},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.CssSelectorExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Elements: []ast.Node{
							&ast.CssTypeSelector{
								NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
								Name:     "div",
							},
						},
					},
				},
			}, n)
		})

		t.Run("selector followed by exclamation mark", func(t *testing.T) {

			n := mustparseChunk(t, "s!div!")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.CssSelectorExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Elements: []ast.Node{
							&ast.CssTypeSelector{
								NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
								Name:     "div",
							},
						},
					},
				},
			}, n)
		})

		t.Run("selector followed by exclamation mark and an expression", func(t *testing.T) {

			n := mustparseChunk(t, "s!div! 1")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.CssSelectorExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Elements: []ast.Node{
							&ast.CssTypeSelector{
								NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
								Name:     "div",
							},
						},
					},
					&ast.IntLiteral{
						NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
						Raw:      "1",
						Value:    1,
					},
				},
			}, n)
		})

		t.Run("single element : class selector", func(t *testing.T) {
			n := mustparseChunk(t, "s!.ab")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.CssSelectorExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Elements: []ast.Node{
							&ast.CssClassSelector{
								NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
								Name:     "ab",
							},
						},
					},
				},
			}, n)
		})

		t.Run("single element : pseudo class selector", func(t *testing.T) {
			n := mustparseChunk(t, "s!:ab")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.CssSelectorExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Elements: []ast.Node{
							&ast.CssPseudoClassSelector{
								NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
								Name:     "ab",
							},
						},
					},
				},
			}, n)
		})

		t.Run("single element : pseudo element selector", func(t *testing.T) {
			n := mustparseChunk(t, "s!::ab")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.CssSelectorExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Elements: []ast.Node{
							&ast.CssPseudoElementSelector{
								NodeBase: ast.NodeBase{NodeSpan{2, 6}, nil, false},
								Name:     "ab",
							},
						},
					},
				},
			}, n)
		})

		t.Run("single element : pseudo element selector", func(t *testing.T) {
			n := mustparseChunk(t, "s!::ab")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.CssSelectorExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Elements: []ast.Node{
							&ast.CssPseudoElementSelector{
								NodeBase: ast.NodeBase{NodeSpan{2, 6}, nil, false},
								Name:     "ab",
							},
						},
					},
				},
			}, n)
		})

		t.Run("single element : attribute selector", func(t *testing.T) {
			n := mustparseChunk(t, `s![a="1"]`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
				Statements: []ast.Node{
					&ast.CssSelectorExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
						Elements: []ast.Node{
							&ast.CssAttributeSelector{
								NodeBase: ast.NodeBase{NodeSpan{2, 9}, nil, false},
								AttributeName: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
									Name:     "a",
								},
								Pattern: "=",
								Value: &ast.DoubleQuotedStringLiteral{
									NodeBase: ast.NodeBase{NodeSpan{5, 8}, nil, false},
									Raw:      `"1"`,
									Value:    "1",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("direct child", func(t *testing.T) {
			n := mustparseChunk(t, "s!a > b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.CssSelectorExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Elements: []ast.Node{
							&ast.CssTypeSelector{
								NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
								Name:     "a",
							},
							&ast.CssCombinator{
								NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
								Name:     ">",
							},
							&ast.CssTypeSelector{
								NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})

		t.Run("descendant", func(t *testing.T) {
			n := mustparseChunk(t, "s!a b")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.CssSelectorExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Elements: []ast.Node{
							&ast.CssTypeSelector{
								NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
								Name:     "a",
							},
							&ast.CssCombinator{
								NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
								Name:     " ",
							},
							&ast.CssTypeSelector{
								NodeBase: ast.NodeBase{NodeSpan{4, 5}, nil, false},
								Name:     "b",
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("various", func(t *testing.T) {

		testCases := map[string]ast.Node{
			"(1 + $a.a)": &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 10}, nil, false},
				Statements: []ast.Node{
					&ast.BinaryExpression{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 10},
							nil,
							true,
							/*[]ast.Token{
								{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{0, 1}},
								{Type: ast.PLUS, Span: NodeSpan{3, 4}},
								{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{9, 10}},
							},*/
						},
						Left: &ast.IntLiteral{
							NodeBase: ast.NodeBase{
								Span: NodeSpan{1, 2},
							},
							Raw:   "1",
							Value: 1,
						},
						Operator: ast.Add,
						Right: &ast.MemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{5, 9}, nil, false},
							Left: &ast.Variable{
								NodeBase: ast.NodeBase{NodeSpan{5, 7}, nil, false},
								Name:     "a",
							},
							PropertyName: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
								Name:     "a",
							},
						},
					},
				},
			},
		}

		for input, expectedOutput := range testCases {
			t.Run("", func(t *testing.T) {
				n := mustparseChunk(t, input)
				assert.EqualValues(t, expectedOutput, n)
			})
		}
	})

	t.Run("various parsing errors", func(t *testing.T) {
		testCases := []struct {
			input  string
			output *ast.Chunk
		}{
			{
				";",
				&ast.Chunk{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 1},
						nil,
						false,
						/*[]ast.Token{
							{Type: ast.SEMICOLON, Span: NodeSpan{0, 1}},
						},*/
					},
					Statements: nil,
				},
			},
			{
				";;",
				&ast.Chunk{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 2},
						nil,
						false,
						/*[]ast.Token{
							{Type: ast.SEMICOLON, Span: NodeSpan{0, 1}},
							{Type: ast.SEMICOLON, Span: NodeSpan{1, 2}},
						},*/
					},
					Statements: nil,
				},
			},
			{
				" ;",
				&ast.Chunk{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 2},
						nil,
						false,
						/*[]ast.Token{
							{Type: ast.SEMICOLON, Span: NodeSpan{1, 2}},
						},*/
					},
					Statements: nil,
				},
			},
			{
				" ;;",
				&ast.Chunk{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 3},
						nil,
						false,
						/*[]ast.Token{
							{Type: ast.SEMICOLON, Span: NodeSpan{1, 2}},
							{Type: ast.SEMICOLON, Span: NodeSpan{2, 3}},
						},*/
					},
					Statements: nil,
				},
			},
			{
				" ; ;",
				&ast.Chunk{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 4},
						nil,
						false,
						/*[]ast.Token{
							{Type: ast.SEMICOLON, Span: NodeSpan{1, 2}},
							{Type: ast.SEMICOLON, Span: NodeSpan{3, 4}},
						},*/
					},
					Statements: nil,
				},
			},
			{
				"1;",
				&ast.Chunk{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 2},
						nil,
						false,
						/*[]ast.Token{
							{Type: ast.SEMICOLON, Span: NodeSpan{1, 2}},
						},*/
					},
					Statements: []ast.Node{
						&ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Raw:      "1",
							Value:    1,
						},
					},
				},
			},
			{
				"1 ;",
				&ast.Chunk{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 3},
						nil,
						false,
						/*[]ast.Token{
							{Type: ast.SEMICOLON, Span: NodeSpan{2, 3}},
						},*/
					},
					Statements: []ast.Node{
						&ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Raw:      "1",
							Value:    1,
						},
					},
				},
			},
			{
				"1;2",
				&ast.Chunk{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 3},
						nil,
						false,
						/*[]ast.Token{
							{Type: ast.SEMICOLON, Span: NodeSpan{1, 2}},
						},*/
					},
					Statements: []ast.Node{
						&ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Raw:      "1",
							Value:    1,
						},
						&ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
							Raw:      "2",
							Value:    2,
						},
					},
				},
			},
			{
				"1; 2",
				&ast.Chunk{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 4},
						nil,
						false,
						/*[]ast.Token{
							{Type: ast.SEMICOLON, Span: NodeSpan{1, 2}},
						},*/
					},
					Statements: []ast.Node{
						&ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Raw:      "1",
							Value:    1,
						},
						&ast.IntLiteral{
							NodeBase: ast.NodeBase{NodeSpan{3, 4}, nil, false},
							Raw:      "2",
							Value:    2,
						},
					},
				},
			},
			{
				"$a;$b",
				&ast.Chunk{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 5},
						nil,
						false,
						/*[]ast.Token{
							{Type: ast.SEMICOLON, Span: NodeSpan{2, 3}},
						},*/
					},
					Statements: []ast.Node{
						&ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{0, 2}, nil, false},
							Name:     "a",
						},
						&ast.Variable{
							NodeBase: ast.NodeBase{NodeSpan{3, 5}, nil, false},
							Name:     "b",
						},
					},
				},
			},
			{
				"()]",
				&ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 3}, nil, false},
					Statements: []ast.Node{
						&ast.UnknownNode{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 2},
								&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("()]"), 1, true)},
								true,
								/*[]ast.Token{
									{Type: ast.OPENING_PARENTHESIS, Span: NodeSpan{0, 1}},
									{Type: ast.CLOSING_PARENTHESIS, Span: NodeSpan{1, 2}},
								},*/
							},
						},
						&ast.UnknownNode{
							NodeBase: ast.NodeBase{
								NodeSpan{2, 3},
								&sourcecode.ParsingError{UnspecifiedParsingError, fmtUnexpectedCharInBlockOrModule(']')},
								false,
								/*[]ast.Token{
									{Type: ast.UNEXPECTED_CHAR, Raw: "]", Span: NodeSpan{2, 3}},
								},*/
							},
						},
					},
				},
			},
			{
				".",
				&ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
					Statements: []ast.Node{
						&ast.UnknownNode{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 1},
								&sourcecode.ParsingError{UnspecifiedParsingError, DOT_SHOULD_BE_FOLLOWED_BY},
								false,
							},
						},
					},
				},
			},
			{
				"@;",
				&ast.Chunk{
					NodeBase: ast.NodeBase{
						NodeSpan{0, 2},
						nil,
						false,
					},
					Statements: []ast.Node{
						&ast.UnknownNode{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 1},
								&sourcecode.ParsingError{UnspecifiedParsingError, AT_SYMBOL_SHOULD_BE_FOLLOWED_BY},
								false,
							},
						},
					},
				},
			},
		}

		for _, testCase := range testCases {

			t.Run(testCase.input, func(t *testing.T) {
				n, _ := parseChunk(t, testCase.input, "")
				assert.EqualValues(t, testCase.output, n)
			})
		}
	})

	t.Run("string template literal", func(t *testing.T) {
		t.Run("pattern identifier, no interpolation", func(t *testing.T) {
			n := mustparseChunk(t, "%sql`SELECT * from users`")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.StringTemplateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 25},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.BACKQUOTE, Span: NodeSpan{4, 5}},
								{Type: ast.BACKQUOTE, Span: NodeSpan{24, 25}},
							},*/
						},
						Pattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "sql",
						},
						Slices: []ast.Node{
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{5, 24}, nil, false},
								Raw:      "SELECT * from users",
								Value:    "SELECT * from users",
							},
						},
					},
				},
			}, n)
		})

		t.Run("pattern namespace's member, no interpolation", func(t *testing.T) {
			n := mustparseChunk(t, "%sql.stmt`SELECT * from users`")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 30}, nil, false},
				Statements: []ast.Node{
					&ast.StringTemplateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 30},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.BACKQUOTE, Span: NodeSpan{9, 10}},
								{Type: ast.BACKQUOTE, Span: NodeSpan{29, 30}},
							},*/
						},
						Pattern: &ast.PatternNamespaceMemberExpression{
							NodeBase: ast.NodeBase{NodeSpan{0, 9}, nil, false},
							Namespace: &ast.PatternNamespaceIdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
								Name:     "sql",
							},
							MemberName: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{5, 9}, nil, false},
								Name:     "stmt",
							},
						},
						Slices: []ast.Node{
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{10, 29}, nil, false},
								Raw:      "SELECT * from users",
								Value:    "SELECT * from users",
							},
						},
					},
				},
			}, n)
		})

		t.Run("no interpolation", func(t *testing.T) {
			n, err := parseChunk(t, "%sql`SELECT * from users", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.StringTemplateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 24},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_STRING_TEMPL_LIT},
							false,
							/*[]ast.Token{
								{Type: ast.BACKQUOTE, Span: NodeSpan{4, 5}},
							},*/
						},
						Pattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "sql",
						},
						Slices: []ast.Node{
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{5, 24}, nil, false},
								Raw:      "SELECT * from users",
								Value:    "SELECT * from users",
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation at the start", func(t *testing.T) {
			n := mustparseChunk(t, "%sql`${nothing:$nothing}SELECT * from users`")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 44}, nil, false},
				Statements: []ast.Node{
					&ast.StringTemplateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 44},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.BACKQUOTE, Span: NodeSpan{4, 5}},
								{Type: ast.STR_INTERP_OPENING_BRACKETS, Span: NodeSpan{5, 7}},
								{Type: ast.STR_INTERP_CLOSING_BRACKETS, Span: NodeSpan{23, 25}},
								{Type: ast.BACKQUOTE, Span: NodeSpan{44, 45}},
							},*/
						},
						Pattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "sql",
						},
						Slices: []ast.Node{
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{5, 5}, nil, false},
								Raw:      "",
								Value:    "",
							},
							&ast.StringTemplateInterpolation{
								NodeBase: ast.NodeBase{NodeSpan{7, 23}, nil, false},
								Type:     "nothing",
								Expr: &ast.Variable{
									NodeBase: ast.NodeBase{NodeSpan{15, 23}, nil, false},
									Name:     "nothing",
								},
							},
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{24, 43}, nil, false},
								Raw:      "SELECT * from users",
								Value:    "SELECT * from users",
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation (variable) at the end", func(t *testing.T) {
			n := mustparseChunk(t, "%sql`SELECT * from users${nothing:$nothing}`")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 44}, nil, false},
				Statements: []ast.Node{
					&ast.StringTemplateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 44},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.BACKQUOTE, Span: NodeSpan{4, 5}},
								{Type: ast.STR_INTERP_OPENING_BRACKETS, Span: NodeSpan{24, 26}},
								{Type: ast.STR_INTERP_CLOSING_BRACKETS, Span: NodeSpan{42, 44}},
								{Type: ast.BACKQUOTE, Span: NodeSpan{44, 45}},
							},*/
						},
						Pattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "sql",
						},
						Slices: []ast.Node{
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{5, 24}, nil, false},
								Raw:      "SELECT * from users",
								Value:    "SELECT * from users",
							},
							&ast.StringTemplateInterpolation{
								NodeBase: ast.NodeBase{NodeSpan{26, 42}, nil, false},
								Type:     "nothing",
								Expr: &ast.Variable{
									NodeBase: ast.NodeBase{NodeSpan{34, 42}, nil, false},
									Name:     "nothing",
								},
							},
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{43, 43}, nil, false},
								Raw:      "",
								Value:    "",
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation (identifier) at the end", func(t *testing.T) {
			n := mustparseChunk(t, "%sql`SELECT * from users${nothing:nothing}`")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 43}, nil, false},
				Statements: []ast.Node{
					&ast.StringTemplateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 43},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.BACKQUOTE, Span: NodeSpan{4, 5}},
								{Type: ast.STR_INTERP_OPENING_BRACKETS, Span: NodeSpan{24, 26}},
								{Type: ast.STR_INTERP_CLOSING_BRACKETS, Span: NodeSpan{41, 43}},
								{Type: ast.BACKQUOTE, Span: NodeSpan{43, 44}},
							},*/
						},
						Pattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "sql",
						},
						Slices: []ast.Node{
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{5, 24}, nil, false},
								Raw:      "SELECT * from users",
								Value:    "SELECT * from users",
							},
							&ast.StringTemplateInterpolation{
								NodeBase: ast.NodeBase{NodeSpan{26, 41}, nil, false},
								Type:     "nothing",
								Expr: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{34, 41}, nil, false},
									Name:     "nothing",
								},
							},
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{42, 42}, nil, false},
								Raw:      "",
								Value:    "",
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation type containing a '.'", func(t *testing.T) {
			n := mustparseChunk(t, "%sql`${ab.cdef:1}SELECT * from users`")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 37}, nil, false},
				Statements: []ast.Node{
					&ast.StringTemplateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 37},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.BACKQUOTE, Span: NodeSpan{4, 5}},
								{Type: ast.STR_INTERP_OPENING_BRACKETS, Span: NodeSpan{5, 7}},
								{Type: ast.STR_INTERP_CLOSING_BRACKETS, Span: NodeSpan{16, 18}},
								{Type: ast.BACKQUOTE, Span: NodeSpan{37, 38}},
							},*/
						},
						Pattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "sql",
						},
						Slices: []ast.Node{
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{5, 5}, nil, false},
								Raw:      "",
								Value:    "",
							},
							&ast.StringTemplateInterpolation{
								NodeBase: ast.NodeBase{NodeSpan{7, 16}, nil, false},
								Type:     "ab.cdef",
								Expr: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{17, 36}, nil, false},
								Raw:      "SELECT * from users",
								Value:    "SELECT * from users",
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation with expression of len 1", func(t *testing.T) {
			n := mustparseChunk(t, "%sql`${nothing:1}SELECT * from users`")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 37}, nil, false},
				Statements: []ast.Node{
					&ast.StringTemplateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 37},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.BACKQUOTE, Span: NodeSpan{4, 5}},
								{Type: ast.STR_INTERP_OPENING_BRACKETS, Span: NodeSpan{5, 7}},
								{Type: ast.STR_INTERP_CLOSING_BRACKETS, Span: NodeSpan{16, 18}},
								{Type: ast.BACKQUOTE, Span: NodeSpan{37, 38}},
							},*/
						},
						Pattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "sql",
						},
						Slices: []ast.Node{
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{5, 5}, nil, false},
								Raw:      "",
								Value:    "",
							},
							&ast.StringTemplateInterpolation{
								NodeBase: ast.NodeBase{NodeSpan{7, 16}, nil, false},
								Type:     "nothing",
								Expr: &ast.IntLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
									Raw:      "1",
									Value:    1,
								},
							},
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{17, 36}, nil, false},
								Raw:      "SELECT * from users",
								Value:    "SELECT * from users",
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated (no interpolatipn)", func(t *testing.T) {
			n, err := parseChunk(t, "%sql`SELECT * from users", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.StringTemplateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 24},
							&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_STRING_TEMPL_LIT},
							false,
							/*[]ast.Token{
								{Type: ast.BACKQUOTE, Span: NodeSpan{4, 5}},
							},*/
						},
						Pattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "sql",
						},
						Slices: []ast.Node{
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{5, 24}, nil, false},
								Raw:      "SELECT * from users",
								Value:    "SELECT * from users",
							},
						},
					},
				},
			}, n)
		})

		t.Run("empty interpolation at the end", func(t *testing.T) {
			n, err := parseChunk(t, "%sql`SELECT * from users${}`", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.StringTemplateLiteral{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 28},
							nil,
							false,
							/*[]ast.Token{
								{Type: ast.BACKQUOTE, Span: NodeSpan{4, 5}},
								{Type: ast.STR_INTERP_OPENING_BRACKETS, Span: NodeSpan{24, 26}},
								{Type: ast.STR_INTERP_CLOSING_BRACKETS, Span: NodeSpan{26, 28}},
								{Type: ast.BACKQUOTE, Span: NodeSpan{28, 29}},
							},*/
						},
						Pattern: &ast.PatternIdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 4}, nil, false},
							Name:     "sql",
						},
						Slices: []ast.Node{
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{5, 24}, nil, false},
								Raw:      "SELECT * from users",
								Value:    "SELECT * from users",
							},
							&ast.StringTemplateInterpolation{
								NodeBase: ast.NodeBase{
									NodeSpan{26, 26},
									&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_STRING_INTERPOLATION_SHOULD_NOT_BE_EMPTY},
									false,
								},
							},
							&ast.StringTemplateSlice{
								NodeBase: ast.NodeBase{NodeSpan{27, 27}, nil, false},
								Raw:      "",
								Value:    "",
							},
						},
					},
				},
			}, n)

			t.Run("no pattern, interpolation at the start", func(t *testing.T) {
				n := mustparseChunk(t, "`${$nothing}SELECT * from users`")
				assert.EqualValues(t, &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 32}, nil, false},
					Statements: []ast.Node{
						&ast.StringTemplateLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{0, 32}},
							Slices: []ast.Node{
								&ast.StringTemplateSlice{
									NodeBase: ast.NodeBase{NodeSpan{1, 1}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.StringTemplateInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{3, 11}, nil, false},
									Expr: &ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{3, 11}, nil, false},
										Name:     "nothing",
									},
								},
								&ast.StringTemplateSlice{
									NodeBase: ast.NodeBase{NodeSpan{12, 31}, nil, false},
									Raw:      "SELECT * from users",
									Value:    "SELECT * from users",
								},
							},
						},
					},
				}, n)
			})

			t.Run("no pattern, interpolation + line feed", func(t *testing.T) {
				n := mustparseChunk(t, "`${$nothing}\n`")
				assert.EqualValues(t, &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
					Statements: []ast.Node{
						&ast.StringTemplateLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 14},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.BACKQUOTE, Span: NodeSpan{0, 1}},
									{Type: ast.STR_INTERP_OPENING_BRACKETS, Span: NodeSpan{1, 3}},
									{Type: ast.STR_INTERP_CLOSING_BRACKETS, Span: NodeSpan{11, 13}},
									{Type: ast.BACKQUOTE, Span: NodeSpan{14, 15}},
								},*/
							},
							Slices: []ast.Node{
								&ast.StringTemplateSlice{
									NodeBase: ast.NodeBase{NodeSpan{1, 1}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.StringTemplateInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{3, 11}, nil, false},
									Expr: &ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{3, 11}, nil, false},
										Name:     "nothing",
									},
								},
								&ast.StringTemplateSlice{
									NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
							},
						},
					},
				}, n)
			})

			t.Run("no pattern, interpolation + escaped n", func(t *testing.T) {
				n := mustparseChunk(t, "`${$nothing}\\n`")
				assert.EqualValues(t, &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
					Statements: []ast.Node{
						&ast.StringTemplateLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 15},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.BACKQUOTE, Span: NodeSpan{0, 1}},
									{Type: ast.STR_INTERP_OPENING_BRACKETS, Span: NodeSpan{1, 3}},
									{Type: ast.STR_INTERP_CLOSING_BRACKETS, Span: NodeSpan{11, 13}},
									{Type: ast.BACKQUOTE, Span: NodeSpan{15, 16}},
								},*/
							},
							Slices: []ast.Node{
								&ast.StringTemplateSlice{
									NodeBase: ast.NodeBase{NodeSpan{1, 1}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.StringTemplateInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{3, 11}, nil, false},
									Expr: &ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{3, 11}, nil, false},
										Name:     "nothing",
									},
								},
								&ast.StringTemplateSlice{
									NodeBase: ast.NodeBase{NodeSpan{12, 14}, nil, false},
									Raw:      "\\n",
									Value:    "\n",
								},
							},
						},
					},
				}, n)
			})

			t.Run("unterminated: followed by EOF", func(t *testing.T) {
				n, err := parseChunk(t, "`${$nothing}", "")
				assert.Error(t, err)
				assert.EqualValues(t, &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
					Statements: []ast.Node{
						&ast.StringTemplateLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 12},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_STRING_TEMPL_LIT},
								false,
							},
							Slices: []ast.Node{
								&ast.StringTemplateSlice{
									NodeBase: ast.NodeBase{NodeSpan{1, 1}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.StringTemplateInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{3, 11}, nil, false},
									Expr: &ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{3, 11}, nil, false},
										Name:     "nothing",
									},
								},
								&ast.StringTemplateSlice{
									NodeBase: ast.NodeBase{NodeSpan{12, 12}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
						},
					},
				}, n)
			})

			t.Run("unterminated: ending with a linefeed", func(t *testing.T) {
				n, err := parseChunk(t, "`${$nothing}\n", "")
				assert.Error(t, err)
				assert.EqualValues(t, &ast.Chunk{
					NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
					Statements: []ast.Node{
						&ast.StringTemplateLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{0, 13},
								&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_STRING_TEMPL_LIT},
								false,
							},
							Slices: []ast.Node{
								&ast.StringTemplateSlice{
									NodeBase: ast.NodeBase{NodeSpan{1, 1}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.StringTemplateInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{3, 11}, nil, false},
									Expr: &ast.Variable{
										NodeBase: ast.NodeBase{NodeSpan{3, 11}, nil, false},
										Name:     "nothing",
									},
								},
								&ast.StringTemplateSlice{
									NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
							},
						},
					},
				}, n)
			})
		})
	})

	t.Run("markup expression", func(t *testing.T) {
		//Future parsing modifications should be reflected and tested for markup pattern expressions.

		t.Run("no children: 0 characters", func(t *testing.T) {
			n := mustparseChunk(t, "h<div></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 12}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 12}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{8, 11}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("implicit namespace", func(t *testing.T) {
			n := mustparseChunk(t, "<div></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{0, 5}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{1, 4}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{5, 5}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{5, 11}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{7, 10}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized, implicit namespace", func(t *testing.T) {
			n := mustparseChunk(t, "(<div></div>)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{1, 12}, nil, true},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 12}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 12}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{8, 11}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated opening tag", func(t *testing.T) {
			n, err := parseChunk(t, "h<div", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 5}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 5},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OPENING_MARKUP_TAG_MISSING_CLOSING},
									false,
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated opening tag of child element", func(t *testing.T) {
			n, err := parseChunk(t, "h<div><span</div>", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 17}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{6, 6},
									},
								},
								&ast.MarkupElement{
									NodeBase: ast.NodeBase{NodeSpan{6, 11}, nil, false},
									Opening: &ast.MarkupOpeningTag{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 11},
											&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OPENING_MARKUP_TAG_MISSING_CLOSING},
											false,
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{7, 11}, nil, false},
											Name:     "span",
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{11, 11},
									},
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{11, 17}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 16}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated opening tag of nested child element", func(t *testing.T) {
			n, err := parseChunk(t, "h<div><div><span</div></div>", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 28}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{6, 6},
									},
								},
								&ast.MarkupElement{
									NodeBase: ast.NodeBase{NodeSpan{6, 22}, nil, false},
									Opening: &ast.MarkupOpeningTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 11}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{7, 10}, nil, false},
											Name:     "div",
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{
												Span: NodeSpan{11, 11},
											},
										},
										&ast.MarkupElement{
											NodeBase: ast.NodeBase{NodeSpan{11, 16}, nil, false},
											Opening: &ast.MarkupOpeningTag{
												NodeBase: ast.NodeBase{
													NodeSpan{11, 16},
													&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OPENING_MARKUP_TAG_MISSING_CLOSING},
													false,
												},
												Name: &ast.IdentifierLiteral{
													NodeBase: ast.NodeBase{NodeSpan{12, 16}, nil, false},
													Name:     "span",
												},
											},
										},
										&ast.MarkupText{
											NodeBase: ast.NodeBase{
												Span: NodeSpan{16, 16},
											},
										},
									},
									Closing: &ast.MarkupClosingTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{16, 22}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{18, 21}, nil, false},
											Name:     "div",
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{22, 22},
									},
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{22, 28}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{24, 27}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("closing bracket of opening tag is on the next line", func(t *testing.T) {
			n := mustparseChunk(t, "h<div\n></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 13}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 7}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{7, 7}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{7, 13}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{9, 12}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("HTML4 predefined entity", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>&eacute;</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 20}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 14}, nil, false},
									Raw:      "&eacute;",
									Value:    "é",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{14, 20}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{16, 19}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("HTML5 predefined entity", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>&iinfin;</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 20}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 14}, nil, false},
									Raw:      "&iinfin;",
									Value:    "⧜",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{14, 20}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{16, 19}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with value", func(t *testing.T) {
			n := mustparseChunk(t, `h<div a="b"></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 18}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 12}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.MarkupAttribute{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 11},
											nil,
											false,
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Value: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{8, 11}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{12, 12}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 18}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 17}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with value on next line", func(t *testing.T) {
			n := mustparseChunk(t, "h<div\na=\"b\"></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 18}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{1, 12},
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.MarkupAttribute{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 11}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Value: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{8, 11}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{12, 12}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 18}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 17}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with value and unquoted region as name", func(t *testing.T) {
			n := mustparseChunk(t, `@(h<div <{a}>="b"></div>)`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
						Expression: &ast.MarkupExpression{
							NodeBase: ast.NodeBase{NodeSpan{2, 24}, nil, true},
							Namespace: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
								Name:     "h",
							},
							Element: &ast.MarkupElement{
								NodeBase: ast.NodeBase{NodeSpan{3, 24}, nil, false},
								Opening: &ast.MarkupOpeningTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 18}},
									Name: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{4, 7}, nil, false},
										Name:     "div",
									},
									Attributes: []ast.Node{
										&ast.MarkupAttribute{
											NodeBase: ast.NodeBase{Span: NodeSpan{8, 17}},
											Name: &ast.UnquotedRegion{
												NodeBase: ast.NodeBase{Span: NodeSpan{8, 13}},
												Expression: &ast.IdentifierLiteral{
													NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
													Name:     "a",
												},
											},
											Value: &ast.DoubleQuotedStringLiteral{
												NodeBase: ast.NodeBase{NodeSpan{14, 17}, nil, false},
												Raw:      `"b"`,
												Value:    "b",
											},
										},
									},
								},
								Children: []ast.Node{
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{18, 18}, nil, false},
										Raw:      "",
										Value:    "",
									},
								},
								Closing: &ast.MarkupClosingTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{18, 24}},
									Name: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{20, 23}, nil, false},
										Name:     "div",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with unquoted region as value", func(t *testing.T) {
			n := mustparseChunk(t, `@(h<div a=<{b}>></div>)`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
						Expression: &ast.MarkupExpression{
							NodeBase: ast.NodeBase{NodeSpan{2, 22}, nil, true},
							Namespace: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
								Name:     "h",
							},
							Element: &ast.MarkupElement{
								NodeBase: ast.NodeBase{NodeSpan{3, 22}, nil, false},
								Opening: &ast.MarkupOpeningTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 16}},
									Name: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{4, 7}, nil, false},
										Name:     "div",
									},
									Attributes: []ast.Node{
										&ast.MarkupAttribute{
											NodeBase: ast.NodeBase{Span: NodeSpan{8, 15}},
											Name: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
												Name:     "a",
											},
											Value: &ast.UnquotedRegion{
												NodeBase: ast.NodeBase{Span: NodeSpan{10, 15}},
												Expression: &ast.IdentifierLiteral{
													NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
													Name:     "b",
												},
											},
										},
									},
								},
								Children: []ast.Node{
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{16, 16}, nil, false},
										Raw:      "",
										Value:    "",
									},
								},
								Closing: &ast.MarkupClosingTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{16, 22}},
									Name: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{18, 21}, nil, false},
										Name:     "div",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute without value on next line", func(t *testing.T) {
			n := mustparseChunk(t, "h<div\na></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 14}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 8}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.MarkupAttribute{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 7}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{8, 8}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{8, 14}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 13}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("self-closing: attribute with value", func(t *testing.T) {
			n := mustparseChunk(t, `h<div a="b"/>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 13}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 13},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.SELF_CLOSING_TAG_TERMINATOR, Span: NodeSpan{11, 13}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.MarkupAttribute{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 11},
											nil,
											false,
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Value: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{8, 11}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with value, followed by space", func(t *testing.T) {
			n := mustparseChunk(t, `h<div a="b" ></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 19}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 13},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{12, 13}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.MarkupAttribute{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 11},
											nil,
											false,
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Value: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{8, 11}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{13, 13}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{13, 19},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{13, 15}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{18, 19}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with invalid name with value", func(t *testing.T) {
			n, err := parseChunk(t, `h<div "a"="b"></div>`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 20}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 14},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{13, 14}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.MarkupAttribute{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 13},
											nil,
											false,
										},
										Name: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{
												NodeSpan{6, 9},
												&sourcecode.ParsingError{UnspecifiedParsingError, MARKUP_ATTRIBUTE_NAME_SHOULD_BE_IDENT},
												false,
											},
											Raw:   `"a"`,
											Value: "a",
										},
										Value: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{10, 13}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{14, 14}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{14, 20},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{14, 16}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{19, 20}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{16, 19}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with missing value after '='", func(t *testing.T) {
			n, err := parseChunk(t, `h<div a=></div>`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 15}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 9},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{8, 9}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.MarkupAttribute{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 8},
											nil,
											false,
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Value: &ast.MissingExpression{
											NodeBase: ast.NodeBase{
												NodeSpan{8, 9},
												&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("h<div a=></div>"), 8, true)},
												false,
											},
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{9, 9}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{9, 15},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{9, 11}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{14, 15}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{11, 14}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with missing value after '='", func(t *testing.T) {
			n, err := parseChunk(t, `h<div a=></div>`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 15}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 9},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{8, 9}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.MarkupAttribute{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 8},
											nil,
											false,
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Value: &ast.MissingExpression{
											NodeBase: ast.NodeBase{
												NodeSpan{8, 9},
												&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("h<div a=></div>"), 8, true)},
												false,
											},
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{9, 9}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{9, 15},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{9, 11}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{14, 15}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{11, 14}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with only name", func(t *testing.T) {
			n := mustparseChunk(t, `h<div a></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 14}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 8},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{7, 8}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.MarkupAttribute{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{8, 8}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{8, 14},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{8, 10}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{13, 14}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 13}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with only name: unterminated opening tag", func(t *testing.T) {
			n, err := parseChunk(t, `h<div a`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 7}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 7},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OPENING_MARKUP_TAG_MISSING_CLOSING},
									false,
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.MarkupAttribute{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("two attributes with value", func(t *testing.T) {
			n := mustparseChunk(t, `h<div a="b" c="d"></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 24}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 18}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.MarkupAttribute{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 11},
											nil,
											false,
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Value: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{8, 11}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
									&ast.MarkupAttribute{
										NodeBase: ast.NodeBase{
											NodeSpan{12, 17},
											nil,
											false,
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
											Name:     "c",
										},
										Value: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{14, 17}, nil, false},
											Raw:      `"d"`,
											Value:    "d",
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{18, 18}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{18, 24},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{18, 20}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{23, 24}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{20, 23}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("empty hyperscript attribute shorthand", func(t *testing.T) {
			t.SkipNow()

			n := mustparseChunk(t, `h<div {}></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 15}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 9}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 8}},
										Value:    "",
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{9, 9}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{9, 15}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{11, 14}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("non-empty hyperscript attribute shorthand", func(t *testing.T) {
			t.SkipNow()

			n := mustparseChunk(t, `h<div {1}></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 16}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 10}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 9}},
										Value:    "1",
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{10, 10}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 16}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("hyperscript attribute shorthand followed by a space", func(t *testing.T) {
			t.SkipNow()
			n := mustparseChunk(t, `h<div {} ></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 16}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 10}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 8}},
										Value:    "",
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{10, 10}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 16}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("hyperscript attribute shorthand followed by a dot", func(t *testing.T) {
			t.SkipNow()

			n := mustparseChunk(t, `h<div {}.></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 16}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 10}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 8}},
										Value:    "",
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{10, 10}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 16}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("hyperscript attribute shorthand with a '}>' sequence inside a single-quoted hyperscript string literal", func(t *testing.T) {
			t.SkipNow()

			n := mustparseChunk(t, `h<div {'}>'}></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 19}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 13}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 12}},
										Value:    "'}>'",
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{13, 13}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{13, 19}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("hyperscript attribute shorthand with a '}>' sequence inside a single-quoted hyperscript string literal that contains an escaped '", func(t *testing.T) {
			t.SkipNow()

			n := mustparseChunk(t, `h<div {'\'}>'}></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 21}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 15}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 14}},
										Value:    `'\'}>'`,
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{15, 15}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{15, 21}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{17, 20}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("hyperscript attribute shorthand with a '}>' sequence inside a double-quoted hyperscript string literal", func(t *testing.T) {
			t.SkipNow()

			n := mustparseChunk(t, `h<div {"}>"}></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 19}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 13}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 12}},
										Value:    `"}>"`,
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{13, 13}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{13, 19}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("hyperscript attribute shorthand with a '}>' sequence inside a double-quoted hyperscript string literal that contains an escaped \"", func(t *testing.T) {
			t.SkipNow()

			n := mustparseChunk(t, `h<div {"\"}>"}></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 21}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 15}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 14}},
										Value:    `"\"}>"`,
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{15, 15}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{15, 21}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{17, 20}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("hyperscript attribute shorthand with a '}>' sequence inside a hyperscript string template literal", func(t *testing.T) {
			t.SkipNow()

			n := mustparseChunk(t, "h<div {`}>`}></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 19}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 13}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 12}},
										Value:    "`}>`",
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{13, 13}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{13, 19}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("hyperscript attribute shorthand with an unterminated hyperscript string template literal", func(t *testing.T) {
			t.SkipNow()

			n, err := parseChunk(t, "h<div {`}></div>", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 16}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 16}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 16},
											&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_HYPERSCRIPT_ATTRIBUTE_SHORTHAND},
											false,
										},
										Value:          "`}></div>",
										IsUnterminated: true,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("hyperscript attribute shorthand followed by end of line", func(t *testing.T) {
			t.SkipNow()

			n, err := parseChunk(t, `h<div {}`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 8}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 8},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OPENING_MARKUP_TAG_MISSING_CLOSING},
									false,
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 8}},
										Value:    "",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated hyperscript attribute shorthand: end of file", func(t *testing.T) {
			t.SkipNow()

			n, err := parseChunk(t, `h<div {`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 7}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 7}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 7},
											&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_HYPERSCRIPT_ATTRIBUTE_SHORTHAND},
											false,
										},
										IsUnterminated: true,
										Value:          "",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("non-empty unterminated hyperscript attribute shorthand: end of file", func(t *testing.T) {
			t.SkipNow()

			n, err := parseChunk(t, `h<div {1`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 8}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 8}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 8},
											&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_HYPERSCRIPT_ATTRIBUTE_SHORTHAND},
											false,
										},
										IsUnterminated: true,
										Value:          "1",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("non-empty unterminated hyperscript attribute shorthand: end of file", func(t *testing.T) {
			t.SkipNow()

			n, err := parseChunk(t, `h<div {1></div>`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 15}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 15}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 15},
											&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_HYPERSCRIPT_ATTRIBUTE_SHORTHAND},
											false,
										},
										IsUnterminated: true,
										Value:          "1></div>",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("non-empty unterminated hyperscript attribute shorthand: ending with space + end of file", func(t *testing.T) {
			t.SkipNow()

			n, err := parseChunk(t, `h<div { `, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 8}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 8}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 8}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
								Attributes: []ast.Node{
									&ast.HyperscriptAttributeShorthand{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 8},
											&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_HYPERSCRIPT_ATTRIBUTE_SHORTHAND},
											false,
										},
										IsUnterminated: true,
										Value:          " ",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("self closing", func(t *testing.T) {
			n := mustparseChunk(t, "h<div/>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 7}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 7},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.SELF_CLOSING_TAG_TERMINATOR, Span: NodeSpan{5, 7}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated self closing", func(t *testing.T) {
			n, err := parseChunk(t, "h<div/", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 6}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 6},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_SELF_CLOSING_MARKUP_TAG_MISSING_CLOSING},
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.SLASH, Span: NodeSpan{5, 6}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single space", func(t *testing.T) {
			n := mustparseChunk(t, "h<div> </div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 13}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 6},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{5, 6}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      " ",
									Value:    " ",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{7, 13},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{7, 9}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{12, 13}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{9, 12}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>\n</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 13}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{7, 13}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{9, 12}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("leading interpolation", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>{1}2</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 16}},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
									Expr: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
									Raw:      "2",
									Value:    "2",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 16}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("leading unquoted region as child", func(t *testing.T) {
			n := mustparseChunk(t, "@(h<div><{1}>2</div>)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
						Expression: &ast.MarkupExpression{
							NodeBase: ast.NodeBase{NodeSpan{2, 20}, nil, true},
							Namespace: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
								Name:     "h",
							},
							Element: &ast.MarkupElement{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 20}},
								Opening: &ast.MarkupOpeningTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 8}},
									Name: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{4, 7}, nil, false},
										Name:     "div",
									},
								},
								Children: []ast.Node{
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{8, 8}, nil, false},
										Raw:      "",
										Value:    "",
									},
									&ast.UnquotedRegion{
										NodeBase: ast.NodeBase{NodeSpan{8, 13}, nil, false},
										Expression: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
										Raw:      "2",
										Value:    "2",
									},
								},
								Closing: &ast.MarkupClosingTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{14, 20}},
									Name: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{16, 19}, nil, false},
										Name:     "div",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("trailing interpolation", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>1{2}</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 16}},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "1",
									Value:    "1",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
									Expr: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{10, 10}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 16}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("trailing unquoted region as child", func(t *testing.T) {
			n := mustparseChunk(t, "@(h<div>1<{2}></div>)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
						Expression: &ast.MarkupExpression{
							NodeBase: ast.NodeBase{NodeSpan{2, 20}, nil, true},
							Namespace: &ast.IdentifierLiteral{
								NodeBase: ast.NodeBase{NodeSpan{2, 3}, nil, false},
								Name:     "h",
							},
							Element: &ast.MarkupElement{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 20}},
								Opening: &ast.MarkupOpeningTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 8}},
									Name: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{4, 7}, nil, false},
										Name:     "div",
									},
								},
								Children: []ast.Node{
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
										Raw:      "1",
										Value:    "1",
									},
									&ast.UnquotedRegion{
										NodeBase: ast.NodeBase{NodeSpan{9, 14}, nil, false},
										Expression: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Raw:      "2",
											Value:    2,
										},
									},
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{14, 14}, nil, false},
										Raw:      "",
										Value:    "",
									},
								},
								Closing: &ast.MarkupClosingTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{14, 20}},
									Name: &ast.IdentifierLiteral{
										NodeBase: ast.NodeBase{NodeSpan{16, 19}, nil, false},
										Name:     "div",
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single curly bracket interpolations should not be parsed in script tags", func(t *testing.T) {
			n := mustparseChunk(t, "h<script>{1}2</script>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 22}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 9},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{8, 9}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 8}, nil, false},
									Name:     "script",
								},
							},
							RawElementContent:       "{1}2",
							RawElementContentStart:  9,
							RawElementContentEnd:    13,
							EstimatedRawElementType: ast.JsScript,
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{13, 22},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{13, 15}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{21, 22}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{15, 21}, nil, false},
									Name:     "script",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("content in script tags should be parsed as raw text", func(t *testing.T) {
			n := mustparseChunk(t, "h<script><a></script>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 21}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 9},
									nil,
									false,
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 8}, nil, false},
									Name:     "script",
								},
							},
							RawElementContent:       "<a>",
							RawElementContentStart:  9,
							RawElementContentEnd:    12,
							EstimatedRawElementType: ast.JsScript,
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{12, 21},
									nil,
									false,
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 20}, nil, false},
									Name:     "script",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single curly bracket interpolations should not be parsed in style tags", func(t *testing.T) {
			n := mustparseChunk(t, "h<style>{1}2</style>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 20}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 8},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{7, 8}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 7}, nil, false},
									Name:     "style",
								},
							},
							RawElementContent:       "{1}2",
							RawElementContentStart:  8,
							RawElementContentEnd:    12,
							EstimatedRawElementType: ast.CssStyleElem,
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{12, 20},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{12, 14}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{19, 20}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 19}, nil, false},
									Name:     "style",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("content in style tags should be parsed as raw text", func(t *testing.T) {
			n := mustparseChunk(t, "h<style><a></style>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 19}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 8},
									nil,
									false,
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 7}, nil, false},
									Name:     "style",
								},
							},
							RawElementContent:       "<a>",
							RawElementContentStart:  8,
							RawElementContentEnd:    11,
							EstimatedRawElementType: ast.CssStyleElem,
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{11, 19},
									nil,
									false,
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 18}, nil, false},
									Name:     "style",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("markup expression within interpolation", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>{h<div></div>}2</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 27}},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{7, 19}, nil, false},
									Expr: &ast.MarkupExpression{
										NodeBase: ast.NodeBase{NodeSpan{7, 19}, nil, false},
										Namespace: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
											Name:     "h",
										},
										Element: &ast.MarkupElement{
											NodeBase: ast.NodeBase{NodeSpan{8, 19}, nil, false},
											Opening: &ast.MarkupOpeningTag{
												NodeBase: ast.NodeBase{Span: NodeSpan{8, 13}},
												Name: &ast.IdentifierLiteral{
													NodeBase: ast.NodeBase{NodeSpan{9, 12}, nil, false},
													Name:     "div",
												},
											},
											Children: []ast.Node{
												&ast.MarkupText{
													NodeBase: ast.NodeBase{NodeSpan{13, 13}, nil, false},
													Raw:      "",
													Value:    "",
												},
											},
											Closing: &ast.MarkupClosingTag{
												NodeBase: ast.NodeBase{Span: NodeSpan{13, 19}},
												Name: &ast.IdentifierLiteral{
													NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
													Name:     "div",
												},
											},
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
									Raw:      "2",
									Value:    "2",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{21, 27}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{23, 26}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("opening bracket within interpolation", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>{{}}2</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},

						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 17}},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
									Expr: &ast.ObjectLiteral{
										NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Raw:      "2",
									Value:    "2",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{11, 17}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 16}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("empty interpolation", func(t *testing.T) {
			n, err := parseChunk(t, "h<div>{}</div>", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{
								NodeSpan{1, 14},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{6, 7}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{7, 8}},
								},*/
							},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 6},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{5, 6}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{
										NodeSpan{7, 7},
										&sourcecode.ParsingError{UnspecifiedParsingError, EMPTY_MARKUP_INTERP},
										false,
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{8, 8}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{8, 14},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{8, 10}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{13, 14}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{10, 13}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("empty interpolation: linefeed", func(t *testing.T) {
			n, err := parseChunk(t, "h<div>{\n}</div>", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{
								NodeSpan{1, 15},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{6, 7}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{8, 9}},
								},*/
							},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 6},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{5, 6}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{
										NodeSpan{7, 8},
										&sourcecode.ParsingError{UnspecifiedParsingError, EMPTY_MARKUP_INTERP},
										false,
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{9, 9}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{9, 15},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{9, 11}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{14, 15}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{11, 14}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation: literal preceded by a linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>{\n1}</div>")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{
								NodeSpan{1, 16},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{6, 7}},
									{Type: ast.NEWLINE, Span: NodeSpan{7, 8}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{9, 10}},
								},*/
							},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 6},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{5, 6}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 9}},
									Expr: &ast.IntLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{8, 9}},
										Raw:      "1",
										Value:    1,
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{10, 10}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 16},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{10, 12}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{15, 16}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation: literal followed by a linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>{1\n}</div>")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{
								NodeSpan{1, 16},
								nil,
								false,
								/*[]ast.Token{
									{Type: ast.OPENING_CURLY_BRACKET, Span: NodeSpan{6, 7}},
									{Type: ast.NEWLINE, Span: NodeSpan{8, 9}},
									{Type: ast.CLOSING_CURLY_BRACKET, Span: NodeSpan{9, 10}},
								},*/
							},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 6},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{5, 6}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 9}},
									Expr: &ast.IntLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 8}},
										Raw:      "1",
										Value:    1,
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{10, 10}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{10, 16},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{10, 12}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{15, 16}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation: literal followed by a linefeed followed by a literal", func(t *testing.T) {
			n, err := parseChunk(t, "h<div>{1\n2}</div>", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 17}},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{
										NodeSpan{7, 10},
										&sourcecode.ParsingError{UnspecifiedParsingError, MARKUP_INTERP_SHOULD_CONTAIN_A_SINGLE_EXPR},
										false,
									},
									Expr: &ast.IntLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 8}},
										Raw:      "1",
										Value:    1,
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{11, 11}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{11, 17}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 16}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation: if expression", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>{if true 1 else 2}</div>")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 30}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 30}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 30}},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 23}},
									Expr: &ast.IfExpression{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 23}},
										Test: &ast.BooleanLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{10, 14}},
											Value:    true,
										},
										Consequent: &ast.IntLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{15, 16}},
											Raw:      "1",
											Value:    1,
										},
										Alternate: &ast.IntLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{22, 23}},
											Raw:      "2",
											Value:    2,
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{24, 24}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{24, 30}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{26, 29}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation: if expression followed by a linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>{if true 1 else 2\n}</div>")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 31}},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 24}},
									Expr: &ast.IfExpression{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 24}},
										Test: &ast.BooleanLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{10, 14}},
											Value:    true,
										},
										Consequent: &ast.IntLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{15, 16}},
											Raw:      "1",
											Value:    1,
										},
										Alternate: &ast.IntLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{22, 23}},
											Raw:      "2",
											Value:    2,
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{25, 25}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{25, 31}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{27, 30}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation: unterminated if expression", func(t *testing.T) {
			n, err := parseChunk(t, "h<div>{if true}</div>", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 21}},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 14}},
									Expr: &ast.IfExpression{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 14}},
										Test: &ast.BooleanLiteral{
											NodeBase: ast.NodeBase{Span: NodeSpan{10, 14}},
											Value:    true,
										},
										Consequent: &ast.MissingExpression{
											NodeBase: ast.NodeBase{
												NodeSpan{13, 14},
												&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("h<div>{if true"), 14, true)},
												false,
											},
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{15, 15}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{15, 21}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{17, 20}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation: for expression", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>{for i in [] => i}</div>")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 30}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 30}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 30}},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 23}},
									Expr: &ast.ForExpression{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 23}},
										ValueElemIdent: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Name:     "i",
										},
										IteratedValue: &ast.ListLiteral{
											NodeBase: ast.NodeBase{NodeSpan{16, 18}, nil, false},
										},
										Body: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{22, 23}, nil, false},
											Name:     "i",
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{24, 24}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{24, 30}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{26, 29}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation: for expression followed by a linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>{for i in [] => i\n}</div>")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 31}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 31}},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 24}},
									Expr: &ast.ForExpression{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 23}},
										ValueElemIdent: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Name:     "i",
										},
										IteratedValue: &ast.ListLiteral{
											NodeBase: ast.NodeBase{NodeSpan{16, 18}, nil, false},
										},
										Body: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{22, 23}, nil, false},
											Name:     "i",
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{25, 25}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{25, 31}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{27, 30}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation: unterminated for expression: missing body", func(t *testing.T) {
			n, err := parseChunk(t, "h<div>{for i in [] =>}</div>", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 28}},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 21}},
									Expr: &ast.ForExpression{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 21}},
										ValueElemIdent: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Name:     "i",
										},
										IteratedValue: &ast.ListLiteral{
											NodeBase: ast.NodeBase{NodeSpan{16, 18}, nil, false},
										},
										Body: &ast.MissingExpression{
											NodeBase: ast.NodeBase{
												NodeSpan{20, 21},
												&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("h<div>{for i in [] =>"), 21, true)},
												false,
											},
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{22, 22}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{22, 28}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{24, 27}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("error within interpolation", func(t *testing.T) {
			n, err := parseChunk(t, "h<div>{?}2</div>", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},

						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 16}},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
									Expr: &ast.MissingExpression{
										NodeBase: ast.NodeBase{
											NodeSpan{7, 8},
											&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("...div>{?"), 8, true)},
											false,
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
									Raw:      "2",
									Value:    "2",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 16}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("leading child element", func(t *testing.T) {
			n := mustparseChunk(t, "h<div><span>1</span>2</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 27}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 6},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{5, 6}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupElement{
									NodeBase: ast.NodeBase{NodeSpan{6, 20}, nil, false},
									Opening: &ast.MarkupOpeningTag{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 12},
											nil,
											false,
											/*[]ast.Token{
												{Type: ast.LESS_THAN, Span: NodeSpan{6, 7}},
												{Type: ast.GREATER_THAN, Span: NodeSpan{11, 12}},
											},*/
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{7, 11}, nil, false},
											Name:     "span",
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
											Raw:      "1",
											Value:    "1",
										},
									},
									Closing: &ast.MarkupClosingTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{13, 20}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{15, 19}, nil, false},
											Name:     "span",
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
									Raw:      "2",
									Value:    "2",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{21, 27},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{21, 23}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{26, 27}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{23, 26}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("linefeed followed by child element", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>\n<span>1</span>2</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 28}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 6},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.LESS_THAN, Span: NodeSpan{1, 2}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{5, 6}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupElement{
									NodeBase: ast.NodeBase{NodeSpan{7, 21}, nil, false},
									Opening: &ast.MarkupOpeningTag{
										NodeBase: ast.NodeBase{
											NodeSpan{7, 13},
											nil,
											false,
											/*[]ast.Token{
												{Type: ast.LESS_THAN, Span: NodeSpan{7, 8}},
												{Type: ast.GREATER_THAN, Span: NodeSpan{12, 13}},
											},*/
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{8, 12}, nil, false},
											Name:     "span",
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
											Raw:      "1",
											Value:    "1",
										},
									},
									Closing: &ast.MarkupClosingTag{
										NodeBase: ast.NodeBase{
											NodeSpan{14, 21},
											nil,
											false,
											/*[]ast.Token{
												{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{14, 16}},
												{Type: ast.GREATER_THAN, Span: NodeSpan{20, 21}},
											},*/
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{16, 20}, nil, false},
											Name:     "span",
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{21, 22}, nil, false},
									Raw:      "2",
									Value:    "2",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{22, 28},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{22, 24}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{27, 28}},
									},*/
								},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{24, 27}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized with unexpected closing tag followed by the closing tag of the outer element", func(t *testing.T) {
			n, err := parseChunk(t, "(<div><ul></ol></div>)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{1, 21}, nil, true},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 21}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupElement{
									NodeBase: ast.NodeBase{NodeSpan{6, 15}, nil, false},
									Opening: &ast.MarkupOpeningTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 10}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
											Name:     "ul",
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{NodeSpan{10, 10}, nil, false},
											Raw:      "",
											Value:    "",
										},
									},
									Closing: &ast.MarkupClosingTag{
										NodeBase: ast.NodeBase{
											NodeSpan{10, 15},
											&sourcecode.ParsingError{UnspecifiedParsingError, fmtExpectedClosingTag("ul")},
											false,
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{12, 14}, nil, false},
											Name:     "ol",
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{15, 15}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{15, 21}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{17, 20}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized with unexpected closing tag followed by a space followed by the valid closing tag of the outer element", func(t *testing.T) {
			n, err := parseChunk(t, "(<div><ul></ol> </div>)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{1, 22}, nil, true},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 22}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupElement{
									NodeBase: ast.NodeBase{NodeSpan{6, 15}, nil, false},
									Opening: &ast.MarkupOpeningTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 10}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
											Name:     "ul",
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{NodeSpan{10, 10}, nil, false},
											Raw:      "",
											Value:    "",
										},
									},
									Closing: &ast.MarkupClosingTag{
										NodeBase: ast.NodeBase{
											NodeSpan{10, 15},
											&sourcecode.ParsingError{UnspecifiedParsingError, fmtExpectedClosingTag("ul")},
											false,
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{12, 14}, nil, false},
											Name:     "ol",
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{15, 16}, nil, false},
									Raw:      " ",
									Value:    " ",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{16, 22}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{18, 21}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized with unexpected closing tag followed by a sibling element", func(t *testing.T) {
			n, err := parseChunk(t, "(<div><ul></ol><a></a></div>)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 29}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{1, 28}, nil, true},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 28}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupElement{
									NodeBase: ast.NodeBase{NodeSpan{6, 15}, nil, false},
									Opening: &ast.MarkupOpeningTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 10}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
											Name:     "ul",
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{NodeSpan{10, 10}, nil, false},
											Raw:      "",
											Value:    "",
										},
									},
									Closing: &ast.MarkupClosingTag{
										NodeBase: ast.NodeBase{
											NodeSpan{10, 15},
											&sourcecode.ParsingError{UnspecifiedParsingError, fmtExpectedClosingTag("ul")},
											false,
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{12, 14}, nil, false},
											Name:     "ol",
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{15, 15}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupElement{
									NodeBase: ast.NodeBase{NodeSpan{15, 22}, nil, false},
									Opening: &ast.MarkupOpeningTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{15, 18}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
											Name:     "a",
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{NodeSpan{18, 18}, nil, false},
											Raw:      "",
											Value:    "",
										},
									},
									Closing: &ast.MarkupClosingTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{18, 22}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
											Name:     "a",
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{22, 22}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{22, 28}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{24, 27}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("region headers: one header followed by a linefeed + the closing tag", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>\n@'a'\n</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 18}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							RegionHeaders: []*ast.AnnotatedRegionHeader{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
									Text: &ast.AnnotatedRegionHeaderText{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
										Raw:      "@'a'",
										Value:    "a",
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 18}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{14, 17}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("region headers: one header followed by EOF", func(t *testing.T) {
			n, err := parseChunk(t, "h<div>\n@'a'", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{
								NodeSpan{1, 11},
								&sourcecode.ParsingError{UnspecifiedParsingError, fmtExpectedClosingTag("div")},
								false,
							},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							RegionHeaders: []*ast.AnnotatedRegionHeader{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
									Text: &ast.AnnotatedRegionHeaderText{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
										Raw:      "@'a'",
										Value:    "a",
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{11, 11}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("region headers: one header followed by a linefeed + an opening tag", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>\n@'a'\n<a></a></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 25}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							RegionHeaders: []*ast.AnnotatedRegionHeader{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
									Text: &ast.AnnotatedRegionHeaderText{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
										Raw:      "@'a'",
										Value:    "a",
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupElement{
									NodeBase: ast.NodeBase{NodeSpan{12, 19}, nil, false},
									Opening: &ast.MarkupOpeningTag{
										NodeBase: ast.NodeBase{NodeSpan{12, 15}, nil, false},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
											Name:     "a",
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{NodeSpan{15, 15}, nil, false},
											Raw:      "",
											Value:    "",
										},
									},
									Closing: &ast.MarkupClosingTag{
										NodeBase: ast.NodeBase{NodeSpan{15, 19}, nil, false},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{17, 18}, nil, false},
											Name:     "a",
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{19, 19}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{19, 25}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{21, 24}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("region headers: one header with annotations followed by a linefeed + an opening tag", func(t *testing.T) {
			n := mustparseChunk(t, "h<div>\n@'a' @a\n<a></a></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 28}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							RegionHeaders: []*ast.AnnotatedRegionHeader{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 14}},
									Text: &ast.AnnotatedRegionHeaderText{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
										Raw:      "@'a'",
										Value:    "a",
									},
									Annotations: &ast.MetadataAnnotations{
										NodeBase: ast.NodeBase{Span: NodeSpan{12, 14}},
										Expressions: []ast.Node{
											&ast.MetaIdentifier{
												NodeBase: ast.NodeBase{Span: NodeSpan{12, 14}},
												Name:     "a",
											},
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupElement{
									NodeBase: ast.NodeBase{NodeSpan{15, 22}, nil, false},
									Opening: &ast.MarkupOpeningTag{
										NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{16, 17}, nil, false},
											Name:     "a",
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{NodeSpan{18, 18}, nil, false},
											Raw:      "",
											Value:    "",
										},
									},
									Closing: &ast.MarkupClosingTag{
										NodeBase: ast.NodeBase{NodeSpan{18, 22}, nil, false},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
											Name:     "a",
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{22, 22}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{22, 28}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{24, 27}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("region headers: one header directly followed by the closing tag", func(t *testing.T) {
			n, err := parseChunk(t, "h<div>\n@'a'</div>", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
						Namespace: &ast.IdentifierLiteral{
							NodeBase: ast.NodeBase{NodeSpan{0, 1}, nil, false},
							Name:     "h",
						},
						Element: &ast.MarkupElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 17}, nil, false},
							Opening: &ast.MarkupOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:     "div",
								},
							},
							RegionHeaders: []*ast.AnnotatedRegionHeader{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{7, 11},
										&sourcecode.ParsingError{UnspecifiedParsingError, MISSING_LINEFEED_AFTER_ANNOTATED_REGION_HEADER},
										false,
									},
									Text: &ast.AnnotatedRegionHeaderText{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
										Raw:      "@'a'",
										Value:    "a",
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{11, 11}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{11, 17}},
								Name: &ast.IdentifierLiteral{
									NodeBase: ast.NodeBase{NodeSpan{13, 16}, nil, false},
									Name:     "div",
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("markup pattern expression", func(t *testing.T) {

		t.Run("no children: 0 characters", func(t *testing.T) {
			n := mustparseChunk(t, "%<div></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 12}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 12}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{6, 12}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{8, 11}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unprefixed", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = <div></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.MarkupPatternExpression{
							NodeBase: ast.NodeBase{NodeSpan{12, 23}, nil, false},
							Element: &ast.MarkupPatternElement{
								NodeBase: ast.NodeBase{NodeSpan{12, 23}, nil, false},
								Opening: &ast.MarkupPatternOpeningTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{12, 17}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{13, 16}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
								Children: []ast.Node{
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{17, 17}, nil, false},
										Raw:      "",
										Value:    "",
									},
								},
								Closing: &ast.MarkupPatternClosingTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{17, 23}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{19, 22}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized, implicit namespace", func(t *testing.T) {
			n := mustparseChunk(t, "pattern p = (<div></div>)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.MarkupPatternExpression{
							NodeBase: ast.NodeBase{NodeSpan{13, 24}, nil, true},
							Element: &ast.MarkupPatternElement{
								NodeBase: ast.NodeBase{NodeSpan{13, 24}, nil, false},
								Opening: &ast.MarkupPatternOpeningTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{13, 18}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{14, 17}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
								Children: []ast.Node{
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{18, 18}, nil, false},
										Raw:      "",
										Value:    "",
									},
								},
								Closing: &ast.MarkupPatternClosingTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{18, 24}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{20, 23}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("element quantifier", func(t *testing.T) {
			n := mustparseChunk(t, "%<div+></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 13}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase:   ast.NodeBase{Span: NodeSpan{1, 7}},
								Quantifier: ast.OneOrMoreMarkupElements,
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{7, 7}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{7, 13}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{9, 12}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("element quantifier precded by an unexpected space", func(t *testing.T) {
			n, err := parseChunk(t, "%<div +></div>", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 14}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 8},
									&sourcecode.ParsingError{UnspecifiedParsingError, THERE_SHOULD_NOT_BE_SPACE_BETWEEN_THE_TAG_NAME_AND_THE_QUANTIFIER},
									false,
								},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{2, 5}},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{8, 8}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{8, 14}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{10, 13}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("wildcard preceded by an opening tag", func(t *testing.T) {
			n := mustparseChunk(t, "%<div>*</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 13}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{2, 5}},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupPatternWildcard{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Wildcard: ast.MarkupStarWildcard,
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{7, 7}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{7, 13}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{9, 12}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("wildcard preceded by character", func(t *testing.T) {
			n := mustparseChunk(t, "%<div>1*</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 14}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{2, 5}},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "1",
									Value:    "1",
								},
								&ast.MarkupPatternWildcard{
									NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
									Wildcard: ast.MarkupStarWildcard,
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{8, 8}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{8, 14}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{10, 13}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("wildcard preceded by a sibling element", func(t *testing.T) {
			n := mustparseChunk(t, "%<div><a></a>*</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 20}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{Span: NodeSpan{2, 5}},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupPatternElement{
									NodeBase: ast.NodeBase{NodeSpan{6, 13}, nil, false},
									Opening: &ast.MarkupPatternOpeningTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 9}},
										Name: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{Span: NodeSpan{7, 8}},
											Name:       "a",
											Unprefixed: true,
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{NodeSpan{9, 9}, nil, false},
											Raw:      "",
											Value:    "",
										},
									},
									Closing: &ast.MarkupPatternClosingTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{9, 13}},
										Name: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Name:       "a",
											Unprefixed: true,
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{13, 13}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupPatternWildcard{
									NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
									Wildcard: ast.MarkupStarWildcard,
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{14, 14}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{14, 20}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{16, 19}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated opening tag", func(t *testing.T) {
			n, err := parseChunk(t, "%<div", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 5}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 5}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 5},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OPENING_MARKUP_TAG_MISSING_CLOSING},
									false,
								},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated opening tag of child element", func(t *testing.T) {
			n, err := parseChunk(t, "%<div><span</div>", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 17}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{6, 6},
									},
								},
								&ast.MarkupPatternElement{
									NodeBase: ast.NodeBase{NodeSpan{6, 11}, nil, false},
									Opening: &ast.MarkupPatternOpeningTag{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 11},
											&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OPENING_MARKUP_TAG_MISSING_CLOSING},
											false,
										},
										Name: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{7, 11}, nil, false},
											Name:       "span",
											Unprefixed: true,
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{11, 11},
									},
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{11, 17}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{13, 16}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated opening tag of nested child element", func(t *testing.T) {
			n, err := parseChunk(t, "%<div><div><span</div></div>", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 28}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{6, 6},
									},
								},
								&ast.MarkupPatternElement{
									NodeBase: ast.NodeBase{NodeSpan{6, 22}, nil, false},
									Opening: &ast.MarkupPatternOpeningTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 11}},
										Name: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{7, 10}, nil, false},
											Name:       "div",
											Unprefixed: true,
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{
												Span: NodeSpan{11, 11},
											},
										},
										&ast.MarkupPatternElement{
											NodeBase: ast.NodeBase{NodeSpan{11, 16}, nil, false},
											Opening: &ast.MarkupPatternOpeningTag{
												NodeBase: ast.NodeBase{
													NodeSpan{11, 16},
													&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OPENING_MARKUP_TAG_MISSING_CLOSING},
													false,
												},
												Name: &ast.PatternIdentifierLiteral{
													NodeBase:   ast.NodeBase{NodeSpan{12, 16}, nil, false},
													Name:       "span",
													Unprefixed: true,
												},
											},
										},
										&ast.MarkupText{
											NodeBase: ast.NodeBase{
												Span: NodeSpan{16, 16},
											},
										},
									},
									Closing: &ast.MarkupPatternClosingTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{16, 22}},
										Name: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{18, 21}, nil, false},
											Name:       "div",
											Unprefixed: true,
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{
										Span: NodeSpan{22, 22},
									},
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{22, 28}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{24, 27}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("closing bracket of opening tag is on the next line", func(t *testing.T) {
			n := mustparseChunk(t, "%<div\n></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 13}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 7}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{7, 7}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{7, 13}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{9, 12}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with pattern", func(t *testing.T) {
			n := mustparseChunk(t, `%<div a="b"></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 18}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 12}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
								Attributes: []ast.Node{
									&ast.MarkupPatternAttribute{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 11}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Type: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{8, 11}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{12, 12}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 18}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{14, 17}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with pattern on next line", func(t *testing.T) {
			n := mustparseChunk(t, "%<div\na=\"b\"></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 18}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{1, 12},
								},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
								Attributes: []ast.Node{
									&ast.MarkupPatternAttribute{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 11}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Type: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{8, 11}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{12, 12}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 18}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{14, 17}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with unprefixed named pattern", func(t *testing.T) {
			n := mustparseChunk(t, `%<div a=b></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 16}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 10}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
								Attributes: []ast.Node{
									&ast.MarkupPatternAttribute{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 9}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Type: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
											Name:       "b",
											Unprefixed: true,
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{10, 10}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 16}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with pattern and unquoted region as name", func(t *testing.T) {
			n := mustparseChunk(t, `@(%<div <{a}>="b"></div>)`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
						Expression: &ast.MarkupPatternExpression{
							NodeBase: ast.NodeBase{NodeSpan{2, 24}, nil, true},
							Element: &ast.MarkupPatternElement{
								NodeBase: ast.NodeBase{NodeSpan{3, 24}, nil, false},
								Opening: &ast.MarkupPatternOpeningTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 18}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{4, 7}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
									Attributes: []ast.Node{
										&ast.MarkupPatternAttribute{
											NodeBase: ast.NodeBase{Span: NodeSpan{8, 17}},
											Name: &ast.UnquotedRegion{
												NodeBase: ast.NodeBase{Span: NodeSpan{8, 13}},
												Expression: &ast.IdentifierLiteral{
													NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
													Name:     "a",
												},
											},
											Type: &ast.DoubleQuotedStringLiteral{
												NodeBase: ast.NodeBase{NodeSpan{14, 17}, nil, false},
												Raw:      `"b"`,
												Value:    "b",
											},
										},
									},
								},
								Children: []ast.Node{
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{18, 18}, nil, false},
										Raw:      "",
										Value:    "",
									},
								},
								Closing: &ast.MarkupPatternClosingTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{18, 24}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{20, 23}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with unquoted region as pattern", func(t *testing.T) {
			n := mustparseChunk(t, `@(%<div a=<{b}>></div>)`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 23}, nil, false},
						Expression: &ast.MarkupPatternExpression{
							NodeBase: ast.NodeBase{NodeSpan{2, 22}, nil, true},
							Element: &ast.MarkupPatternElement{
								NodeBase: ast.NodeBase{NodeSpan{3, 22}, nil, false},
								Opening: &ast.MarkupPatternOpeningTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 16}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{4, 7}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
									Attributes: []ast.Node{
										&ast.MarkupPatternAttribute{
											NodeBase: ast.NodeBase{Span: NodeSpan{8, 15}},
											Name: &ast.IdentifierLiteral{
												NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
												Name:     "a",
											},
											Type: &ast.UnquotedRegion{
												NodeBase: ast.NodeBase{Span: NodeSpan{10, 15}},
												Expression: &ast.IdentifierLiteral{
													NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
													Name:     "b",
												},
											},
										},
									},
								},
								Children: []ast.Node{
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{16, 16}, nil, false},
										Raw:      "",
										Value:    "",
									},
								},
								Closing: &ast.MarkupPatternClosingTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{16, 22}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{18, 21}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute without pattern on next line", func(t *testing.T) {
			n := mustparseChunk(t, "%<div\na></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 14}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 8}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
								Attributes: []ast.Node{
									&ast.MarkupPatternAttribute{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 7}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{8, 8}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{8, 14}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{10, 13}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("self-closing: attribute with pattern", func(t *testing.T) {
			n := mustparseChunk(t, `%<div a="b"/>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 13}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 13}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
								Attributes: []ast.Node{
									&ast.MarkupPatternAttribute{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 11}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Type: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{8, 11}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with pattern, followed by space", func(t *testing.T) {
			n := mustparseChunk(t, `%<div a="b" ></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 19}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 13}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
								Attributes: []ast.Node{
									&ast.MarkupPatternAttribute{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 11}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Type: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{8, 11}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{13, 13}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{13, 19}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{15, 18}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with invalid name with pattern", func(t *testing.T) {
			n, err := parseChunk(t, `%<div "a"="b"></div>`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 20}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 14}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
								Attributes: []ast.Node{
									&ast.MarkupPatternAttribute{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 13},
											nil,
											false,
										},
										Name: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{
												NodeSpan{6, 9},
												&sourcecode.ParsingError{UnspecifiedParsingError, MARKUP_ATTRIBUTE_NAME_SHOULD_BE_IDENT},
												false,
											},
											Raw:   `"a"`,
											Value: "a",
										},
										Type: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{10, 13}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{14, 14}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{14, 20}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{16, 19}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with missing pattern after '='", func(t *testing.T) {
			n, err := parseChunk(t, `%<div a=></div>`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 15}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 9}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
								Attributes: []ast.Node{
									&ast.MarkupPatternAttribute{
										NodeBase: ast.NodeBase{
											NodeSpan{6, 8},
											nil,
											false,
										},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Type: &ast.MissingExpression{
											NodeBase: ast.NodeBase{
												NodeSpan{8, 9},
												&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("%<div a=></div>"), 8, true)},
												false,
											},
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{9, 9}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{9, 15}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{11, 14}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with missing pattern after '='", func(t *testing.T) {
			n, err := parseChunk(t, `%<div a=></div>`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 15}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 9}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
								Attributes: []ast.Node{
									&ast.MarkupPatternAttribute{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 8}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Type: &ast.MissingExpression{
											NodeBase: ast.NodeBase{
												NodeSpan{8, 9},
												&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("%<div a=></div>"), 8, true)},
												false,
											},
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{9, 9}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{9, 15}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{11, 14}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with only name", func(t *testing.T) {
			n := mustparseChunk(t, `%<div a></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 14}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 8}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
								Attributes: []ast.Node{
									&ast.MarkupPatternAttribute{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{8, 8}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{8, 14}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{10, 13}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("attribute with only name: unterminated opening tag", func(t *testing.T) {
			n, err := parseChunk(t, `%<div a`, "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 7}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 7},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_OPENING_MARKUP_TAG_MISSING_CLOSING},
									false,
								},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
								Attributes: []ast.Node{
									&ast.MarkupPatternAttribute{
										NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("two attributes with value", func(t *testing.T) {
			n := mustparseChunk(t, `%<div a="b" c="d"></div>`)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 24}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 24}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 18}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
								Attributes: []ast.Node{
									&ast.MarkupPatternAttribute{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 11}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
											Name:     "a",
										},
										Type: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{8, 11}, nil, false},
											Raw:      `"b"`,
											Value:    "b",
										},
									},
									&ast.MarkupPatternAttribute{
										NodeBase: ast.NodeBase{Span: NodeSpan{12, 17}},
										Name: &ast.IdentifierLiteral{
											NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
											Name:     "c",
										},
										Type: &ast.DoubleQuotedStringLiteral{
											NodeBase: ast.NodeBase{NodeSpan{14, 17}, nil, false},
											Raw:      `"d"`,
											Value:    "d",
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{18, 18}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{18, 24}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{20, 23}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("hyperscript attribute shorthands are not supported", func(t *testing.T) {
			//TODO
		})

		t.Run("self closing", func(t *testing.T) {
			n := mustparseChunk(t, "%<div/>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 7}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 7}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 7}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unterminated self closing", func(t *testing.T) {
			n, err := parseChunk(t, "%<div/", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 6}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{
									NodeSpan{1, 6},
									&sourcecode.ParsingError{UnspecifiedParsingError, UNTERMINATED_SELF_CLOSING_MARKUP_TAG_MISSING_CLOSING},
									false,
								},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single space", func(t *testing.T) {
			n := mustparseChunk(t, "%<div> </div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 13}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      " ",
									Value:    " ",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{7, 13}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{9, 12}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "%<div>\n</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 13}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{7, 13}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{9, 12}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("leading interpolation", func(t *testing.T) {
			n := mustparseChunk(t, "%<div>{1}2</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 16}},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupPatternInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
									Expr: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
										Raw:      "1",
										Value:    1,
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
									Raw:      "2",
									Value:    "2",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 16}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("unprefixed named pattern in interpolation", func(t *testing.T) {
			n := mustparseChunk(t, "%<div>{p}2</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 16}},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupPatternInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
									Expr: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{7, 8}, nil, false},
										Unprefixed: true,
										Name:       "p",
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
									Raw:      "2",
									Value:    "2",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 16}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("leading unquoted region as child", func(t *testing.T) {
			n := mustparseChunk(t, "@(%<div><{1}>2</div>)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
						Expression: &ast.MarkupPatternExpression{
							NodeBase: ast.NodeBase{NodeSpan{2, 20}, nil, true},
							Element: &ast.MarkupPatternElement{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 20}},
								Opening: &ast.MarkupPatternOpeningTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 8}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{4, 7}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
								Children: []ast.Node{
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{8, 8}, nil, false},
										Raw:      "",
										Value:    "",
									},
									&ast.UnquotedRegion{
										NodeBase: ast.NodeBase{NodeSpan{8, 13}, nil, false},
										Expression: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
											Raw:      "1",
											Value:    1,
										},
									},
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
										Raw:      "2",
										Value:    "2",
									},
								},
								Closing: &ast.MarkupPatternClosingTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{14, 20}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{16, 19}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("trailing interpolation", func(t *testing.T) {
			n := mustparseChunk(t, "%<div>1{2}</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 16}},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "1",
									Value:    "1",
								},
								&ast.MarkupPatternInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
									Expr: &ast.IntLiteral{
										NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
										Raw:      "2",
										Value:    2,
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{10, 10}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 16}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("trailing unquoted region as child", func(t *testing.T) {
			n := mustparseChunk(t, "@(%<div>1<{2}></div>)")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.QuotedExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
						Expression: &ast.MarkupPatternExpression{
							NodeBase: ast.NodeBase{NodeSpan{2, 20}, nil, true},
							Element: &ast.MarkupPatternElement{
								NodeBase: ast.NodeBase{Span: NodeSpan{3, 20}},
								Opening: &ast.MarkupPatternOpeningTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{3, 8}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{4, 7}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
								Children: []ast.Node{
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{8, 9}, nil, false},
										Raw:      "1",
										Value:    "1",
									},
									&ast.UnquotedRegion{
										NodeBase: ast.NodeBase{NodeSpan{9, 14}, nil, false},
										Expression: &ast.IntLiteral{
											NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
											Raw:      "2",
											Value:    2,
										},
									},
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{14, 14}, nil, false},
										Raw:      "",
										Value:    "",
									},
								},
								Closing: &ast.MarkupPatternClosingTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{14, 20}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{16, 19}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single curly bracket interpolations should not be parsed in script tags", func(t *testing.T) {
			n := mustparseChunk(t, "%<script>{1}2</script>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 22}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 22}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 9}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 8}, nil, false},
									Name:       "script",
									Unprefixed: true,
								},
							},
							RawElementContent:       "{1}2",
							RawElementContentStart:  9,
							RawElementContentEnd:    13,
							EstimatedRawElementType: ast.JsScript,
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{13, 22}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{15, 21}, nil, false},
									Name:       "script",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("content in script tags should be parsed as raw text", func(t *testing.T) {
			n := mustparseChunk(t, "%<script><a></script>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 21}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 21}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 9}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 8}, nil, false},
									Name:       "script",
									Unprefixed: true,
								},
							},
							RawElementContent:       "<a>",
							RawElementContentStart:  9,
							RawElementContentEnd:    12,
							EstimatedRawElementType: ast.JsScript,
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 21}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{14, 20}, nil, false},
									Name:       "script",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("single curly bracket interpolations should not be parsed in style tags", func(t *testing.T) {
			n := mustparseChunk(t, "%<style>{1}2</style>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 20}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 20}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 8}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 7}, nil, false},
									Name:       "style",
									Unprefixed: true,
								},
							},
							RawElementContent:       "{1}2",
							RawElementContentStart:  8,
							RawElementContentEnd:    12,
							EstimatedRawElementType: ast.CssStyleElem,
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 20}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{14, 19}, nil, false},
									Name:       "style",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("content in style tags should be parsed as raw text", func(t *testing.T) {
			n := mustparseChunk(t, "%<style><a></style>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 19}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 19}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 8}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 7}, nil, false},
									Name:       "style",
									Unprefixed: true,
								},
							},
							RawElementContent:       "<a>",
							RawElementContentStart:  8,
							RawElementContentEnd:    11,
							EstimatedRawElementType: ast.CssStyleElem,
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{11, 19}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{13, 18}, nil, false},
									Name:       "style",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("markup expression within interpolation", func(t *testing.T) {
			n := mustparseChunk(t, "%<div>{%<div></div>}2</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 27}},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupPatternInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{7, 19}, nil, false},
									Expr: &ast.MarkupPatternExpression{
										NodeBase: ast.NodeBase{NodeSpan{7, 19}, nil, false},
										Element: &ast.MarkupPatternElement{
											NodeBase: ast.NodeBase{NodeSpan{8, 19}, nil, false},
											Opening: &ast.MarkupPatternOpeningTag{
												NodeBase: ast.NodeBase{Span: NodeSpan{8, 13}},
												Name: &ast.PatternIdentifierLiteral{
													NodeBase:   ast.NodeBase{NodeSpan{9, 12}, nil, false},
													Name:       "div",
													Unprefixed: true,
												},
											},
											Children: []ast.Node{
												&ast.MarkupText{
													NodeBase: ast.NodeBase{NodeSpan{13, 13}, nil, false},
													Raw:      "",
													Value:    "",
												},
											},
											Closing: &ast.MarkupPatternClosingTag{
												NodeBase: ast.NodeBase{Span: NodeSpan{13, 19}},
												Name: &ast.PatternIdentifierLiteral{
													NodeBase:   ast.NodeBase{NodeSpan{15, 18}, nil, false},
													Name:       "div",
													Unprefixed: true,
												},
											},
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
									Raw:      "2",
									Value:    "2",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{21, 27}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{23, 26}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("opening bracket within interpolation", func(t *testing.T) {
			n := mustparseChunk(t, "%<div>{{}}2</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 17}},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupPatternInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
									Expr: &ast.ObjectPatternLiteral{
										NodeBase: ast.NodeBase{NodeSpan{7, 9}, nil, false},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{10, 11}, nil, false},
									Raw:      "2",
									Value:    "2",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{11, 17}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{13, 16}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("empty interpolation", func(t *testing.T) {
			n, err := parseChunk(t, "%<div>{}</div>", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 14}},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupPatternInterpolation{
									NodeBase: ast.NodeBase{
										NodeSpan{7, 7},
										&sourcecode.ParsingError{UnspecifiedParsingError, EMPTY_MARKUP_INTERP},
										false,
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{8, 8}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{
									Span: NodeSpan{8, 14},
								},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{10, 13}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("empty interpolation: linefeed", func(t *testing.T) {
			n, err := parseChunk(t, "%<div>{\n}</div>", "")
			assert.Error(t, err)

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 15}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 15}},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupPatternInterpolation{
									NodeBase: ast.NodeBase{
										NodeSpan{7, 8},
										&sourcecode.ParsingError{UnspecifiedParsingError, EMPTY_MARKUP_INTERP},
										false,
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{9, 9}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{
									NodeSpan{9, 15},
									nil,
									false,
									/*[]ast.Token{
										{Type: ast.END_TAG_OPEN_DELIMITER, Span: NodeSpan{9, 11}},
										{Type: ast.GREATER_THAN, Span: NodeSpan{14, 15}},
									},*/
								},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{11, 14}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation: literal preceded by a linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "%<div>{\n1}</div>")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 16}},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupPatternInterpolation{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 9}},
									Expr: &ast.IntLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{8, 9}},
										Raw:      "1",
										Value:    1,
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{10, 10}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 16}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation: literal followed by a linefeed", func(t *testing.T) {
			n := mustparseChunk(t, "%<div>{1\n}</div>")

			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 16}},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupPatternInterpolation{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 9}},
									Expr: &ast.IntLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 8}},
										Raw:      "1",
										Value:    1,
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{10, 10}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 16}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("interpolation: literal followed by a linefeed followed by a literal", func(t *testing.T) {
			n, err := parseChunk(t, "%<div>{1\n2}</div>", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 17}},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupPatternInterpolation{
									NodeBase: ast.NodeBase{
										NodeSpan{7, 10},
										&sourcecode.ParsingError{UnspecifiedParsingError, MARKUP_INTERP_SHOULD_CONTAIN_A_SINGLE_EXPR},
										false,
									},
									Expr: &ast.IntLiteral{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 8}},
										Raw:      "1",
										Value:    1,
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{11, 11}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{11, 17}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{13, 16}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("error within interpolation", func(t *testing.T) {
			n, err := parseChunk(t, "%<div>{?}2</div>", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 16}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{Span: NodeSpan{1, 16}},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupPatternInterpolation{
									NodeBase: ast.NodeBase{NodeSpan{7, 8}, nil, false},
									Expr: &ast.MissingExpression{
										NodeBase: ast.NodeBase{
											NodeSpan{7, 8},
											&sourcecode.ParsingError{MissingExpr, fmtExprExpectedHere([]rune("...div>{?"), 8, true)},
											false,
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{9, 10}, nil, false},
									Raw:      "2",
									Value:    "2",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{10, 16}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{12, 15}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("leading child element", func(t *testing.T) {
			n := mustparseChunk(t, "%<div><span>1</span>2</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 27}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 27}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 6}, nil, false},
									Raw:      "",
									Value:    "",
								},
								&ast.MarkupPatternElement{
									NodeBase: ast.NodeBase{NodeSpan{6, 20}, nil, false},
									Opening: &ast.MarkupPatternOpeningTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{6, 12}},
										Name: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{7, 11}, nil, false},
											Name:       "span",
											Unprefixed: true,
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{NodeSpan{12, 13}, nil, false},
											Raw:      "1",
											Value:    "1",
										},
									},
									Closing: &ast.MarkupPatternClosingTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{13, 20}},
										Name: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{15, 19}, nil, false},
											Name:       "span",
											Unprefixed: true,
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{20, 21}, nil, false},
									Raw:      "2",
									Value:    "2",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{21, 27}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{23, 26}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("linefeed followed by child element", func(t *testing.T) {
			n := mustparseChunk(t, "%<div>\n<span>1</span>2</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 28}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupPatternElement{
									NodeBase: ast.NodeBase{NodeSpan{7, 21}, nil, false},
									Opening: &ast.MarkupPatternOpeningTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 13}},
										Name: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{8, 12}, nil, false},
											Name:       "span",
											Unprefixed: true,
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{NodeSpan{13, 14}, nil, false},
											Raw:      "1",
											Value:    "1",
										},
									},
									Closing: &ast.MarkupPatternClosingTag{
										NodeBase: ast.NodeBase{Span: NodeSpan{14, 21}},
										Name: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{16, 20}, nil, false},
											Name:       "span",
											Unprefixed: true,
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{21, 22}, nil, false},
									Raw:      "2",
									Value:    "2",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{22, 28}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{24, 27}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized with unexpected closing tag followed by the closing tag of the outer element", func(t *testing.T) {
			n, err := parseChunk(t, "pattern p = (<div><ul></ol></div>)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 34}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 34}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.MarkupPatternExpression{
							NodeBase: ast.NodeBase{NodeSpan{13, 33}, nil, true},
							Element: &ast.MarkupPatternElement{
								NodeBase: ast.NodeBase{NodeSpan{13, 33}, nil, false},
								Opening: &ast.MarkupPatternOpeningTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{13, 18}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{14, 17}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
								Children: []ast.Node{
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{18, 18}, nil, false},
										Raw:      "",
										Value:    "",
									},
									&ast.MarkupPatternElement{
										NodeBase: ast.NodeBase{NodeSpan{18, 27}, nil, false},
										Opening: &ast.MarkupPatternOpeningTag{
											NodeBase: ast.NodeBase{Span: NodeSpan{18, 22}},
											Name: &ast.PatternIdentifierLiteral{
												NodeBase:   ast.NodeBase{NodeSpan{19, 21}, nil, false},
												Name:       "ul",
												Unprefixed: true,
											},
										},
										Children: []ast.Node{
											&ast.MarkupText{
												NodeBase: ast.NodeBase{NodeSpan{22, 22}, nil, false},
												Raw:      "",
												Value:    "",
											},
										},
										Closing: &ast.MarkupPatternClosingTag{
											NodeBase: ast.NodeBase{
												NodeSpan{22, 27},
												&sourcecode.ParsingError{UnspecifiedParsingError, fmtExpectedClosingTag("ul")},
												false,
											},
											Name: &ast.PatternIdentifierLiteral{
												NodeBase:   ast.NodeBase{NodeSpan{24, 26}, nil, false},
												Name:       "ol",
												Unprefixed: true,
											},
										},
									},
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{27, 27}, nil, false},
										Raw:      "",
										Value:    "",
									},
								},
								Closing: &ast.MarkupPatternClosingTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{27, 33}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{29, 32}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized with unexpected closing tag followed by a space followed by the valid closing tag of the outer element", func(t *testing.T) {
			n, err := parseChunk(t, "pattern p = (<div><ul></ol> </div>)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 35}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 35}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.MarkupPatternExpression{
							NodeBase: ast.NodeBase{NodeSpan{13, 34}, nil, true},
							Element: &ast.MarkupPatternElement{
								NodeBase: ast.NodeBase{NodeSpan{13, 34}, nil, false},
								Opening: &ast.MarkupPatternOpeningTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{13, 18}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{14, 17}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
								Children: []ast.Node{
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{18, 18}, nil, false},
										Raw:      "",
										Value:    "",
									},
									&ast.MarkupPatternElement{
										NodeBase: ast.NodeBase{NodeSpan{18, 27}, nil, false},
										Opening: &ast.MarkupPatternOpeningTag{
											NodeBase: ast.NodeBase{Span: NodeSpan{18, 22}},
											Name: &ast.PatternIdentifierLiteral{
												NodeBase:   ast.NodeBase{NodeSpan{19, 21}, nil, false},
												Name:       "ul",
												Unprefixed: true,
											},
										},
										Children: []ast.Node{
											&ast.MarkupText{
												NodeBase: ast.NodeBase{NodeSpan{22, 22}, nil, false},
												Raw:      "",
												Value:    "",
											},
										},
										Closing: &ast.MarkupPatternClosingTag{
											NodeBase: ast.NodeBase{
												NodeSpan{22, 27},
												&sourcecode.ParsingError{UnspecifiedParsingError, fmtExpectedClosingTag("ul")},
												false,
											},
											Name: &ast.PatternIdentifierLiteral{
												NodeBase:   ast.NodeBase{NodeSpan{24, 26}, nil, false},
												Name:       "ol",
												Unprefixed: true,
											},
										},
									},
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{27, 28}, nil, false},
										Raw:      " ",
										Value:    " ",
									},
								},
								Closing: &ast.MarkupPatternClosingTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{28, 34}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{30, 33}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("parenthesized with unexpected closing tag followed by a sibling element", func(t *testing.T) {
			n, err := parseChunk(t, "pattern p = (<div><ul></ol><a></a></div>)", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 41}, nil, false},
				Statements: []ast.Node{
					&ast.PatternDefinition{
						NodeBase: ast.NodeBase{NodeSpan{0, 41}, nil, false},
						Left: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{8, 9}, nil, false},
							Name:       "p",
							Unprefixed: true,
						},
						Right: &ast.MarkupPatternExpression{
							NodeBase: ast.NodeBase{NodeSpan{13, 40}, nil, true},
							Element: &ast.MarkupPatternElement{
								NodeBase: ast.NodeBase{NodeSpan{13, 40}, nil, false},
								Opening: &ast.MarkupPatternOpeningTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{13, 18}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{14, 17}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
								Children: []ast.Node{
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{18, 18}, nil, false},
										Raw:      "",
										Value:    "",
									},
									&ast.MarkupPatternElement{
										NodeBase: ast.NodeBase{NodeSpan{18, 27}, nil, false},
										Opening: &ast.MarkupPatternOpeningTag{
											NodeBase: ast.NodeBase{Span: NodeSpan{18, 22}},
											Name: &ast.PatternIdentifierLiteral{
												NodeBase:   ast.NodeBase{NodeSpan{19, 21}, nil, false},
												Name:       "ul",
												Unprefixed: true,
											},
										},
										Children: []ast.Node{
											&ast.MarkupText{
												NodeBase: ast.NodeBase{NodeSpan{22, 22}, nil, false},
												Raw:      "",
												Value:    "",
											},
										},
										Closing: &ast.MarkupPatternClosingTag{
											NodeBase: ast.NodeBase{
												NodeSpan{22, 27},
												&sourcecode.ParsingError{UnspecifiedParsingError, fmtExpectedClosingTag("ul")},
												false,
											},
											Name: &ast.PatternIdentifierLiteral{
												NodeBase:   ast.NodeBase{NodeSpan{24, 26}, nil, false},
												Name:       "ol",
												Unprefixed: true,
											},
										},
									},
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{27, 27}, nil, false},
										Raw:      "",
										Value:    "",
									},
									&ast.MarkupPatternElement{
										NodeBase: ast.NodeBase{NodeSpan{27, 34}, nil, false},
										Opening: &ast.MarkupPatternOpeningTag{
											NodeBase: ast.NodeBase{Span: NodeSpan{27, 30}},
											Name: &ast.PatternIdentifierLiteral{
												NodeBase:   ast.NodeBase{NodeSpan{28, 29}, nil, false},
												Name:       "a",
												Unprefixed: true,
											},
										},
										Children: []ast.Node{
											&ast.MarkupText{
												NodeBase: ast.NodeBase{NodeSpan{30, 30}, nil, false},
												Raw:      "",
												Value:    "",
											},
										},
										Closing: &ast.MarkupPatternClosingTag{
											NodeBase: ast.NodeBase{Span: NodeSpan{30, 34}},
											Name: &ast.PatternIdentifierLiteral{
												NodeBase:   ast.NodeBase{NodeSpan{32, 33}, nil, false},
												Name:       "a",
												Unprefixed: true,
											},
										},
									},
									&ast.MarkupText{
										NodeBase: ast.NodeBase{NodeSpan{34, 34}, nil, false},
										Raw:      "",
										Value:    "",
									},
								},
								Closing: &ast.MarkupPatternClosingTag{
									NodeBase: ast.NodeBase{Span: NodeSpan{34, 40}},
									Name: &ast.PatternIdentifierLiteral{
										NodeBase:   ast.NodeBase{NodeSpan{36, 39}, nil, false},
										Name:       "div",
										Unprefixed: true,
									},
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("region headers: one header followed by a linefeed + the closing tag", func(t *testing.T) {
			n := mustparseChunk(t, "%<div>\n@'a'\n</div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 18}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 18}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							RegionHeaders: []*ast.AnnotatedRegionHeader{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
									Text: &ast.AnnotatedRegionHeaderText{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
										Raw:      "@'a'",
										Value:    "a",
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{12, 18}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{14, 17}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("region headers: one header followed by EOF", func(t *testing.T) {
			n, err := parseChunk(t, "%<div>\n@'a'", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{
								NodeSpan{1, 11},
								&sourcecode.ParsingError{UnspecifiedParsingError, fmtExpectedClosingTag("div")},
								false,
							},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							RegionHeaders: []*ast.AnnotatedRegionHeader{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
									Text: &ast.AnnotatedRegionHeaderText{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
										Raw:      "@'a'",
										Value:    "a",
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{11, 11}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("region headers: one header followed by a linefeed + an opening tag", func(t *testing.T) {
			n := mustparseChunk(t, "%<div>\n@'a'\n<a></a></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 25}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 25}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							RegionHeaders: []*ast.AnnotatedRegionHeader{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
									Text: &ast.AnnotatedRegionHeaderText{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
										Raw:      "@'a'",
										Value:    "a",
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{11, 12}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupPatternElement{
									NodeBase: ast.NodeBase{NodeSpan{12, 19}, nil, false},
									Opening: &ast.MarkupPatternOpeningTag{
										NodeBase: ast.NodeBase{NodeSpan{12, 15}, nil, false},
										Name: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{13, 14}, nil, false},
											Name:       "a",
											Unprefixed: true,
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{NodeSpan{15, 15}, nil, false},
											Raw:      "",
											Value:    "",
										},
									},
									Closing: &ast.MarkupPatternClosingTag{
										NodeBase: ast.NodeBase{NodeSpan{15, 19}, nil, false},
										Name: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{17, 18}, nil, false},
											Name:       "a",
											Unprefixed: true,
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{19, 19}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{19, 25}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{21, 24}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("region headers: one header with annotations followed by a linefeed + an opening tag", func(t *testing.T) {
			n := mustparseChunk(t, "%<div>\n@'a' @a\n<a></a></div>")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 28}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 28}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							RegionHeaders: []*ast.AnnotatedRegionHeader{
								{
									NodeBase: ast.NodeBase{Span: NodeSpan{7, 14}},
									Text: &ast.AnnotatedRegionHeaderText{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
										Raw:      "@'a'",
										Value:    "a",
									},
									Annotations: &ast.MetadataAnnotations{
										NodeBase: ast.NodeBase{Span: NodeSpan{12, 14}},
										Expressions: []ast.Node{
											&ast.MetaIdentifier{
												NodeBase: ast.NodeBase{Span: NodeSpan{12, 14}},
												Name:     "a",
											},
										},
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{14, 15}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupPatternElement{
									NodeBase: ast.NodeBase{NodeSpan{15, 22}, nil, false},
									Opening: &ast.MarkupPatternOpeningTag{
										NodeBase: ast.NodeBase{NodeSpan{15, 18}, nil, false},
										Name: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{16, 17}, nil, false},
											Name:       "a",
											Unprefixed: true,
										},
									},
									Children: []ast.Node{
										&ast.MarkupText{
											NodeBase: ast.NodeBase{NodeSpan{18, 18}, nil, false},
											Raw:      "",
											Value:    "",
										},
									},
									Closing: &ast.MarkupPatternClosingTag{
										NodeBase: ast.NodeBase{NodeSpan{18, 22}, nil, false},
										Name: &ast.PatternIdentifierLiteral{
											NodeBase:   ast.NodeBase{NodeSpan{20, 21}, nil, false},
											Name:       "a",
											Unprefixed: true,
										},
									},
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{22, 22}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{22, 28}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{24, 27}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})

		t.Run("region headers: one header directly followed by the closing tag", func(t *testing.T) {
			n, err := parseChunk(t, "%<div>\n@'a'</div>", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
				Statements: []ast.Node{
					&ast.MarkupPatternExpression{
						NodeBase: ast.NodeBase{NodeSpan{0, 17}, nil, false},
						Element: &ast.MarkupPatternElement{
							NodeBase: ast.NodeBase{NodeSpan{1, 17}, nil, false},
							Opening: &ast.MarkupPatternOpeningTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{1, 6}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{2, 5}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
							RegionHeaders: []*ast.AnnotatedRegionHeader{
								{
									NodeBase: ast.NodeBase{
										NodeSpan{7, 11},
										&sourcecode.ParsingError{UnspecifiedParsingError, MISSING_LINEFEED_AFTER_ANNOTATED_REGION_HEADER},
										false,
									},
									Text: &ast.AnnotatedRegionHeaderText{
										NodeBase: ast.NodeBase{Span: NodeSpan{7, 11}},
										Raw:      "@'a'",
										Value:    "a",
									},
								},
							},
							Children: []ast.Node{
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{6, 7}, nil, false},
									Raw:      "\n",
									Value:    "\n",
								},
								&ast.MarkupText{
									NodeBase: ast.NodeBase{NodeSpan{11, 11}, nil, false},
									Raw:      "",
									Value:    "",
								},
							},
							Closing: &ast.MarkupPatternClosingTag{
								NodeBase: ast.NodeBase{Span: NodeSpan{11, 17}},
								Name: &ast.PatternIdentifierLiteral{
									NodeBase:   ast.NodeBase{NodeSpan{13, 16}, nil, false},
									Name:       "div",
									Unprefixed: true,
								},
							},
						},
					},
				},
			}, n)
		})
	})

	t.Run("extend statement", func(t *testing.T) {
		t.Run("unprefixed named pattern", func(t *testing.T) {
			n := mustparseChunk(t, "extend user {}")
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 14}, nil, false},
				Statements: []ast.Node{
					&ast.ExtendStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 14},
							nil,
							false,
						},
						ExtendedPattern: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{7, 11}, nil, false},
							Unprefixed: true,
							Name:       "user",
						},
						Extension: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{12, 14}},
						},
					},
				},
			}, n)
		})

		t.Run("extension should be an object literal", func(t *testing.T) {
			n, err := parseChunk(t, "extend user 1", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 13}, nil, false},
				Statements: []ast.Node{
					&ast.ExtendStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 13},
							nil,
							false,
						},
						ExtendedPattern: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{7, 11}, nil, false},
							Unprefixed: true,
							Name:       "user",
						},
						Extension: &ast.IntLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{12, 13},
								&sourcecode.ParsingError{UnspecifiedParsingError, INVALID_EXTENSION_VALUE_AN_OBJECT_LITERAL_WAS_EXPECTED},
								false,
							},
							Raw:   "1",
							Value: 1,
						},
					},
				},
			}, n)
		})

		t.Run("missing extended pattern: 'extend' at end of file", func(t *testing.T) {
			n, err := parseChunk(t, "extend", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 6}, nil, false},
				Statements: []ast.Node{
					&ast.ExtendStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							&sourcecode.ParsingError{UnterminatedExtendStmt, UNTERMINATED_EXTEND_STMT_MISSING_PATTERN_TO_EXTEND_AFTER_KEYWORD},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("missing extended pattern: 'extend' followed by line feed", func(t *testing.T) {
			n, err := parseChunk(t, "extend\n", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 7},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.ExtendStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 6},
							&sourcecode.ParsingError{UnterminatedExtendStmt, UNTERMINATED_EXTEND_STMT_MISSING_PATTERN_TO_EXTEND_AFTER_KEYWORD},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("missing extended pattern: 'extend' followed by carriage return + line feed", func(t *testing.T) {
			n, err := parseChunk(t, "extend\r\n", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 8},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.ExtendStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 7},
							&sourcecode.ParsingError{UnterminatedExtendStmt, UNTERMINATED_EXTEND_STMT_MISSING_PATTERN_TO_EXTEND_AFTER_KEYWORD},
							false,
						},
					},
				},
			}, n)
		})

		t.Run("missing extension: pattern at end of file", func(t *testing.T) {
			n, err := parseChunk(t, "extend user", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{NodeSpan{0, 11}, nil, false},
				Statements: []ast.Node{
					&ast.ExtendStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							&sourcecode.ParsingError{UnterminatedExtendStmt, UNTERMINATED_EXTEND_STMT_MISSING_OBJECT_LITERAL_AFTER_EXTENDED_PATTERN},
							false,
						},
						ExtendedPattern: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{7, 11}, nil, false},
							Unprefixed: true,
							Name:       "user",
						},
					},
				},
			}, n)
		})

		t.Run("missing extension: pattern followed by line feed", func(t *testing.T) {
			n, err := parseChunk(t, "extend user\n", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 12},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.ExtendStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							&sourcecode.ParsingError{UnterminatedExtendStmt, UNTERMINATED_EXTEND_STMT_MISSING_OBJECT_LITERAL_AFTER_EXTENDED_PATTERN},
							false,
						},
						ExtendedPattern: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{7, 11}, nil, false},
							Unprefixed: true,
							Name:       "user",
						},
					},
				},
			}, n)
		})

		t.Run("missing extension: pattern followed by carriage return + line feed", func(t *testing.T) {
			n, err := parseChunk(t, "extend user\r\n", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 13},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.ExtendStatement{
						NodeBase: ast.NodeBase{
							NodeSpan{0, 11},
							&sourcecode.ParsingError{UnterminatedExtendStmt, UNTERMINATED_EXTEND_STMT_MISSING_OBJECT_LITERAL_AFTER_EXTENDED_PATTERN},
							false,
						},
						ExtendedPattern: &ast.PatternIdentifierLiteral{
							NodeBase:   ast.NodeBase{NodeSpan{7, 11}, nil, false},
							Unprefixed: true,
							Name:       "user",
						},
					},
				},
			}, n)
		})

		t.Run("the extended pattern should be a named pattern", func(t *testing.T) {
			n, err := parseChunk(t, "extend ({}) {}", "")
			assert.Error(t, err)
			assert.EqualValues(t, &ast.Chunk{
				NodeBase: ast.NodeBase{
					NodeSpan{0, 14},
					nil,
					false,
				},
				Statements: []ast.Node{
					&ast.ExtendStatement{
						NodeBase: ast.NodeBase{Span: NodeSpan{0, 14}},
						ExtendedPattern: &ast.ObjectPatternLiteral{
							NodeBase: ast.NodeBase{
								NodeSpan{8, 10},
								&sourcecode.ParsingError{UnspecifiedParsingError, A_PATTERN_NAME_WAS_EXPECTED},
								true,
							},
						},
						Extension: &ast.ObjectLiteral{
							NodeBase: ast.NodeBase{Span: NodeSpan{12, 14}},
						},
					},
				},
			}, n)
		})
	})

}

func parseChunkForgetTokens(s, name string, opts ...ParserOptions) (*ast.Chunk, error) {
	c, err := ParseChunk(s, name, opts...)
	if c != nil {
		c.Tokens = nil
		ast.Walk(c, func(node, parent, scopeNode ast.Node, ancestorChain []ast.Node, after bool) (ast.TraversalAction, error) {
			if mod, ok := node.(*ast.EmbeddedModule); ok {
				mod.Tokens = nil
			}
			return ast.ContinueTraversal, nil
		}, nil)
	}
	return c, err
}

func mustParseChunkForgetTokens(s string, opts ...ParserOptions) *ast.Chunk {
	c := MustParseChunk(s, opts...)
	c.Tokens = nil
	ast.Walk(c, func(node, parent, scopeNode ast.Node, ancestorChain []ast.Node, after bool) (ast.TraversalAction, error) {
		if mod, ok := node.(*ast.EmbeddedModule); ok {
			mod.Tokens = nil
		}
		return ast.ContinueTraversal, nil
	}, nil)
	return c
}

func TestParseSystematicCheckAndAlreadyDoneContext(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	cancel()

	mustParseChunk := func(t *testing.T, str string) (result *ast.Chunk) {
		err := (func() (err error) {
			defer func() {
				e := recover()
				if er, ok := e.(error); ok {
					err = er
				}
			}()
			mustParseChunkForgetTokens(str, ParserOptions{
				NoCheckFuel:   1, //check context every major function call during parsing.
				ParentContext: ctx,
			})
			return
		})()

		assert.ErrorContains(t, err, context.Canceled.Error())

		return mustParseChunkForgetTokens(str)
	}

	parseChunk := func(t *testing.T, str, name string) (result *ast.Chunk, e error) {
		_, err := ParseChunk(str, name, ParserOptions{
			NoCheckFuel:   1, //check context every major function call during parsing.
			ParentContext: ctx,
		})

		assert.ErrorContains(t, err, context.Canceled.Error())

		return parseChunkForgetTokens(str, name)
	}

	testParse(t, mustParseChunk, parseChunk)
}

func TestParseNonSystematicCheckAndAlreadyDoneContext(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	cancel()

	mustParseChunk := func(t *testing.T, str string) (result *ast.Chunk) {
		err := (func() (err error) {
			defer func() {
				e := recover()
				if er, ok := e.(error); ok {
					err = er
				}
			}()
			mustParseChunkForgetTokens(str, ParserOptions{
				NoCheckFuel:   2, //check context every 2 major function calls during parsing.
				ParentContext: ctx,
			})
			return
		})()

		assert.ErrorContains(t, err, context.Canceled.Error())

		return mustParseChunkForgetTokens(str)
	}

	parseChunk := func(t *testing.T, str, name string) (result *ast.Chunk, e error) {
		_, err := parseChunkForgetTokens(str, name, ParserOptions{
			NoCheckFuel:   2, //check context every 2 major function calls during parsing.
			ParentContext: ctx,
		})

		assert.ErrorContains(t, err, context.Canceled.Error())

		return parseChunkForgetTokens(str, name)
	}

	testParse(t, mustParseChunk, parseChunk)
}

func TestParseNonSystematicCheckAndAlreadyDoneContext2(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	cancel()

	const MIN_CONTEXT_CHECK_TEST_NODE_COUNT = 6

	mustParseChunk := func(t *testing.T, str string) (result *ast.Chunk) {
		n := mustParseChunkForgetTokens(str)
		nodeCount := ast.CountNodes(n)

		if nodeCount < MIN_CONTEXT_CHECK_TEST_NODE_COUNT { //ignore context check test.
			return n
		}

		err := (func() (err error) {
			defer func() {
				e := recover()
				if er, ok := e.(error); ok {
					err = er
				}
			}()
			mustParseChunkForgetTokens(str, ParserOptions{
				NoCheckFuel:   nodeCount / 2, //check context somewhere during the parsing.
				ParentContext: ctx,
			})
			return
		})()

		assert.ErrorContains(t, err, context.Canceled.Error())

		return n
	}

	parseChunk := func(t *testing.T, str, name string) (result *ast.Chunk, e error) {
		n, err := parseChunkForgetTokens(str, name)
		nodeCount := ast.CountNodes(n)

		if nodeCount < MIN_CONTEXT_CHECK_TEST_NODE_COUNT { //ignore context check test.
			return n, err
		}

		_, err = parseChunkForgetTokens(str, name, ParserOptions{
			NoCheckFuel:   nodeCount / 2, //check context somewhere during the parsing.
			ParentContext: ctx,
		})

		assert.ErrorContains(t, err, context.Canceled.Error())

		return parseChunkForgetTokens(str, name)
	}

	testParse(t, mustParseChunk, parseChunk)
}

func TestParseSystematicCheckAndVeryShortTimeout(t *testing.T) {
	code := "[" + strings.Repeat("111,", 20_000) + "]"

	_, err := ParseChunk(code, "test", ParserOptions{
		NoCheckFuel:   1, //check context every major function call during parsing.
		ParentContext: context.Background(),
		Timeout:       time.Millisecond,
	})

	assert.ErrorIs(t, err, context.DeadlineExceeded)
}

func TestParseSystematicCheckAndDefaultTimeout(t *testing.T) {
	code := "[" + strings.Repeat("111,", 200_000) + "]"

	_, err := ParseChunk(code, "test", ParserOptions{})

	assert.ErrorIs(t, err, context.DeadlineExceeded)
}

func TestCheckEmbddedModuleTokens(t *testing.T) {
	t.Run("empty: no tokens", func(t *testing.T) {
		chunk := MustParseChunk(`go do {}`)

		embeddedMod := ast.FindNode(chunk, (*ast.EmbeddedModule)(nil), nil)
		assert.Empty(t, embeddedMod.Tokens)
	})

	t.Run("empty: no tokens, missing closing bracket", func(t *testing.T) {
		chunk, _ := ParseChunk(`go do {`, "test")

		embeddedMod := ast.FindNode(chunk, (*ast.EmbeddedModule)(nil), nil)
		assert.Empty(t, embeddedMod.Tokens)
	})

	t.Run("empty: single non-stored token", func(t *testing.T) {
		chunk := MustParseChunk(`go do {1}`)

		embeddedMod := ast.FindNode(chunk, (*ast.EmbeddedModule)(nil), nil)
		assert.Empty(t, embeddedMod.Tokens)
	})

	t.Run("empty: single non-stored token, missing closing bracket", func(t *testing.T) {
		chunk, _ := ParseChunk(`go do {1`, "test")

		embeddedMod := ast.FindNode(chunk, (*ast.EmbeddedModule)(nil), nil)
		assert.Empty(t, embeddedMod.Tokens)
	})

	t.Run("empty: single stored token", func(t *testing.T) {
		chunk, _ := ParseChunk(`go do {?}`, "test")

		embeddedMod := ast.FindNode(chunk, (*ast.EmbeddedModule)(nil), nil)
		assert.Equal(t, []ast.Token{{Type: ast.UNEXPECTED_CHAR, Raw: "?", Span: NodeSpan{7, 8}}}, embeddedMod.Tokens)
	})

	t.Run("empty: single stored token, missing closing bracket", func(t *testing.T) {
		chunk, _ := ParseChunk(`go do {?`, "test")

		embeddedMod := ast.FindNode(chunk, (*ast.EmbeddedModule)(nil), nil)
		assert.Equal(t, []ast.Token{{Type: ast.UNEXPECTED_CHAR, Raw: "?", Span: NodeSpan{7, 8}}}, embeddedMod.Tokens)
	})
}

func TestParseChunkStart(t *testing.T) {
	opts := ParserOptions{Start: true}
	chunk := MustParseChunk("manifest {}", opts)
	assert.NotNil(t, chunk.Manifest)
	assert.Empty(t, chunk.Statements)

	chunk = MustParseChunk("manifest {}\na = 1", opts)
	assert.NotNil(t, chunk.Manifest)
	assert.Empty(t, chunk.Statements)

	chunk = MustParseChunk("manifest {};a = 1", opts)
	assert.NotNil(t, chunk.Manifest)
	assert.Empty(t, chunk.Statements)

	chunk = MustParseChunk("const(C=1)\nmanifest {}; a = 1", opts)
	assert.NotNil(t, chunk.Manifest)
	assert.NotNil(t, chunk.GlobalConstantDeclarations)
	assert.Empty(t, chunk.Statements)

	chunk = MustParseChunk("includable-file", opts)
	assert.NotNil(t, chunk.IncludableChunkDesc)
	assert.Empty(t, chunk.Statements)

	chunk = MustParseChunk("includable-file\nconst(A = 1)\na = 1", opts)
	assert.NotNil(t, chunk.IncludableChunkDesc)
	assert.NotNil(t, chunk.GlobalConstantDeclarations)
	assert.Empty(t, chunk.Statements)

	chunk = MustParseChunk("includable-file;const(A = 1)\na = 1", opts)
	assert.NotNil(t, chunk.IncludableChunkDesc)
	assert.NotNil(t, chunk.GlobalConstantDeclarations)
	assert.Empty(t, chunk.Statements)
}
