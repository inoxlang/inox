context-data:
  title: Context data
  elements:
  - topic: add_ctx_data
    related-topics: [ctx_data]
    text: >
      The `add_ctx_data` function creates a new user data entry in the context. The passed value should
      fall in one of the following categories: sharable, immutable, clonable. Adding an entry with an 
      existing entry's name is not allowed.
    examples:
    - code: |
        user = {name: "foo"}

        # `user` will be shared.
        add_ctx_data(/user, user)
    - code: |
        list = [1, 2, 3]

        # `list` will be cloned.
        add_ctx_data(/list, list)
  - topic: ctx_data
    related-topics: [add_ctx_data]
    text: >
      The `ctx_data` function retrieves the value of a user data entry. `nil` is returned if the entry does not
      exist. A pattern checking the value is accepted as a second argument.
    examples:
    - code: |
        user = ctx_data(/user)
    - code: |
        # ctx_data panics if the value does not match %user.
        user = ctx_data(/user, %user)
functional:
  title: Functional Programming
  elements:
  - topic: map_iterable
    related-topics: [filter_iterable, get_at_most, some, all, none]
    text: The `map_iterable` function creates a list by applying an operation on each element of an iterable
    examples:
    - code: 'map_iterable([{name: "foo"}], .name)'
      output: '["foo"]'
      standalone: true

    - code: 'map_iterable([{a: 1, b: 2, c: 3}], .{a,b})'
      output: '[{a: 1, b: 2}]'
      standalone: true

    - code: 'map_iterable([0, 1, 2], Mapping{0 => "0" 1 => "1"})'
      output: '["0", "1", nil]'
      standalone: true

    - code: 'map_iterable([97, 98, 99], torune)'
      output: "['a', 'b', 'c']"
      standalone: true

    - code: 'map_iterable([0, 1, 2], @($ + 1))'
      output: '[1, 2, 3]'
      standalone: true

  - topic: filter_iterable
    related-topics: [map_iterable, get_at_most, some, all, none]
    text: The `filter_iterable` function creates a list by iterating over an iterable and keeping elements that pass a condition
    examples:
    - code: 'filter_iterable!(["a", "0", 1], %int)'
      output: '[1]'
      standalone: true

    - code: 'filter_iterable!([0, 1, 2], @($ >= 1))'
      output: '[1, 2]'
      standalone: true

  - topic: get_at_most
    related-topics: [filter_iterable, map_iterable, some, all, none]
    text: The `get_at_most` function gets at most the specified number of elements from an iterable
    examples:
    - code: 'get_at_most(1, [])'
      output: '[]'
      standalone: true

    - code: 'get_at_most(3, ["a", "b"])'
      output: '["a", "b"]'
      standalone: true

    - code: 'get_at_most(2, ["a", "b", "c"])'
      output: '["a", "b"]'
      standalone: true

  - topic: some
    related-topics: [map_iterable, filter_iterable, all, none]
    text: The `some` function returns true if and only if at least one element of an iterable passes a condition. For an empty iterable the result is always true.
    examples:
    - code: 'some(["a", "0", 1], %int)'
      output: 'true'
      standalone: true

    - code: "some([0, 1, 2], @($ == 'a'))"
      output: 'false'
      standalone: true

  - topic: all
    related-topics: [map_iterable, filter_iterable, some, none]
    text: The `all` function returns true if and only if all elements of an iterable pass a condition. For an empty iterable the result is always true.
    examples:
    - code: 'all([0, 1, "a"], %int)'
      output: 'false'
      standalone: true

    - code: 'all([0, 1, 2], @($ >= 0))'
      output: 'true'
      standalone: true
      
  - topic: none
    related-topics: [map_iterable, filter_iterable, some, all]
    text: The `none` function returns true if and only if no elements of an iterable pass a condition. For an empty iterable the result is always true.
    examples:
    - code: 'none([0, 1, "a"], %int)'
      output: 'false'
      standalone: true

    - code: 'none([0, 1, 2], @($ < 0))'
      output: 'true'
      standalone: true

  # - topic: sort
  #   text: >
  #     The `sort` function creates a new list by sorting a list of strings or integers, the second argument is an identifier describing
  #     the order. For strings the available orderings are `#lex` (lexicographic) and `#revlex` (same but reversed). For integers the available
  #     orderings are `#asc` (ascending) and `#desc` (descending).
  #   examples:
  #   - code: 'sort([2, 1], #asc)'
  #     output: '[1, 2]'
  #     standalone: true

  #   - code: 'sort(["b", "a"], #lex)'
  #     output: '["a", "b"]'
  #     standalone: true

  - topic: find
    text: The `find` function searches for items matching a pattern at a given location (a string, an iterable, a directory)
    examples:
    - code: 'find %`a+` "a-aa-aaa"'
      output: '["a", "aa", "aaa"]'
      standalone: true

    - code: 'find %./**/*.json ./'
      output: '[./file.json, ./dir/file.json, ./dir/dir/.file.json]'

    - code: find %int ['1', 2, "3"]
      output: '[2]'
      standalone: true
  
  - topic: idt
    text: The idt (identity) function takes a single argument and returns it.

rand:
  elements:
  - topic: rand
    related-topics: [pseudo_rand]
    text: >
      The `rand` function generates/picks a random value in a cryptographically secure way.
      If the argument is a pattern a matching value is returned, if the argument is an indexable an element is picked.
    examples:
    - code: 'rand(%int(0..10))'
      output: '3'
      standalone: true

    - code: 'rand(%str("a"+))'
      output: '"aaaaa"'
      standalone: true

    - code: 'rand(["a", "b"])'
      output: '"b"'
      standalone: true

crypto:
  title: Cryptography
  elements:
  - topic: hash_password
    text: >
      The `hash_password` function hashes a password string using the Argon2id algorithm, it returns a string
      containing: the hash, a random salt and parameters. You can find the implementation in this file: https://github.com/inoxlang/inox/blob/main/internal/globals/crypto.go 
    examples:
    - code: 'hash_password("password")'
      output: '$argon2id$v=19$m=65536,t=1,p=1$xDLqbPJUrCURnSiVYuy/Qg$OhEJCObGgJ2EbcH0a7oE2sfD1+5T2BPRs8SRWkreE00'
      standalone: true

  - topic: check_password
    text: The check_password verifies that a password matches a Argon2id hash.
    related-topics: [hash_password]
    examples:
    - code: 'check_password("password", "$argon2id$v=19$m=65536,t=1,p=1$xDLqbPJUrCURnSiVYuy/Qg$OhEJCObGgJ2EbcH0a7oE2sfD1+5T2BPRs8SRWkreE00")'
      output: 'true'
      standalone: true

  - topic: sha256
    text: The `sha256` function hashes a string or a byte sequence with the SHA-256 algorithm
    examples:
    - code: sha256("string")
      output: '0x[473287f8298dba7163a897908958f7c0eae733e25d2e027992ea2edc9bed2fa8]'
      standalone: true

  - topic: sha384
    text: The `sha384` function hashes a string or a byte sequence with the SHA-384 algorithm
    examples:
    - code: sha384("string")
      output: '0x[36396a7e4de3fa1c2156ad291350adf507d11a8f8be8b124a028c5db40785803ca35a7fc97a6748d85b253babab7953e]'
      standalone: true

  - topic: sha512
    text: The `sha512` function hashes a string or a byte sequence with the SHA-512 algorithm
    examples:
    - code: sha512("string")
      output: '0x[2757cb3cafc39af451abb2697be79b4ab61d63d74d85b0418629de8c26811b529f3f3780d0150063ff55a2beee74c4ec102a2a2731a1f1f7f10d473ad18a6a87]'
      standalone: true

  - topic: rsa
    namespace: true
    text: The rsa namespace contains functions to generate a key pair and encrypt/decrypt using OAEP.
    subtopics:
    - topic: rsa.gen_key
      text: The rsa.gen_key function generates a public/private key pair
      examples:
      - code: 'rsa.gen_key()'
        output: '#{public: "<key>", private: "<secret key>"}'
        standalone: true

    - topic: rsa.encrypt_oaep
      text: The rsa.encrypt_oaep function encrypts a string or byte sequence using a public key
      examples:
      - code: 'rsa.encrypt_oaep("message", public_key)'

    - topic: rsa.decrypt_oaep
      text: The rsa.decrypt_oaep function decrypts a string or byte sequence using a private key
      examples:
      - code: 'rsa.encrypt_oaep(bytes, private_key)'

encoding:
  title: Encodings
  elements:
  - topic: b64
    text: The `b64` function encodes a string or byte sequence to Base64.

  - topic: db64
    text: The `db64` function decodes a byte sequence from Base64.

  - topic: hex
    text: The `hex` function encodes a string or byte sequence to hexadecimal.

  - topic: unhex
    text: The `unhex` function decodes a byte sequence from hexadecimal.

conversion:
  title: Conversion
  elements:
  - topic: tostr
    text: > 
      The `tostr` function converts its argument to a string-like value. The following types
      are supported: bool, int, rune, rune-slice, path, host, url, all bytes-likes, and all string-likes.

  - topic: tostring
    text: > 
      The `tostring` function converts its argument to a string. `tostr` should always be used over `tostring`, unless
      you need a `string`, not a string-like value. The following types
      are supported: bool, int, rune, rune-slice, path, host, url, all bytes-likes, and all string-likes.

  - topic: torune
    text: The `torune` function converts an integral value to a rune.

  - topic: tobyte
    text: The `tobyte` function converts an integer to a byte.

  - topic: tofloat
    text: The `tofloat` function converts an `integral` value (e.g. int, byte, rune count) to a float.

  - topic: toint
    text: The `toint` function converts a float or an `integral` value (e.g. int, byte, rune count) to an integer. An error is thrown if precision has been lost.

  - topic: tobytecount
    text: The `tobytecount` function converts an integer to a byte count. An error is thrown if the provided value is negative.

  - topic: torstream
    text: >
      The `torstream` function creates a readable stream from a value. If the value is readable (string, byte-slice, ...)
      a byte stream is returned. If the value is indexable a stream containing the elements is returned.
      
  - topic: tojson
    related-topics: [topjson, asjson, asjonl]
    text: >
      The `tojson` function returns the JSON representation of an Inox value. 
      The representation depends on the provided pattern (optional second parameter).
      If you want to create a custom JSON (string) see the `asjson` function instead.
    examples:
    - code: 'tojson({a: 1}, %{a: int}) # `{"a":1}`'
      standalone: true
    - code: 'tojson({a: 1}, %object) # `{"a":{"int__value":1}}`'
      standalone: true
    - code: 'tojson({a: 1}) # `{"object__value":{"a":{"int__value":1}}}`'
      standalone: true
  
  - topic: topjson
    related-topics: [tojson, asjson, asjsonl]
    text: The `topjson` function is equivalent to `tojson` but the JSON output is pretty (formatted).

  - topic: asjson
    related-topics: [tojson, topjson, asjsonl]
    text: >
      The `asjson` function returns a JSON string created by stringifying the provided Inox value
      as if it was a JSON value. Only objects, lists, string-like values, integers, floats, boolean, and `nil` are supported.
      If you want to get the JSON representation of an Inox value see the `tojson` function instead.
    examples:
    - code: 'asjson({a: {b: 1}}) # {a: {b: 1}}'
      standalone: true

  - topic: asjsonl
    related-topics: [tojson, topjson, asjsonl]
    text: >
      The `asjsonl` function returns a JSONL string (https://jsonlines.org/) created by stringifying the elements of the provided
      iterables as if they were JSON values. Only objects, lists, string-like values, integers, floats, boolean, and `nil` are supported.
    examples:
    - code: 'asjsonl([ "first line", "second line", 3 ])'
      standalone: true

  - topic: parse
    text: The `parse` function parses a string based on the specified pattern.
    examples:
    - code: 'parse!("1", %int)'

  - topic: split
    text: The `split` function slices a string into all substrings separated by sep. If a pattern is 
      given as a second argument each substring is parsed based on it.
    examples:
    - code: 'split!("a,b", ",")'
      explanation: 'returns ["a", "b"]'
    - code: 'split!("1,2", ",", %int)'
      explanation: 'returns [1, 2]'
    - code: 'split!("first line\nsecond line", "\n")'
      explanation: 'returns ["first line", "second line"]'

time:
  title: Time
  elements:
  - topic: ago
    text: The `ago` function returns the current datetime minus the provided duration.
    examples:
    - code: 'ago(1h)'
      standalone: true

  - topic: now
    text: The `now` function returns the current datetime.

  - topic: time_since
    text: The `time_since` function returns the time elapsed (duration) since the provided datetime. 

  - topic: sleep
    text: The `sleep` function pauses the execution for the given duration.
    examples:
    - code: 'sleep(1s)'
      standalone: true

printing:
  title: Printing
  elements:
  - topic: print
    text: "The `print` function prints its arguments with a space ' ' separation. A `\\n` character is added at the end."

  - topic: fprint
    text: "The `fprint` function writes to the provided writer its arguments with a space ' ' separation. A '\\n' character is added at the end."

log:
  namespace: true
  title: Structured Logging
  elements:
  - topic: log
    text: The log namespace contains functions for structured logging.
  - topic: log.add
    text: >
      The log.add function logs an event that is created from the provided record. The log level is specified with the `lvl` property,
      it defaults to `debug`. The message can be either provided by setting the `msg` property or by adding record elements: each element will be a single part of the message. ⚠️ It is recommended to use the default level (debug) for high frequency events.
    examples:
    - code: |
        # add a log event of level 'debug' with the message 'user created'
        log.add #{"user created"}
      standalone: true

    - code: |
        # add a log event of level 'debug' with the message 'user created'
        log.add #{msg: "user created"}
      standalone: true

    - code: |
        # add a log event of level 'info' with the message 'user created'
        log.add #{lvl: "info", msg: "user created"}
      standalone: true

    - code: |
        id = 100
        # add a log event of level 'debug' with the message 'user 100 created'
        # and a field `id: 100`
        log.add #{"user", id, "created", id: 100}
      standalone: true

bytes-runes:
  title: Bytes and Runes
  elements:
  - topic: mkbytes
    text: The `mkbytes` function allocates a byte-slice of the provided size.
    examples:
    - code: 'mkbytes(1kB)'
      standalone: true

  - topic: Bytes
    text: The `Bytes` function reads a readable (string, byte-slice, ...) and returns a byte-slice.
    examples:
    - code: 'bytes = Bytes("abc")'
      standalone: true

  - topic: Runes
    text: >
      The `Runes` function reads a readable (string, byte-slice, ...) and returns a rune-slice. A rune is a Unicode code point (character).
      See https://go.dev/blog/strings for more details.
    examples:
    - code: 'runes = Runes("abc")'

  - topic: is_space
    text: The `is_space` function returns whether a given rune is a space character (Unicode's White Space property).
    examples:
    - code: "is_space(' ') # true"
      standalone: true

  - topic: Reader
    text: The `Reader` function creates a reader from a readable (string, byte-slice, ...).
    examples:
    - code: |
        reader = Reader("abc")
        bytes = reader.read_all!()

        # abc
        print(tostr(bytes))
      standalone: true

  - topic: RingBuffer
    text: The `RingBuffer` function creates a ring-buffer with a given capacity.
    examples: 
    - code: |
        buffer = RingBuffer(100B)
        buffer.write!("abc")

        # allocate a byte-slice to read from the buffer.
        buf = mkbytes(100B)

        # The read method writes to buf and returns the written slice of buf.
        # Make sure to not modify the returned slice since doing so would mutate buf.
        slice = buffer.read!(buf)

        # abc
        s = tostr(slice)
      standalone: true

string-types:
  title: Email Address
  elements:
  - topic: EmailAddress
    text: > 
      The `EmailAddress` function parses a RFC 5322 email address and returns a normalized `emailaddr` value.
      The normalization algorithm depends on the email provider, for example: `john.doe@gmail.com` is normalized 
      to `johndoe@gmail.com`. The email is not normalized if the provider is not supported, supported providers are 
      listed here: https://github.com/dimuska139/go-email-normalizer?tab=readme-ov-file#supported-providers.
      Internationalized email addresses will be supported in the future.
    examples:
    - code: 'EmailAddress("john.doe@gmail.com")'
      standalone: true

id-types:
  title: ID Parsing
  elements:
  - topic: ULID
    text: The `ULID` function parses the string representation of a ULID and returns an `ulid` value. https://github.com/ulid/spec.
    examples:
    - code: 'ULID("01HNZ7E5R630AD87V7FWSFZ865")'
      standalone: true
  - topic: UUIDv4
    text: The `UUIDv4` function parses the string representation of a UUIDV4 and returns an `uuiv4` value. https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random).
    examples:
    - code: 'UUIDv4("968011a9-52dc-4816-8527-04b737376471")'
      standalone: true

html:
  namespace: true
  title: HTML
  elements:
  - topic: html
    text: The html namespace contains functions to create & manipulate HTML nodes
  - topic: html.find
    text: The html.find function finds all elements matching the specified CSS selector in the specified element.
    examples:
    - code: h1_elems = html.find("h1", html<div> <h1>title</h1> </div>)
  - topic: html.escape
    text: >
      The html.escape function escapes special characters like "<" to become "&lt;".
      It escapes only five such characters: <, >, &, ' and ".
    examples:
    - code: html.escape("<span></span>")
      output: "&lt;span&gt;&lt;/span&gt;"
      standalone: true

  - topic: html.Node
    text: >
      The html.Node factory function creates a node with a given tag. The first argument is the tag name. The second
      argument is an object with several optional parameters (properties): id, class, children. Additional parameters
      depend on the tag: (e.g. href for `<a>`). html.Node is still being developped, for now it only supports additional 
      parameters for `<a>`. It is recommended to use XML expressions with `html` as the namespace instead of using html.Node: 
      calling the function and creating the object argument (description) is not efficient.
    examples:
    - code: html.Node("a", {})
      output: "<a></a>"
      standalone: true

    - code: 'html.Node("a", {id: "link"})'
      output: '<a id="link"></a>'
      standalone: true

    - code: 'html.Node("a", {href: /index.html})'
      output: '<a href="/index.html"></a>'
      standalone: true
      
    - code: 'html.Node("div", {  html<span>text</span> })'
      output: '<div><span>text</span></div>'
      standalone: true

    - code: 'html.Node("div", { children: [ html<span>text</span> ] })'
      output: '<div><span>text</span></div>'
      standalone: true

chrome:
  namespace: true
  title: Browser Automation
  elements:
  - topic: chrome
    related-topics: [chrome.Handle]
    text: chrome namespace

  - topic: chrome.Handle
    text: |
      The `Handle` function creates a new Chrome handle that provides methods to interact with a web browser instance.
      You should call its .close() method when you are finished using it. 
      
      The project server downloads a Chromium browser
      if none is present. The list of checked paths can be found here: https://github.com/inoxlang/inox/blob/main/internal/globals/chrome_ns/download.go#L114C1-L114C43.
      If you are not using the project server you have to install Chrome or Chromium.

      The browser instance always forwards the HTTP requests to a local proxy server that runs inside an Inox process.
      Therefore make sure to add the necessary HTTP permissions in the manifest.
    examples:
    - code: 'chrome.Handle!()'
    subtopic-names: [
      chrome.Handle/nav, chrome.Handle/wait_visible, chrome.Handle/click, chrome.Handle/screenshot, 
      chrome.Handle/screenshot_page, chrome.Handle/html_node, chrome.Handle/close
    ]

  - topic: chrome.Handle/nav
    text: >
      The nav method makes the browser navigate to a page. All HTTP requests made by the browser are checked against the permission system,
      so make sure to add the necessary permissions.
    examples:
    - code: 'handle.nav https://go.dev/'

  - topic: chrome.Handle/wait_visible
    text: The wait_visible method waits until the DOM element matching the selector is visible.
    examples:
    - code: 'handle.wait_visible "div.title"'


  - topic: chrome.Handle/click
    text: The click method makes the browser click on the first DOM element matching the selector.
    examples:
    - code: 'handle.click "button.menu-item"'

  - topic: chrome.Handle/screenshot
    text: The screenshot method takes a screenshot of the first DOM element matching the selector.
    examples:
    - code: 'png_bytes = handle.screenshot!("#content")'

  - topic: chrome.Handle/screenshot_page
    text: The screenshot_page method takes a screenshot of the entire browser viewport.
    examples:
    - code: 'png_bytes = handle.screenshot_page!()'

  - topic: chrome.Handle/html_node
    text: The screenshot method gets the HTML of the first DOM element matching the selector, the result is %html.node not a string.
    examples:
    - code: 'png_bytes = handle.screenshot_page!()'

  - topic: chrome.Handle/close
    text: this method should be called when you are finished using the Chrome handle.

containers:
  title: Data Containers
  elements:
  - topic: Graph
    related-topics: [Tree]
    text: The `Graph` function creates a directed Graph

  - topic: Tree
    related-topics: [Graph]
    text: The `Tree` function creates a tree from a treedata value
    examples:
    - code: 'Tree(treedata "root")'
      explanation: creates a Tree with a single node
      standalone: true

  - topic: Queue
    text: The `Queue` function creates a queue from an iterable
    examples:
    - code: 'Queue([])'
      explanation: creates an empty queue
      standalone: true

    - code: 'Queue([1])'
      explanation: creates a queue with an element 1
      standalone: true

  - topic: Set
    text: >
      The `Set` function creates a set from an iterable, by default only representable (serializable) values are allowed.
      A configuration is accepted as a second argument.

    examples:
    - code: 'Set([])'
      explanation: creates an empty set
      standalone: true

    - code: 'Set([1])'
      explanation: "creates a queue with an element 1"
      standalone: true

    - code: 'Set([], {element: %int})'
      explanation: creates an empty set of integers
      standalone: true

    - code: 'Set([{name: "A"}, {name: "B"}], {uniqueness: .name})'
      explanation: creates a set of values where the identity is defined by the .name property
      standalone: true

  - topic: Map
    text: The `Map` function creates a map from a flat list of entries
    examples:
    - code: 'Map(["key1", 10, "key2", 20])'
      explanation: creates a Map with the entries "key1" -> 10, "key2" -> 20`
      standalone: true

  - topic: Ranking
    text: >
      The `Ranking` function creates a ranking from a flat list of entries.
      An entry is composed of a value and a floating-point score. 
      The value with the highest score has the first rank (0), values with the same score have the same rank.
    examples:
    - code: 'Ranking(["best player", 10.0, "other player", 5.0])'
      explanation: 'creates a Ranking with the following ranks: rank(0) -> "best player", rank(1) -> "other player"'
      standalone: true

    - code: 'Ranking(["best player", 10.0, "other player", 10.0])'
      explanation: 'creates a Ranking with the following ranks: rank(0) -> "best player" & "other player"'
      standalone: true
      
dns:
  namespace: true
  title: DNS
  elements:
  - topic: dns.resolve
    text: The dns.resolve function retrieves DNS records of the given type.
    examples:
    - code: 'dns.resolve!("github.com" "A")'
      explanation: retrieves "A" records for github.com
      standalone: true

tcp:
  namespace: true
  title: TCP
  elements:
  - topic: tcp.connect
    text: The tcp.connect function creates a TCP connection to a given host.
    examples:
    - code: |
        conn = tcp.connect!(://example.com:80)

        conn.write!("GET / HTTP/1.1\nHost: example.com\n\n")
        print tostr(conn.read!())

        conn.close()
      standalone: true

resource:
  namespace: false
  title: Resource Manipulation
  elements:
  - topic: read
    text: > 
      `read` is a general purpose function that reads the content of a file, a directory or an HTTP resource.
      The content is parsed by default, to disable parsing use --raw after the resource's name: a byte slice 
      will be returned instead. The type of content is determined by looking at the extension for files & 
      the Content-Type header for HTTP resources.
    examples:
      - code: 'read ./'
        output: |
          [
            dir/
            file.txt 1kB 
          ]
        explanation: returns a list containing the entries of the directory ./

      - code: 'read ./file.txt'
        output: hello

      - code: 'read ./file.json'
        output: '{"key": "value"}'

      - code: 'read https://jsonplaceholder.typicode.com/posts/1'
        output: |
          {
            "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita....", 
            "id": 1.0, 
            "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit", 
            "userId": 1.0
          }
  - topic: create
    text: `create` is a general purpose function that can create a file, a directory or an HTTP resource.
    examples:
    - code: 'create ./dir/'
    - code: 'create ./empty-file.txt'
    - code: 'create ./file.txt "content"'

  - topic: update
    text: >
      `update` is a general purpose function that updates an existing resource, it has 2 modes: append and replace.
      Replace is the default mode.
    examples:
    - code: 'update ./file.txt append "additional content"'
    - code: update ./file.txt "new content"
    - code: update ./file.txt replace "new content"
    - code: 'update https://example.com/users/100 tojson({name: "foo"})'

  - topic: delete
    text: '`delete` is a general purpose function that deletes a resource, deletion is recursive for directories.'
    examples:
    - code: 'delete ./file.txt'
    - code: 'delete ./dir/'
    - code: 'delete https://example.com/users/100'

  - topic: get
    text: 'The `get` function loads a resource located at the specified URL. `get` only supports databases for now.'
    examples:
    - code: 'get(ldb://main/users)'
      standalone: true
    - code: 'get(ldb://main/users/01HNZ7E5R630AD87V7FWSFZ865)'
      standalone: true

fs:
  namespace: true
  title: Filesystem
  elements:
  - topic: fs
    text: The fs namespace contains functions to interact with the filesystem.

  - topic: fs.mkfile
    text: >
      The fs.mkfile function takes a file path as first argument. It accepts a --readonly switch that causes 
      the created file to not have the write permission ; and a %readable argument that is the content of the file to create.
    examples:
    - code: fs.mkfile ./file.txt
    - code: fs.mkfile ./file.txt "content"

  - topic: fs.mkdir
    text: The fs.mkdir function takes a directory path as first argument & and optional dictionary literal as a second argument.
      The second argument recursively describes the content of the directory.
    examples:
    - code: fs.mkdir ./dir_a/
    - code: |
        dir_content = :{
            ./subdir_1/: [./empty_file]
            ./subdir_2/: :{  
                ./file: "foo"
            }
            ./file: "bar"
        }

        fs.mkdir ./dir_b/ $dir_content

  - topic: fs.read
    text: > 
      The fs.read function behaves exactly like the `read` function but only works on files & directories.
      The content of files is parsed by default, to disable parsing use --raw after the path: a byte slice will be returned instead. 
      The type of content is determined by looking at the extension.

  - topic: fs.read_file
    text: >
      The fs.read function behaves exactly like the `read` function but only works on files.
      The content is parsed by default, to disable parsing use --raw after the path: a
      byte slice will be returned instead. The type of content is determined by
      looking at the extension.

  - topic: fs.ls
    text: >
      The fs.ls function takes a directory path or a path pattern as first argument and returns a list of entries, if no argument is provided
      the ./ directory is used.
    examples:
    - code: 'fs.ls()'
    - code: 'fs.ls ./'
    - code: 'fs.ls %./*.json'

  - topic: fs.rename
    alias: fs.mv
    text: >
      The fs.rename (fs.mv) function renames a file, it takes two path arguments. 
      An error is returned if a file already exists at the target path.

  - topic: fs.cp
    text: >
      The fs.cp function copies a file/dir at a destination or a list of files in a destination directory, the copy is recursive by default.
      As you can see this behaviour is not exactly the same as the cp command on Unix.
      An error is returned if a file or a directory already exists at one of the target paths (recursive).
    examples:
    - code: 'fs.cp ./file.txt ./file_copy.txt'
    - code: 'fs.cp ./dir/ ./dir_copy/'
    - code: 'fs.cp [./file.txt, ./dir/] ./dest_dir/'
      explanation: 'creates ./dest_dir/file.txt and ./dest_dir/dir/ by copying the provided file & directory'

  - topic: fs.exists
    text: 'the fs.exists takes a path as first argument and returns a boolean'

  - topic: fs.isdir
    text: 'the fs.isdir function returns true if there is a directory at the given path'

  - topic: fs.isfile
    text: 'the fs.isfile returns true if there is a regular file at the given path'

  - topic: fs.remove
    alias: fs.rm
    text: 'the fs.remove function removes a file or a directory recursively'

  - topic: fs.glob
    text: 'the fs.glob function takes a globbing path pattern argument (%./a/... will not work) and returns a list of paths matching this pattern.'
    example:
    - code: 'fs.glob %./*.json'
      explanation: 'returns paths of JSON files in the current directory.'

  - topic: fs.find
    text: >
      The fs.find function takes a directory path argument followed by one or more globbing path patterns, 
      it returns a directory entry for each file matching at least one of the pattern.

    examples:
    - code: 'fs.find ./ %./**/*.json'

  - topic: fs.get_tree_data
    text: > 
      The fs.get_tree_data function takes a directory path argument and returns a %treedata value 
      thats contains the file hiearachy of the passed directory.
    examples:
    - code: fs.get_tree_data(./)

http:
  namespace: true
  title: HTTP
  elements:
  - topic: http
    text: >
      The http namespace contains functions to read, modify & delete HTTP resources.
      Most functions accept the --insecure option to ignore certificate errors & the --client option
      to specify an HTTP client to use.
  - topic: http.get
    text: >
      The `http.get` function takes a URL (or host) as first argument and returns an HTTP response.
      The --insecure options causes the function to ignore certificate errors.
    examples:
    - code: 'http.get https://example.com/'

  - topic: http.read
    text: >
      The `http.read` function behaves exactly like the `read` function but only works on HTTP resources.
      By default the type of content is determined by looking at the Content-Type header. You can specify a content type
      by adding a mimetype value such as mime"json".
    examples:
    - code: 'http.read https://jsonplaceholder.typicode.com/posts/1'

  - topic: http.exists
    text: 'the http.exists takes a URL (or host) as argument, it sends a HEAD request and returns true if the status code is less than 400.'
  - topic: http.post
    text: > 
      The `http.post` function sends a **POST** request to the specified URL (or host) with the given body value.
      The body value can be a `readable` (e.g. string, byte slice), an object or a list. If an object or list is passed the `Content-Type` 
      is set to JSON, and the body is created with the result of `asjson(<value>)`. A %mimetype value can be specified 
      to change the value of the Content-Type header.
    examples:
    - code: 'http.post https://example.com/data `text` # no Content-Type header is sent'
    - code: 'http.post https://example.com/posts mime"json" `{"title":"hello"}` # Content-Type: application/json is sent'
    - code: 'http.post https://example.com/posts {title: "hello"} # object values are converted to JSON using asjson'
    - code: 'http.post https://example.com/posts [ {title: "hello"} ] # list values are converted to JSON using asjson'

  - topic: http.patch
    text: The `http.patch` function works exactly like `http.post` but sends a **PATCH** request instead.
    related-topics: [http.post]

  - topic: http.delete
    text: The `http.delete` function sends an HTTP DELETE request to the specified URL

  - topic: http.Client
    text: The `http.Client` function creates an HTTP client that can be used in most http.* functions with the --client flag.

    examples:
    - code: 'http.Client{ save-cookies: true }'
      explanation: saves the cookies received in responses, cookies are not persisted
      standalone: true

    - code: 'http.Client{ insecure: true }'
      explanation: ignore certificate errors
      standalone: true

    - code: |
        http.Client{
          request-finalization: :{
            https://example.com : { 
              add-headers: {X-API-KEY: env.initial.API_KEY}
            }
          } 
        }
      explanation: add X-API-KEY header to all requests sent to https://example.com
      standalone: true

  - topic: http.Server
    text: >
      The `http.Server` function creates a listening HTTPS server with a given address & handler. The address should be a HTTPS
      host such as `https://localhost:8080` or `https://0.0.0.0:8080`. The handler can be an function or a Mapping that routes requests. 
      When you send a request to a server listening on localhost add the --insecure flag to ignore certificate errors. When using filesystem routing modules are reloaded each time files are changed in /routes/.
      Also for each page render a nonce is added to the `script-src-elem` CSP directive and to all `<script>` elements in the page's HTML.
      You can learn about the HTTP server here: https://github.com/inoxlang/inox/blob/main/docs/http-server-reference.md
    examples:
    - code: |
        server = http.Server!(https://localhost:8080, {
            routing: {
                static: /static/
                dynamic: /routes/
            }
        })
      explanation: >
         creates an HTTP server at https://localhost:8080 with filesystem routing. The server will look for static files in the /static/ folder
         and dynamic handler modules (.ix files) in the /routes/ folder. Modules are reloaded each time files are changed in /routes/.
         To learn more about filesystem routing see https://github.com/inoxlang/inox/blob/main/docs/http-server-reference.md#filesystem-routing
      standalone: true

    - code: |
        fn handle(rw http.resp-writer, r http.req){
          rw.write_json({ a: 1 })
        }

        server = http.Server!(https://localhost:8080, Mapping {
            /hello => "hello"
            %/... => handle
        })
      explanation: >
        creates an HTTP server at https://localhost:8080, requests to /hello will return 'hello' & other requests will
        be handled by the 'handle' function.
      standalone: true

    - code: |
        fn handle(rw http.resp-writer, r http.req){
            match r.path {
              / {
                  rw.write_json({ a: 1 })
              }
              %/... {
                rw.write_headers(http.status.NOT_FOUND)
              }
            }
        }

        server = http.Server!(https://localhost:8080, handle)
      explanation: >
        creates an HTTP server at https://localhost:8080 that returns a JSON body with {a: 1} for the `/` path 
        and a 404 status for other paths.
      standalone: true

  - topic: http.FileServer
    text: The `http.FileServer` creates an HTTP server that serves static file from a given directory.
    examples:
    - code: http.FileServer!(https://localhost:8080, ./examples/static/)
      explanation: https://localhost:8080/index.html will return the content of the file ./examples/static/index.html

  - topic: http.servefile

  - topic: http.CSP
    text: |
      The `http.CSP` function creates a Content Security Policy with the passed directives and some default directives: 
      all types that are not provided in arguments default to the following:
        - `default-src 'none';`
        - `frame-ancestors 'none';`
        - `frame-src 'none';`
        - `script-src-elem 'self' 'nonce-[page-nonce]>';`
        - `connect-src 'self';`
        - `font-src 'self';`
        - `img-src 'self';`
        - `style-src-elem 'self' 'unsafe-inline';`
    examples:
    - code: "http.CSP{default-src: \"'self'\"}"
      standalone: true

  - topic: http.Result
    text: |
      The `http.Result` function creates an HTTP result that, if returned by a handler, is used by the HTTP server to construct a response.
      The function has several parameters that are all optional:
      - `status`: a status code, defaults to 200.
      - `body` a value that is used to construct the response's body; the Content-Type header is inferred.
      - `headers`: an object `{<header name>: <str> | <strings>}`
      - `session` an `{id: <hex-encoded id string>}` object that is stored in the session storage if the result is returned by a handler;
        if an empty id is provided it is updated with a random one.
    examples:
    - code: "http.Result{status: http.status.BAD_REQUEST}"
      standalone: true

Errors:
  namespace: false
  elements:
  - topic: Error
    text: The `Error` function creates an error from the provided string and an optional immutable data argument.
    examples:
    - code: 'Error("failed to create user")'
      standalone: true

    - code: 'Error("failed to create user", #{user_id: 100})'
      standalone: true

concurrency-exec:
  namespace: false
  title: Concurrency And Execution
  elements:
  - topic: LThreadGroup
    text: The `LThreadGroup` function creates a lightweight thread group. The group supports cancelling
     all lthreads added to it by calling its `cancel_all` method. Added lthreads can be waited for by calling
     the `wait_results` method of the group.
    examples:
    - code: 'LThreadGroup()'
      standalone: true
  - topic: ex
    text: >
      The `ex` function executes a command by name or by path in the OS filesystem. Executing commands requires the appropriate Inox permissions.
      The timeout duration for the execution can be configured by prefixing the command name (or path) with a duration range (e.g. ..5s), 
      it defaults to 500ms.
    examples:
    - code: 'ex echo "hello"'
    - code: 'ex!(#echo, "hello")'
    - code: 'ex!(/bin/echo "hello")'
    - code: 'ex git --log'
    - code: 'ex ..5s rm ./'
  - topic: run
    text: >
      The `run` function executes an Inox script.
    examples:
    - code: 'run ./script.ix'
  - topic: cancel_exec
    text: >
      The `cancel_exec` cancels the execution of the module.
    examples:
    - code: 'cancel_exec()'

integer-utils:
  title: Integer Utils
  namespace: false
  elements:
  - topic: is_even
    text: >
      `is_even` tells whether the provided integer is even, negative values are allowed.
  - topic: is_odd
    text: >
      `is_odd` tells whether the provided integer is odd, negative values are allowed.

min-max:
  namespace: false
  title: Minimum & Maximum  
  elements:
  - topic: minof
    text: >
      `minof` returns the minimum value among its arguments, it supports all comparable values.
    examples:
    - code: minof(1, 2)
      standalone: true
    - code: minof(1ms, 1s)
      standalone: true
  - topic: maxof
    text: >
      `maxof` returns the maximum value among its arguments, it supports all comparable values.
    examples:
    - code: maxof(1, 2)
      standalone: true
    - code: maxof(1ms, 1s)
      standalone: true
  - topic: minmax
    text: >
      `minmax` returns the minimum and maximum values among its arguments, it supports all comparable values.
    examples:
    - code: assign min max = minmax(1, 2)
      standalone: true
    - code: assign min max = minmax(1ms, 1s)
      standalone: true